
MySQL의 성능은 여러 요인이 결정하지만 인덱스 없이는 성능을 달성할 수 없으므로 인덱스는 특별한 존재라고 할 수 있다.

MySQL은 하드웨어 최적화, 인덱스를 활용하여 필요한 데이터에 접근할 때 성능을 발휘합니다.

최적화는 MySQL 측면에서 하드웨어를 효율적으로 활용하게 해주는 다양한 기술과 알고리즘, 데이터 구조를 의미합니다. 최적화는 하드웨어의 성능에 초점을 맞추는 것이며 초점에 따른 효과는 전구와 레이저 사이의 차이와 같습니다. 결과적으로 최적화가 하드웨어보다 MySQL 성능에 더 많은 영향을 미치게 됩니다.

이번 장에서는 5개의 절에 걸쳐 MySQL 인덱스와 인덱싱을 설명합니다.

1. 하드웨어나 MySQL 튜닝에만 관심을 두어서는 안 되는 이유
2. MySQL 인덱스가 무엇이고 어떻게 작동하는지를 시각적으로 소개합니다.
3. MySQL 관점에서 어떻게 인덱스를 생성해야 최대의 효과를 발휘할 수 있을지 생각해 봅니다.
4. 인덱스가 효과를 발휘하지 못하는 일반적인 이유를 다룹니다.
5. MySQL 테이블 조인 알고리즘에 대해 간략하게 설명합니다. 효과적인 테이블 조인은 적절한 인덱스에 의존하게 되는데 그 이유를 알아봅니다.


## 1. 성능 향상과 관련 없는 딴짓

#### 더 좋고 빠른 하드웨어

MySQL 성능이 만족스럽지 않을 때 성능 향상에 도움이 되는지 확인하기 위해 더 좋고 빠른 하드웨어를 사용하는 즉, 스케일업 부터 시작하지 마세요

그러나 합리적으로 스케일업을 해야하는 두 가지 예외 상황이 있는데

- 첫째, 하드웨어 성능 부족으로 명백하게 느린 거라면 적절한 성능의 하드웨어로 스케일업해야 합니다.
- 둘째, 어플리케이션의 사용량이 급증하고 있으며, 하드웨어 스케일업이 애플리케이션 실행에 있어 안정성을 담보하기 위한 임시 방편이라면 이 방법도 시행합니다.

> 이러한 예외 상황이 아니라면 MySQL 성능을 향상시킬 목적으로 취하는 하드웨어 확장은 최후의 선택입니다.
> 전문가들은 제일 먼저 쿼리와 데이터, 접근 패턴, 애플리케이션을 최적화해야 한다는 데 동의합니다. 이러한 최적화가 충분한 성능을 발휘하지 못하 때 비로소 하드웨어 확장을 수행하게 됩니다.


#### MySQL 튜닝

튜닝이란 연구개발을 목적으로 MySQL 시스템 변수를 조정하는 행위로 구체적인 목표와 기준이 있는 실험실 수준의 작업입니다. 일반적으로 벤치마킹에서는 시스템 변수를 조정하여 성능에 미치는 영향을 측정합니다.

구성이란 시스템 변수를 하드웨어와 환경에 적합한 값으로 설정하는 행위입니다. 목표는 변경해야 하는 몇 가지 기본값을 가장 적합한 값으로 구성하는 것입니다.

최적화는 워크로드를 줄이거나 효율성을 높여 MySQL 성능을 향상시키는 행위입니다. 애플리케이션은 사용량이 증가하는 경향이 있으므로 보통 성능 향상을 선택합니다. 그래서 목표는 기존 하드웨어로 더 빠른 응답 시간과 더 많은 용량을 제공하는 것입니다.

> 엔지니어는 튜닝, 구성, 최적화 작업을 모두 수행하므로 용어 구분이 중요하지만, 이 가운데 최적화 작업만이 여러분의 시간 측면에서 효율성을 높이는 방법입니다.


결론적으로 튜닝은 레드헤링이고 구성은 MySQL 8.0에서 자동으로 이루어지므로 우리는 최적화만 수행하면 됩니다.



---


## 2.  MySQL 인덱스 : 시각적 소개

인덱스는 성능에서 핵심이며, 쿼리와 인덱스를 변경하는 방법으로 다양한 성능 문제가 해결됩니다.

#### 테이블은 인덱스다.

앞으로 아래 elem 테이블을 가지고 인덱스를 소개하겠습니다.

```sql
CREATE TABLE `elem` (
	`id` int unsigned NOT NULL,
	`a` char(2) NOT NULL,
	`b` char(2) NOT NULL,
	`c` char(2) NOT NULL,
	PRIMARY KEY (`id`),
	KEY `idx_a_b` (`a`, `b`)
) ENGINE=InnoDB;
```

![[Pasted image 20231128213809.png]]


elem 테이블에는 프라이머리 키를 가진 id 열과 a, b 열로 구성된 비고유 세컨더리 인덱스 이렇게 두 가지 인덱스가 있습니다.

InnoDB 테이블은 프라이머리 키로 구성된 B-Tree 인덱스 입니다. 행은 인덱스 구조에서 리프 노드에 저장된 인덱스 레코드가 됩니다.

아래 그림은 elem 테이블의 B-Tree 인덱스를 매우 간단하게 보여줍니다.

![[Pasted image 20231128213942.png]]


InnoDB 트리 기반 인덱스에 대한 가장 중요한 두 가지는 아래와 같습니다.

- 프라이머리 키 조회는 매우 빠르고 효율적입니다.
- 프라이머리 키는 MySQL 성능에서 핵심적인 역할을 합니다.

세컨더리 인덱스도 B-Tree 인덱스지만 리프 노드는 프라이머리 키 값을 저장합니다.
즉, MySQL이 행을 찾으려고 세컨더리 인덱스를 사용한다면, 전체 행을 읽기 위해 프라이머리 키를 이용하여 두 번째 조회를 수행합니다.

> 테이블은 프라이머리 키를 오직 하나만 가질 수 있습니다. 다른 인덱스는 모두 세컨더리 인덱스입니다.


#### 테이블 접근 방법

MySQL 에서는 테이블이 곧 인덱스이므로 인덱스 조회가 가장 적합하면서 일반적인 테이블 접근 방법입니다. 그러나 때로는 쿼리에 따라 인덱스 조회가 불가능할 때도 있으며, 이때는 인덱스 스캔 또는 테이블 스캔 같은 접근 방법이 유일합니다.


#### 인덱스 조회

인덱스 조회에서는 인덱스의 정렬된 구조와 접근 알고리즘을 활용하여 특정 행이나 행 범위를 찾습니다. 대량의 데이터를 대상으로 한 빠르고 효율적인 접근, 이것이 바로 인덱스가 도입된 목적이므로 가장 빠르면서 효과적인 접근 방법입니다.


#### 인덱스 스캔

인덱스 조회가 불가능할 때 MySQL은 전체 데이터 순차 찾기 같은 억지 기법으로 행을 찾아야 합니다. 즉, 모든 행을 읽고 일치하지 않는 행을 필터링합니다. MySQL은 프라이머리 키로 모든 행을 읽기 전에 세컨더리 인덱스로 행 읽기를 새도합니다. 이를 인덱스 스캔이라고 합니다.


- 풀 인덱스 스캔

인덱스 스캔에는 두 가지 유형이 있습니다. 첫 번째는 풀 인덱스 스캔으로서 MySQL은 인덱스 순서대로 모든 행을 읽습니다.

인덱스 순서대로 모든 행을 읽을 때 생각해보면 세컨더리 인덱스를 순서대로 스캔하는 것은 순차 읽기일 수 있지만, 프라이머리 키 조회는 거의 무작위 읽기입니다.

> 인덱스 순서로 행에 접근한다고 해서 순차 읽기가 보장되는 것은 아니며 무작위 읽기가 발생할 가능성이 높습니다.


- 인덱스 전용 스캔

인덱스 스캔의 두 번째 유형은 인덱스 전용 스캔입니다. MySQL은 인덱스에서 열값을 읽습니다. 이를 위해서는 커버링 인덱스가 필요합니다. 전체 행을 읽기 위해서 프라이머리 키 조회를 해야 하는 상황이 아니므로 풀 인덱스 스캔보다 빠르게 됩니다.

또한 세컨더리 인덱스에서 열값만 읽기에 커버링 인덱스가 필요합니다. 

> 유일한 대안이 풀 테이블 스캔이 아닌 이상 인덱스 스캔으로 최적화하지 마세요. 다른 대안이 있다면 인덱스 스캔을 피하세요



#### 테이블 스캔

풀 테이블 스캔은 프라이머리 키 순서로 모든 행을 읽습니다. MySQL이 인덱스 조회나 인덱스 스캔을 수행할 수 없을 때 테이블 스캔이 유일한 옵션입니다.

> 일반적으로 테이블 스캔을 피하는 것이 최선입니다.

그러나 완전하면서 균형 있게 설명하기 위해 테이블 스캔을 허용하거나 더 나은 경우 두 가지를 들겠습니다.

- 테이블이 작고 접근 빈도가 낮을 때
- 테이블 선택도가 매우 낮을 때

테이블 스캔을 당연하게 여기면 안 됩니다. 일반적으로 성능에 굉장히 나쁩니다.



#### 맨 왼쪽 접두사 요구사항

인덱스를 사용하려면 커리는 인덱스의 맨 왼쪽 접드사, 즉 인덱스 정의에서 지정한 맨 왼쪽 인덱스 여로 시작하는 하나 이상의 인덱스 열을 반드시 사용해야 합니다. 기본적인 인덱스 구조는 인덱스 열 순서에 따라 정렬되므로 맨 왼쪽 접두사가 필요하면 그 순서로만 탐색할 수 있습니다.

![[Pasted image 20231128221633.png]]


인덱스의 열 전체를 사용하는 것이 이상적이지만 필수는 아니며 맨 왼쪽 접두사만 필요합니다.

> 인덱스를 사용하려면 쿼리가 인덱스의 맨 왼쪽 접두사를 사용해야 합니다.


맨 왼쪽 접두사에 대한 요구사항은 두 가지 논리적인 결과를 가져옵니다.

- 첫째, 인덱스 (a, b)와 (b, a)는 서로 다릅니다.
- 둘째, MySQL은 인덱스 (a)와 (a, b) 대신 (a, b, c)를 사용할 가능성이 큽니다.

> 모든 세커더리 인덱스의 끝에는 프라이머리 키가 숨겨져 있습니다. elem 테이블에서 세컨더리 인덱스는 사실상 (a, b, id) 지만 맨 오른쪽 id는 숨겨져 있습니다. MySQL은 세컨더리 인덱스에 추가된 프라이머리 키를 표시하지 않으므로 해당 내용을 알고 있어야 합니다.


#### EXPLAIN : 쿼리 실행 계획

EXPLAIN 명령은 MySQL이 쿼리를 실행하는 방법을 설명하는 쿼리 실행 계획 또는 EXPLAIN 계획을 보여줍니다. 쿼리 실행 계획에는 테이블 조인 순서, 테이블 접근 방법, 인덱스 사용 등 중요한 정보가 포함되어 있습니다.

앞으로 다양한 예제를 통해 설명하도록 하겠습니다.

1. 기존 형식

```sql
EXPLAIN SELECT * FROM elem WHERE id = 1
```

![[Pasted image 20231128222213.png]]


- table 필드
	- table 필드는 테이블 이름이나 참조된 서브 쿼리입니다.
	- 테이블 쿼리에 보여지는 순서가 아니라 MySQL이 결정한 조인 순서로 나열됩니다.

- type 필드
	- type 필드는 테이블 접근 방법이나 인덱스 조회의 접근 유형입니다.
	- ALL은 풀 테이블 스캔을 의미하고
	- index는 인덱스 스캔을 의미합니다.
	- const, ref, range 등 다른 값은 인덱스 조회의 접근 유형입니다.

- possible_keys 피드
	- possible_keys 필드는 쿼리가 맨 왼쪽 접두사를 사용하므로 MySQL이 사용할 수 있는 인덱스를 나열합니다.

- key 필드
	- key 필드는 MySQL이 사용할 인덱스의 이름이거나 인덱스를 사용할 수 없을 때에는 NULL 입니다.
	- MySQL은 많은 요소를 기반으로 최상의 인덱스를 선택하며 그중 일부는 Extra 필드에 표시됩니다.

- ref 필드
	- ref 필드는 인덱스에서 행을 조회하는 데 사용되는 값의 소스를 나열합니다.

- rows 필드
	- rows 필드는 MySQL이 일치하는 행을 찾기 위해 조회할 예상 행의 수입니다.
	- MySQL은 인덱스 통계를 사용하여 행을 추정하므로 실제 값과는 근사하지만 같지는 않을 것입니다.

- Extra 필드
	- Extra 필드는 쿼리 실행 계획에 대한 부가 정보를 제공합니다.
	- 이 필드는 MySQL이 적용할 수 있는 쿼리 최적화를 나타내므로 중요합니다.



#### WHERE

MySQL은 인덱스를 사용하여 WHERE 절의 테이블 조건과 일치하는 행을 찾을 수 있습니다.
테이블 조건은 열과 해당 열값으로 이루어지며, 이 조건과 일치하는 행을 찾거나, 이 조건에 따라 행을 그룹화하고, 집계하고, 또는 정렬하기 위해 사용합니다.


1. 프라이머리 키 조회를 위한 EXPLAIN 계획

```sql
EXPLAIN SELECT * FROM elem WHERE id = 1
```

![[Pasted image 20231128223208.png]]

위 예제에서 key: PRIMARY는 MySQL이 인덱스 조회로 프라이머리 키를 사용할 것임을 확인해 줍니다. 이에 따라 접근 유형은 ALL 또는 index가 아니라, 간단한 프라이머리 키 조회로 예상됩니다.

const 접근 유형은 프라이머리 키나 유니크 세컨더리 인덱스의 모든 인덱스 열에 상수조건이 있을 때만 발생하는 특별한 경우입니다. 결과는 상수 행입니다.


2. 프라이머리 키를 사용하여 범위 접근을 하는 EXPLAIN 계획

```sql
EXPLAIN SELECT * FROM elem WHERE id > 3 AND id < 6 AND c = 'Cd'
```

![[Pasted image 20231128223426.png]]

접근 유형은 범위 스캔(type: range)으로 바뀝니다. 즉, 인덱스를 사용하여 값 범위 사이의 행을 읽습니다. 이때 MySQL은 프라이머리 키를 사용하여 id 열값이 3 ~ 6 사이인 행을 읽습니다.
id 열의 조건이 상수가 아니므로 ref 필드는 NULL 입니다.

Extra 필드의 Using where는 예상대로 일반적인 내용입니다. 이는 MySQL이 WHERE 조건을 사용하여 일치하는 행을 찾는다는 의미입니다. 각 행 읽기에 대해 모든 WHERE 조건이 참이면 행이 일치합니다.
id 열의 조건이 범위를 정의하므로 MySQL이 범위의 행을 일치시키는 데 사용할 것은 실제로 c 열의 조건뿐입니다.



3. 세컨더리 인덱스 조회에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT * FROM elem WHERE a = 'Au'
```

![[Pasted image 20231128223735.png]]


```sql 
EXPLAIN SELECT * FROM elem WHERE a = 'Au' AND b = 'Be'
```

![[Pasted image 20231128223747.png]]


위 예제의 각 EXPLAIN 계획에 대해 key: idx_a_b는 조건이 맨 왼쪽 접두사에 대한 요구사항을 충족하므로 MySQL이 세컨더리 인덱스를 사용함을 확인해 줍니다.

EXPLAIN 계획에서는 ref 접근 유형이 새롭고 중요합니다. 간단히 말해서 ref 접근 유형은 인덱스의 맨 왼쪽 접두사(key 필드)에 대한 동등 조회입니다. 다른 인덱스 조회와 마찬가지로 ref 접근은 조회할 예상 행의 수(rows 필드)가 적절하다면 매우 빠릅니다.

인덱싱되지 않은 열에 대해서 조건이 없지만 MySQL은 인덱스만 사용하여 일치하는 행을 찾을 수 있으므로 Extra: NULL 이 다시 나옵니다.



4. 인덱스 조회와 인덱싱되지 않은 열에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT * FROM elem WHERE a = 'Al' AND c = 'Co'
```

![[Pasted image 20231128224121.png]]

위 쿼리는 MySQL에서 인덱스를 사용하여 a 열의 조건에 대한 행을 조회하고 읽은 다음, c 열의 조건과 일치하는 행을 찾습니다.(Extra: Using where)

> EXPLAIN 에서 출력되는 rows는 모든 테이블 조건과 일치하는 행 수가 아니라 쿼리를 실행할 때 MySQL이 조회할 행 수로 추정한 값입니다.



5. 맨 왼쪽 접두사 없는 WHERE에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT * FROM elem WHERE b= 'Be'
```

![[Pasted image 20231128225654.png]]

위 사진에서 '>' 표시는 인덱스 맨 왼쪽 접두사에 대한 요구사항이 추족되지 않아서 MySQL이 테이블 조건과 인덱스 열을 사용할 수 없음을 나타냅니다.

인덱스가 없으면 MySQL은 풀 테이블 스캔(type: ALL)을 수행해야 합니다. 마찬가지로 rows: 10은 전체 행 수를 반영하고 Extra: Using where 는 mySQL이 b= 'Be' 조건을 사용해 일치하지 않는 행은 필터링한다는 것을 나타냅니다.

위 예제는 최악의 EXPLAIN 계획의 예입니다. type: ALL, possible_keys: NULL 또는 key: NULL이 표시되면 쿼리를 멈추고 분석해야 한다는 의미입니다.




#### GROUP BY

MySQL은 값이 인덱스 순서에 따라 암묵적으로 그룹화되므로 GROUP BY를 최적화하기 위해 인덱스를 사용할 수 있습니다.
GROUP BY a 쿼리는 a 열이 맨 왼쪽 접두사이고 인덱스가 a 열값으로 암묵적으로 그룹화되므로 인덱스 idx_a_b를 사용할 수 있습니다.


1. GROUP BY a 에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT a, COUNT(*) FROM elem GROUP BY a
```

![[Pasted image 20231128230131.png]]

key: idx_a_b 는 MySQL이 인덱스를 사용하여 GROUP BY를 최적화하는지 확인해 줍니다.

Extra 필드의 Using index는 MySQL이 인덱스에서 오직 a 열의 값만 읽고 프라이머리 키에서 전체 행을 읽지 않음을 나타냅니다. 이런 최적화는 커버링 인덱스에서도 다룹니다.

이 쿼리는 인덱스를 사용하지만 인덱스 조회에는 사용하지 않습니다. 즉, type: index는 인덱스 스캔을 나타냅니다. 그리고 행을 필터링 하는 WHERE 절이 없으므로 MySQL은 모든 행을 읽습니다.


2. 동일한 인덱스 열의 GROUP BY 와 WHERE에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT a, COUNT(a) FROM elem WHERE a != 'Ar' GROUP BY a 
```

![[Pasted image 20231128230433.png]]

Extra 필드의 Using where는 WHERE a != 'Ar' 을 나타냅니다. 흥미로운 점은 type: range로 바뀌었다는 것입니다. 같지 않음 연산자(!=) 때문에 범위 접근 유형이 작동합니다 즉, WHERE a < 'Ar' AND a > 'Ar' 로 생각할 수 있습니다.



3. 다른 인덱스 열의 GROUP BY와 WHERE에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT a, b FROM elem WHERE b = 'B' GROUP BY a
```

![[Pasted image 20231128230712.png]]


WHERE 절의 b 열에 대한 조건은 다른 SQL 절에 있더라도 조건이 맨 왼쪽 접두사에 대한 요구사항을 충족하므로 인덱스를 여전히 사용할 수 있습니다.



4. 맨 왼쪽 접두사가 없는 GROUP BY에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT b, COUNT(*) FROM elem GROUP BY b
```

![[Pasted image 20231128230904.png]]

key: idx_a_b 를 보면 MySQL은 쿼리가 a 열에 조건이 없음에도 인덱스를 사용한다는 것을 기억해야 합니다.
이는 MySQL이 a 열의 인덱스(type: index)를 스캔하고 있으므로 충족됩니다. a = a와 같이 항상 참인 a 열 조건을 상상해 볼 수 있습니다.

그러면 GROUP BY c 쿼리에 대해 a 열에서 계속 인덱스 스캔을 할까요?? 하지 않습니다. 풀 테이블 스캔을 합니다. 인덱스 b 열값은 있지만 c 열값은 없기 때문입니다.

Extra 필드의 Using temporary는 맨 왼쪽 접두사 조건이라는 엄격한 세트를 가지지 않은 것에 대한 부작용입니다.



#### ORDER BY

MySQL은 ORDER BY를 최적화하기 위해 정렬된 인덱스를 사용할 수 있습니다. 이렇게 최적화하면 순서대로 행에 접근하기 때문에 시간이 조금 더 걸리는 행 정렬을 피할 수 있습니다. MySQL은 행을 정렬할 때 EXPLAIN 계획의 Extra 필드에 Using filesort를 출력합니다. 파일 정렬이란 행 정렬을 의미합니다.

> 행 정렬은 추가 작업이므로 그로 인해 응답 시간이 향상되지는 않습니다.

인덱스를 사용하여 ORDER BY를 최적화하는 방법은 세 가지가 있습니다.

첫 번째이자 가장 간단한 방법은 ORDER BY 절에 인덱스의 맨 왼쪽 접두사를 사용하는 것입니다. elem 테이블이라면 다음처럼 사용할 수 있습니다.

- ORDER BY id
- ORDER BY a
- ORDER BY a, b


두 번째 방법은 인덱스 상수로 맨 왼쪽 부분을 유지하고 다음에 인덱스 열을 기준으로 정렬하는 것입니다.


1. 다른 인덱스 열들의 ORDER BY와 WHERE에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT a, b FROM elem WHERE a = 'Ar' ORDER BY b
```

![[Pasted image 20231128231600.png]]

WHERE a = 'Ar' ORDER BY b 는 첫 번째 인덱스 부분(a 열)의 WHERE 조건이 상수이므로 인덱스 (a, b)를 사용할 수 있습니다. 따라서 MySQL은 인덱스에서 a = 'Ar'로 이동하고 거기에서 b 열값을 순서대로 읽습니다.


세 번째 방법은 두 번째 방법의 특별한 경우입니다.


2. ORDER BY ID에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT * FROM elem WHERE a = 'Al' AND b = 'B' ORDER BY id
```

![[Pasted image 20231128231815.png]]

WHERE 조건이 맨 왼쪽 접두사이므로 쿼리가 idx_a_b 인덱스를 사용하는 것은 이해할 수 있지만, 왜 ORDER BY id 가 파일 정렬을 일으키지 않을까요, 아래 그림에 답이 있습니다.

![[Pasted image 20231128231920.png]]

모든 세컨더리 인덱스의 끝에는 프라이머리 키가 숨겨져 있기 때문입니다.



3. 맨 왼쪽 접두사 없는 ORDER BY 에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT * FROM elem WHERE a = 'Al' ORDER BY id
```

![[Pasted image 20231128232052.png]]

b 열의 조건을 제거하면 MySQL이 ORDER BY를 최적화하기 위해 숨겨진 프라이머리 키를 사용할 수 있도록 하는 세컨더리 인덱스에 더 이상 맨 왼쪽 접두사가 없습니다. 따라서 이 특별한 쿼리는 Extra 필드에 Using filesort 가 나옵니다.


모든 ORDER BY 최적화에 영향을 미치는 중요한 세부 사항이 있습니다. 인덱스 정렬은 기본적으로 오름차순이고 ORDER BY col 은 오름차순을 의미합니다. ORDER BY 최적화는 ASC든지 DESC든지 모든 열에 대해 한 방향으로만 작동합니다. 결과적으로 ORDER BY a, b DESC 에서 a 열은 b DESC 와 달리 ASC 정렬이므로 해당 정렬은 작동하지 않습니다.


- 마지막으로 앞에서 잠깐 언급한 "왜 파일 정렬이 느리다는 평판이 있는가??" 에 대한 답을 하겠습니다.

MySQL은 데이터 정렬이 ort_buffer_size를 초과할 때 디스크의 임시 파일을 사용하게 되고 하드 드라이브는 메모리보다 수십 배 느립니다. 이것은 회전하는 디스크가 일반적이었던 수십 년 전에 특히 그랬습니다.

그러나 오늘날에는 SSD가 표준이며 이 스토리지는 일반적으로 매우 빠릅니다. 파일 정렬은 높은 처리량의 쿼리에 문제가 될 수 있으므로 EXPLAIN ANALYZE를 사용하여 측정하고 확인해야 합니다.



#### 커버링 인덱스

커버링 인덱스에는 쿼리가 참조하는 모든 열이 포함됩니다. 아래 사진은 SELECT 문의 커버링 인덱스를 보여 줍니다.

![[Pasted image 20231128232655.png]]

a와 b 열의 WHERE 조건은 늘 그렇듯 해당 인덱스 열을 가리키지만, 이러한 인덱스 열은 SELECT 절의 해당 열을 다시 가리키기도 하여 인덱스에서 이러한 열값을 읽었음을 나타냅니다.

일반적으로 MySQL은 프라이머리 키에서 전체 행을 읽습니다. 그러나 커버링 인덱스를 사용하면 MySQL은 인덱스에서 열값만 읽을 수 있습니다. 이는 프라이머리 키 조회를 피할 수 있어서 세컨더리 인덱스에 가장 유용합니다.

MySQL은 자동으로 커버링 인덱스 최적화를 사용하며 EXPLAIN은 이를 Extra 필드에 Using index로 보고합니다.

커버링 인덱스는 매력적이지만 실제 쿼리에서는 인덱스 하나가 맡기에는 너무 많은 열과 조건, 절이 있어서 실용적이지 않습니다. 커버링 인덱스를 만드는 데 시간을 낭비하지 마세요. 열 개수가 적은 간단한 쿼리를 설계하거나 분석할 때 커버링 인덱스가 작동하는지 확인해 보는 것으로 충분합니다. 커버링 인덱스에 성능을 기대하는 사람은 아무도 없습니다.



#### 테이블 조인

MySQL은 테이블 조인에 인덱스를 사용하며, 사용법은 다른 것에 인덱스를 사용하는 것과 기본적으로 같습니다. 주요 차이라면 각 테이블의 조인 조건에 사용되는 소스값입니다.

아래 elem_names 테이블을 추가해 보겠습니다.

```sql
CREATE TABLE `elem_names` (
	`symbol` char(2) NOT NULL,
	`name` varchar(16) DEFAULT NULL,
	PRIMARY KEY (`symbol`)
) ENGINE=InnoDB
```

아래 사진은 elem 테이블과 elem_names 테이블을 조인한 쿼리입니다. EXPLAIN과 마찬가지로 이 그림은 조인 순서대로 위에서 아래로 테이블을 나열합니다. 조인 순서에서 테이블 elem은 첫 번째 테이블이고 테이블 elem_names는 두 번째 테이블입니다.

![[Pasted image 20231128233529.png]]

선행 테이블에 조인된 elem_names 테이블에 대한 인덱스 사용의 경우 두 가지 사소한 차이를 보입니다. 이것을 제외하면 기본적으로 같습니다.

첫째, WHERE 절은 JOIN ON 절을 재작성한 것이며 이에 관해서는 나중에 다시 설명하겠습니다.

둘째, symbol 열의 조인 조건에 대해 elem 테이블의 일치하는 행에서 가져온 열값을 사용하여 elem_names 테이블의 행을 조회합니다.
선행 테이블의 값이 주어지면 새롭거나 특별할 것 없이 symbol 열에 대해 프라이머리 키 조회를 합니다. 일치하는 행이 나오면 선행 테이블에서 조인된 행이 반환됩니다.

아래는 위 SELECT 문에 대한 EXPLAIN 계획을 보여 줍니다.

```sql
EXPLAIN SELECT name
	FROM elem JOIN elem_names ON (elem.a = elem_names.symbol)
	WHERE a IN ('Ag', 'Au', 'At')
```

![[Pasted image 20231128234135.png]]

조인의 경우 두 번째 테이블인 elem_names 에서 2개의 새로운 세부 정보가 있습니다

첫 번째는 접근 유형 eq_ref는 프라이머리 키나 유니크 not-null 세컨더리 인덱스를 사용하는 단일 행 조회를 의미합니다. 여기서 not-null은 모든 세컨더리 인덱스 열이 NOT NULL 로 정의됨을 의미합니다.

두 번째는 ref: test.elem.a로 참조 열 elem.a로 읽습니다. (데이터베이스 이름이 test여서 test값이 붙었습니다.) elem_names 테이블을 조인하기 위해 elem.a 참조 열값을 사용하여 조인된 symbol 열의 프라이머리 키로 행을 조회합니다. 이것이 JOIN 조건인 ON(elem.a = elem_names.symbol)에 해당합니다.

> 테이블별로 조인이 인덱스 사용법을 변경하지 않습니다. 주요 차이는 조인 조건의 값이 선행 테이블에서 온다는 것입니다.


MySQL은 어떤 접근 방법이든 사용하여 테이블을 조인할 수 있지만 eq_ref 접근 유형을 사용하는 인덱스 조회가 가장 좋으며 빠릅니다. 이유는 한 행만 일치하기 때문입니다. eq_ref 접근 유형에는 프라이머리 키나 유니크 세컨더리 인덱스와 모든 인덱스 열의 동일 조건이라는 두 가지 요구사항이 있습니다.

이러한 요구사항을 종합하면 eq_ref 조회가 최대 하나의 행과 일치하도록 보장합니다. 두 요구사항이 모두 충족하지 않으면, MySQL은 기본적으로 동일하지만 임의의 행 수와 일치하는 ref 인덱스 조회를 사용하게 됩니다.


MySQL은 쿼리에 작성되는 테이블 순서가 아니라 가능한 한 최상의 순서로 테이블을 조인하므로 테이블 조인 순서가 중요합니다. 테이블 조인 순서를 보려면 EXPLAIN을 사용해야 합니다.
EXPLAIN은 조인 순서에 따라 위에서 아래로 테이블을 출력합니다. 기본 조인 알고리즘인 중첩 반복 조인은 조인 순서를 따릅니다.


쿼리를 조금만 변경해도 테이블 조인 순서나 쿼리 실행 계획이 크게 달라질 수 있으므로 테이블 조인 순서를 추측하거나 추정해서는 안 됩니다. 아래 사진을 확인해보겠습니다.

![[Pasted image 20231128234930.png]]


- 세컨더리 인덱스 조회 시 테이블 조인에 대한 EXPLAIN 계획

```sql
EXPLAIN SELECT name
	FROM elem JOIN elem_names ON (elem.a = elem_names.symbol)
	WHERE a IN ('Ag', 'Au')
```

![[Pasted image 20231128235041.png]]


위 쿼리는 기존에 보았던 JOIN 쿼리와 문법상 같지만 실행 계획은 상당히 다릅니다. IN( ) 목록에서 'At'라는 단일 값이 제거된것 뿐입니다.

실행 계획을 살펴보면 첫 번째 테이블은 elem_names로 elem JOIN elem_names 으로 작성된 쿼리와는 다릅니다. MySQL은 쿼리에 나열된 JOIN 절 순서가 아니라, 내부적으로 테이블 조인 순서를 결정합니다.

아래 사진은 SHOW WARNING 명령에 대한 요약된 출력 내용입니다.

![[Pasted image 20231128235330.png]]

마지막 줄을 보면 MySQL은 원래 쿼리에 작성된 elem.a 대신 elem_names.symbols에 대한 값으로 IN( ) 목록을 사용하도록 쿼리를 재작성합니다. 이제 elem_names.symbols 테이블의 인덱스 사용은 "Ag"와 "Au" 의 두 값을 조회하기 위한 범위 스캔임을 알 수 있습니다.

MySQL이 두 번째 elem 테이블을 조인하는 데 사용할 2개의 행만 일치시키면 되기 때문에 프라이머리 키를 사용하여 매우 빠른 인덱스 조회를 할 수 있습니다.



- 풀 조인을 위한 EXPLAIN 계획

MySQL은 인덱스 없이 테이블 조인을 할 수 있습니다. 이것을 풀 조인이라고 하며 쿼리가 수행할 수 있는 최악의 작업입니다. 단일 테이블 쿼리에 대한 테이블 스캔도 나쁘지만, 조인된 테이블에 대한 테이블 스캔은 한 번 발생하는 것이 아니라 선행 테이블에 일치하는 모든 행에 대해 발생하므로 풀 조인이 더 나쁩니다.

```sql
EXPLAIN SELECT name
	FROM elem STRAIGHT_JOIN elem_names IGNORE INDEX (PRIMARY)
	ON (elem.a = elem_names.symbol)
```

![[Pasted image 20231128235648.png]]


STRAIGHT_JOIN과 IGNORE INDEX(PRIMARY) 키워드는 강제 실행을 위해 작성된 것입니다.

첫 번째 테이블(elem)에 대한 인덱스 전용 스캔은 10개의 행을 모두 가져옵니다. 각 행에 대해 MySQL은 일치하는 행을 찾기 위해 풀 테이블 스캔(type: ALL)을 수행하여 두 번째 테이블(elem_names)을 조인합니다.

이것은 조인된 테이블이므로 테이블 스캔은 풀 조인 횟수로 세어지게 됩니다. 풀 조인은 선행 테이블의 각 행에 대해 조회가 발생하므로 쿼리가 수행할 수 있는 최악의 단일 작업입니다. elem_names 테이블에 대해서는 10번의 풀 테이블 스캔입니다. 

> 조인된 테이블에서 type: ALL이 표시될 때마다 하는 모든 작업을 중지하고 그것부터 수정하세요

조인에는 더 많은 테이블과 인덱스가 포함되지만 테이블별로 인덱스 사용과 요구사항은 같습니다. 맨 왼쪽 접두사에 대한 요구사항도 같습니다. 주요 차이라면 조인된 테이블의 경우 조인 조건값이 선행 테이블에서 온다는 것입니다.



---


## 3. 인덱싱: MySQL 처럼 생각하는 방법

인덱스와 인덱싱은 다른 주제입니다. 지금까지 WHERE, GROUP BY, ORDER BY, 커버링 인덱스, 테이블 조인에 관여하는 InnoDB 테이블의 표준 B-Tree 인덱스를 소개했습니다.

이 절에서는 성능에 최대의 영향력을 발휘하는 인덱싱을 소개합니다. 단순히 모든 열을 인덱싱해서는 탁월한 성능을 발휘할 수는 없습니다. 쿼리를 실행할 때 MySQL이 가장 적은 수의 행에 접근할 수 있도록 열을 인덱싱하는 것이 최선입니다.


#### 쿼리 알기

MySQL 처럼 생각하는 첫 번째 단계는 최적화하려는 쿼리의 기본 정보를 파악하는 것입니다.

다음 질문에 답해보면 도움이 됩니다.

쿼리
- 쿼리는 몇 개의 행에 접근해야 합니까
- 쿼리는 몇 개의 행을 반환해야 합니까
- 어떤 열이 선택됩니까
- GROUP BY, ORDER BY, LIMIT절은 무엇입니까
- 하위 쿼리가 있습니까

테이블 접근(테이블마다)
- 테이블 조건은 무엇입니까
- 쿼리는 어떤 인덱스를 사용해야 합니까
- 쿼리가 사용할 수 있는 다른 인덱스는 무엇입니까
- 각 인덱스의 카디널리티는 무엇입니까
- 테이블의 크기는 얼마입니까

이러한 질문은 MySQL이 수행하는 일이 쿼리 구문 분석이므로 쿼리를 머릿속으로 그려 보면 구문 분석하는 데 도움이 됩니다.


#### EXPLAIN 으로 이해하기

두 번째 단계는 EXPLAIN에서 보고한 현재 쿼리 실행 계획을 이해하는 것입니다. MySQL에서 선택한 인덱스, 즉 EXPLAIN 출력의 key 필드부터 시작하여 인덱스와 관련된 각 테이블과 해당 조건을 고려합니다.

> 항상 쿼리를 EXPLAIN 하세요, EXPLAIN 없이는 직접 쿼리 최적화가 불가능하므로 습관화하세요


쿼리 실행 계획에는 항상 이유가 있습니다. 때때로 MySQL은 매우 영리해서 일반적으로 Extra 필드에서 언급되는, 뻔하지 않은 쿼리 최적화를 사용하기도 합니다.


#### 쿼리 최적화

세 번째 단계는 직접 쿼리 최적화로 쿼리, 인덱스 또는 둘 모두를 변경합니다. 이러한 변경은 프로덕션이 아닌 개발이나 준비 단계에서 이루어지므로 아직 위험하지 않습니다.

쿼리에는 결과와 해당 결과를 얻는 방법이 있습니다. 이 둘은 밀접하게 관련되어 있지만 별개입니다. 쿼리를 어떻게 수정할지 고민하면서 이러한 사실을 아는 것은 상당히 유용합니다.

단순 쿼리가 느릴 때는 쿼리가 아닌 인덱스를 변경해야 할 가능성이 큽니다. 그리고 인덱스 변경으로 문제가 해결되지 않으면 앞으로 뒤 장에서 얘기할 간접 쿼리 최적화로 여정을 옮겨야 합니다. 인덱스 추가나 수정은 접근 방법과 쿼리별 최적화 사이의 절충점입니다.


#### 배포와 검증

마지막 단게는 변경 사항을 배포하고 응답 시간이 개선되는지 검증하는 것입니다. 하지만 먼저 변경 사항으로 인해 의도하지 않은 부작용이 발생할 경우 배포를 되돌릴 방법을 확인하고 준비해야 합니다.


---


## 4. 좋은 인덱스였는데...

아무것도 변경되지 않는다면 좋은 인덱스는 영원히 좋은 인덱스로 남을 것입니다. 하지만 현실적으로는 무언가 변해서 좋은 인덱스를 나쁘게 만들고 성능을 떨어뜨립니다. 이번 절에서는 성능 저하의 일반적인 원인을 알아보겠습니다.


#### 쿼리 변경

쿼리가 변경될 때 맨 왼쪽 접두사에 대한 요구사항이 손실될 수 있습니다. 최악의 경우는 MySQL이 사용할 수 있는 다른 인덱스가 없어서 풀 테이블 스캔을 실행하는 전체 데이터 순차 탐색으로 되돌아갈 때입니다.
이러한 해결책은 새로 변경한 쿼리에 대해 인덱스를 다시 만드는 것입니다.



#### 과도하고 중복되며 사용되지 않음

인덱스는 성능에 있어 필요하지만 때때로 엔지니어는 너무 과도하게 사용해서 결국 과도한 인덱스, 중복 인덱스, 사용되지 않는 인덱스가 만들어지곤 합니다.
인덱스가 얼마나 되어야 너무 많은 걸까요? 바로 필요 이상으로 하나 더 있는 경우 입니다.

인덱스가 많아지면 더 많은 메모리를 사용하므로 아이러니하게도 각 인덱스에 사용할 수 있는 메모리가 줄어듭니다.

두 번째 문제는 MySQL이 데이터를 작성할 때 모든 인덱스를 확인하고 갱신하고, 잠재적으로 재구성해야 하므로 쓰기 성능이 떨어진다는 것입니다. 인덱스 수가 과도하면 쓰기 성능이 심각하게 떨어질 수 있습니다.

인덱스를 삭제할 때는 주의해야 합니다. MySQL 8.0부터 인비저블 인덱스를 사용할 수 있습니다. 인덱스 삭제 전에 인덱스가 사용되지 않거나 필요하지 않은지 확인할 수 있습니다. 인덱스를 보이지 않게 하고 성능에 영향을 미치지 않는지 확인한 다음 인덱스를 삭제하려는 것입니다.



#### 최고의 선택도

카디널리티는 인덱스의 고윳값 수입니다. 선택도는 카디널리티를 테이블의 행 수로 나눈 값입니다. 값 a, a, b, b를 사용하여 각 값이 한 행일 때 인덱스 선택도는 2 / 4 = 0.5 입니다.

선택도는 0 에서 1까지이며, 선택도가 1인 인덱스는 모든 행에 대해 값이 각각인 유니크 인덱스입니다. MySQL은 인덱스 선택도를 표시하지 않습니다. 카디널리티에는 SHOW INDEX를 사용하고 행 수에는 SHOW TABLE STATUS를 사용하여 직접 계산해야 합니다.

선택도가 매우 낮은 인덱스는 각 고윳값이 많은 수의 행과 일치할 수 있으므로 거의 영향력이 없습니다.
쿼리에서 선택도가 매우 낮은 인덱스를 사용하는 경우, 더 나은 선택도를 갖는 인덱스를 만들 수 있는지 확인하거나 더 나은 선택도를 갖는 인덱스를 사용하도록 쿼리를 다시 작성하는 것이 좋습니다.

선택도가 매우 높은 인덱스는 과도하게 활용될 수 있습니다. 비고유 세컨더리 인덱스의 선택도가 1에 가까워지면 인덱스가 고유해야 하는지, 아니면 프라이머리 키를 사용하도록 쿼리를 다시 작성할 수 있는지 의문이 생기기 시작합니다. 이러한 인덱스는 성능을 떨어뜨리지 않지만 대안을 모색할 가치는 있습니다.



#### 이것은 함정이다! - MySQL이 다른 인덱스를 선택할 때

매우 드물지만 MySQL이 인덱스를 잘못 선택하기도 합니다. 이런 경우는 MySQL이 인덱스를 사용하고 있지만 쿼리 응답 시간이 설명할 수 없을 정도로 느릴 때 마지막에 의심할 정도로 드뭅니다.

이런 상황이 발생할 수 있는 이유가 몇 가지 있습니다. 일반적인 이유는 많은 수의 행을 갱신할 때 갱신된 행 수가 인덱스 통계의 자동 갱신을 유발하기에는 조금 모자라기 때문입니다. 인덱스 통계는 MySQL이 어떤 인덱스를 선택할지에 영향을 미치는 많은 요소 중 하나이므로 실제와 크게 다른 인덱스 통계로 인해 MySQL이 잘못된 인덱스를 선택할 수 있습니다. 정확히 말하자면, 인덱스 자체는 결코 부정확하지 않으며 단지 인덱스 통계가 부정확할 뿐입니다.



---


## 5. 테이블 조인 알고리즘

JOIN에 대해 분석하고 최적화하면서 MySQL 테이블 조인 알고리즘을 간략하게나마 알게 된다면 인덱스와 인덱싱을 어떻게 할지 고민할 때 도움이 됩니다.

기본 테이블 조인 알고리즘은 중첩 반복 조인이라고 하며 코드에서 사용하는 중첩 foreach 반복문처럼 작동합니다.

중첩 반복 조인 알고리즘은 간단하고 효과적이지만 한 가지 문제가 있습니다. 가장 안쪽 테이브렝 상당히 자주 접근하고 풀 조인을 사용하면 접근 속도가 매우 느려진다는 것입니다.

블록 중첩 반복 조인 알고리즘이 이 문제를 해결합니다. 기존에 일치하는 행의 조인 열값은 조인 버퍼에 저장됩니다. 조인 버퍼가 가득 차면 MySQL은 마다음 테이블을 스캔하고 조인 버퍼의 조인 열값과 일치하는 각 행을 조인합니다. 조인 버퍼에는 여러 번 접근하지만 메모리에 있어서 상당히 빠르며 중첩 중복 조인 알고리즘에 필요한 100개의 테이블 스캔보다 훨씬 빠릅니다.

MySQL 8.0.20 부터 해시 조인 알고리즘이 블록 중첩 반복 조인 알고리즘을 대체합니다. 해시 조인은 마지막 테이블과 같은 조인 테이블을 메모리 내에 해시 테이블로 생성합니다. MySQL은 해시 테이블을 사용하여 조인 테이블의 행을 조회하는데, 해시 테이블 조회는 상수 시간 연산이기 때문에 매우 빠릅니다.


---


## 요점 정리

이 장에서는 MySQL의 인덱스와 인덱싱을 설명했습니다. 요점은 아래 내용과 같습니다.

- 인덱스는 MySQL 성능에 최고이자 최상의 영향력을 미칩니다.
- 다른 옵션을 모두 사용할 때까지 MySQL 성능을 향상하기 위해 하드웨어를 확장하지 마세요
- 합리적인 구성으로 MySQL 성능을 향상하기 위해 튜닝할 필요는 없습니다.
- InnoDB 테이블은 프라이머리 키로 구성된 B-Tree 인덱스입니다.
- MySQL은 인덱스 조회, 인덱스 스캔, 풀 테이블 스캔을 통해 테이블에 접근합니다. 이 중에서 인덱스 조회가 최선의 접근 방법입니다.
- 인덱스를 사용하려면 쿼리는 인덱스의 맨 왼쪽 접두사를 사용해야 합니다.
- MySQL은 인덱스를 사용하여 WHERE와 일치하는 행을 찾고, GROUP BY에 대해 행을 그룹화하고, ORDER BY에 대해 행을 정렬하고, 커버링 인덱스를 사용하여 행 읽기를 피하고, 테이블을 조인합니다.
- EXPLAIN 은 mySQL이 쿼리를 실행하는 방법을 자세히 설명하는 쿼리 실행 계획을 출력합니다.
- 인덱싱에서는 쿼리 실행 계획을 이해하기 위해 MySQL과 같은 사고 방식이 필요합니다.
- 좋은 인덱스는 다양한 이유로 효율성을 잃을 수 있습니다.
- MySQL은 중첩 반복 조인, 블록 중첩 반복 조인, 해시 조인의 세 가지 알고리즘을 사용하여 테이블을 조인합니다.