
이번 장에서는 일반적인 MySQL 문제와 이를 완화하는 방법을 간략하게 소개합니다. 처음 2가지 문제는 데이터베이스를 망칠 수 있으니 과소 평가하면 안됩니다. 이러한 문제는 특별한 상황에서만 발생하는 것이 아니며 업무를 망칠지도 모르는 일반적인 문제이기 때문에 잘 준비해야 합니다.


---

## 1. 스프릿-브레인이 가장 큰 위험이다.

스플릿-브레인이 똑같은 복제 토폴로지에서 동시에 발생하려면 2가지 조건을 만족해야 합니다.

- 둘 이상의 MySQL 인스턴스에서 쓰기가 가능합니다.(read_only=0)
- 둘 이상의 MySQL 인스턴스에서 쓰기가 발생합니다.

둘 다 일어나서는 안 되고 특히 동시에 발생해서는 안 되지만, 버그나 사고를 영원히 피할 수는 없습니다. 이런 일이 발생할 때 이를 <span style="color:#ff0000">스플릿-브레인</span>이라고 합니다. 모든 MySQL 인스턴스가 같은 데이터를 가지는 대신, 데이터가 모든 인스턴스에서 더 이상 일관되지 않기 때문에 실질적인 분할입니다.

일관되지 않은 데이터는 근본적으로 잘못되었을 뿐만 아니라 복제에 문제가 생기거나 심지어는 이 때문에 더 많은 데이터가 일관되지 않게 되어 다음 문제인 데이터 드리프트가 발생할 수 있습니다.

스프릿-브레인이 발생하면 반드시 감지하고 즉시 중지해야 합니다. 이유는 단일 쓰기가 여러 행에 영향을 미칠 수 있기 때문입니다. 단 몇 초의 스플릿-브레인으로 인해 일관되지 않은 데이터가 쏟아져나올 수 있으며, 그 결과 몇 주 동안 데이터 포렌식(데이터 복구)과 조정이 이루어질 수 있습니다.

스플릿-브레인을 중지하려면 모든 인스턴스에서 쓰기를 비활성화합니다(SET GLOABL read_only=1). 하나의 인스턴스만 쓰기 가능 상태로 두지 마세요. 그러면 문제가 더 나빠집니다. 쓰기를 비활성화할 수 없으면 MySQL이나 서버 종료를 심각하게 고려해야 합니다.

> 데이터 무결성은 데이터 가용성보다 더 중요합니다.

이상적으로는 일치하지 않는 모든 데이터를 찾아 조정할 때까지 전체 데이터베이스를 오프라인으로 전환해야 합니다. 그러나 현실적으로 장기간의 데이터베이스를 중지하면 비즈니스를 망치므로 잠재적으로 잘못된 데이터를 읽어도 더 이상의 손상이 발생하지 않는다고 확신한다면 super_read_only 모드를 사용하여 데이터를 수정하는 동안 MySQL을 읽기 전용 모드(read_only=1)로 실행할 수 있습니다.

일치하지 않는 행을 찾는 방법은 pt-table-sync 를 사용하거나 수동으로 확인하는 두 가지뿐입니다. 행 조정은 어려운 부분이므로 MySQL 전문가와 협력하여 올바르게 수행되었는지 확인해야 합니다. 운이 좋아서 하나의 인스턴스가 신뢰할 만하다면(모든 행에 올바른 데이터가 있음) 확인하고 조정하는 대신 재구성할 수 있습니다. 신뢰할 만한 인스턴스로부터 모든 복제본을 재구성합니다.


---

## 2. 데이터 드리프트는 실제지만 보이지 않는다.

데이터 드리프트는 일관성 없는 데이터를 의미합니다. 하나 이상의 행이 같은 복제 토폴로지의 서로 다른 MySQL 인스턴스에서 서로 다른 값을 가집니다. 스플릿-브레인 시나리오에서 일관되지 않은 데이터는 예상되지만, 데이터 드리프트에서 일관되지 않은 데이터는 예상치 못한 것입니다. 일관되지 않은 데이터가 있는지 모르거나 의심할 이유가 없습니다. 데이터 드리프트는 문제를 초래하지 않는다는 점에서 눈에 보이지 않지만 애플리케이션이 잘못된 값을 반환할 수 있기 때문에 실제로 문제입니다.

이론적으로는 비결정적 쿼리와 명령문 기반 복제나 복제본에 대한 쓰기로 인해 데이터 드리프트가 발생합니다. 테스트에서 이 두 가지로 인해 데이터 드리프트가 발생할 수 있지만 실제 상황에서는 결코 그 원인이 아닌 것 같습니다. 대신 엔지니어와 DBA 모두 데이터 드리프트를 유발하거나 허용하기 위해 수행된 작업이 없다고 확신합니다. 그럼에도 불구하고 데이터 드리프트는 존재합니다.

> pt-table-checksum 을 실행하여 몇 달마다 데이터 드리프트를 확인하세요. 데이터 드리프트가 발견되더라도 걱정하지 말고 행을 조정한 후 한 달 뒤에 다시 확인하세요. 데이터가 계속 드리프트하면(가능성이 매우 낮음) 근본 원인을 찾아 수정하기 위해 자세히 조사할 가치가 있는 문제입니다.


---

## 3. ORM을 믿지 않도록 주의합니다.

객체 관계형 매핑의 목적은 데이터 접근을 프로그래밍 용어와 객체로 추상화하여 프로그래머를 지원하는 것입니다. ORM은 본질적으로 나쁘거나 비효율적이지는 않지만 성능이 목적이 아니므로 ORM 라이브러리에서 생성된 쿼리를 확인해야 합니다. ORM에서 생성된 쿼리가 너무 비효울적이면 ORM 라이브러리 설명서를 읽고 더 효율적인 쿼리를 생성하도록 구성하는 방법을 알아보세요


---

## 4. 스키마는 항상 변경된다.

이 문제를 이미 알고 있을 수도 있지만 관계형 데이터베이스를 처음 사용하는 경우 스키마는 항상 변경됩니다. 사용 중인 스키마를 애플리케이션에 영향을 주지 ㅇ낳고 변경하는 3가지 훌륭한 솔루션이 있습니다.

- pt-online-schema-change
- gh-ost
- ALTER TABLE

각 솔루션은 매우 다르게 작동하지만 모두 애플리케이션에 영향을 주지 않고 온라인으로 테이블 정의를 변경할 수 있습니다. 각각의 설명서를 읽고 자신에게 가장 적합한 것을 결정하세요


---

## 5. MySQL 표준 SQL 확장

MySQL만 사용할 때는 이 문제를 건너뛸 수 있습니다. 그러나 다른 관계형 데이터베이스에서 온 경우 MySQL 매뉴얼의 '표준 SQL에 대한 MySQL 확장' 부분에 열거한 표준 SQL에 대한 많은 확장이 있다는 점에 유의하세요. 그리고 MySQL은 전체 외부 조인(full outer join)과 같은 일부 표준 SQL 기능을 지원하지 않습니다.

> MySQL 전문가는 매뉴얼에 많이 의존하고 있으며 여러분도 그래야 합니다.


---

## 6. 시끄러운 이웃들

물리적 서버에서 이른바 '시끄러운 이웃'은 지나치게 많은 시스템 리소스를 사용하여 다른 프로그램의 성능을 떨어뜨리는 프로그램입니다. 시끄러운 이웃은 여러분의 잘못은 아니지만 성능에 미치는 영향은 여러분의 문제입니다.

시끄러운 이웃을 더 조용한 다른 서버로 이동합니다. 만약 이것이 불가능하다면 시끄러운 이웃에게 이 책을 선물하여 MySQL의 성능을 최적화하는 방법을 배울 수 있도록 합니다.


---

## 7. 애플리케이션은 우아하게 실패하지 않는다.

주변의 모든 것이 올바르게 작동할 때 올바르게 작동하는 소프트웨어를 작성하는 것은 너무도 기본적이고 명백한 기대이므로 아무런 소용이 없습니다. 문제는 주변의 모든 것이 실패하는 경우에도 어느 정도 작동하는 소프트웨어를 작성하는 것입니다. 가장 교활한 문제는 완전한 실패가 아니라 극단적인 경우와 이상한 점이 발생했을 때입니다. 아래에 애플리케이션의 성능을 테스트할 수 있는 12가지 데이터베이스 카오스 시나리오가 있습니다.

- MySQL이 오프라인 상태입니다.
- MySQL은 응답 속도가 매우 느립니다.
- MySQL은 읽기 전용입니다.
- MySQL이 방금 시작(콜드 버퍼 풀) 했습니다.
- 읽기 전용 복제본이 오프라인이거나 매우 느립니다.
- 같은 지역에서 장애 조치가 되었습니다.
- 다른 지역으로 장애 조치가 되었습니다.
- 데이터베이스 백업이 실행 중입니다.
- DNS 주소 해석이 매우 느립니다.
- 네트워크가 느리거나(긴 대기 시간) 꽉 찼습니다.
- RAID 배열에 있는 하나의 하드 드라이브가 성능이 저하되었습니다.
- SSD의 여유 디스크 공간이 5% 미만입니다.

이러한 12가지 데이터베이스 카오스 시나리오 중 일부는 인프라에 적용되지 않을 수 있지만 대부분은 표준이며, 애플리케이션에 따라 흥미로운 결과를 가져오기도 합니다. 카오스를 설계한 적이 없다면 카오스는 여러분이 준비될 때까지 기다리지 않기 때문에 시작하는 것이 좋습니다.


---

## 8. 고성능 MySQL은 어렵다.

고성능 MySQL은 책, 블로그, 비디오, 컨퍼런스 등의 학습 자료들이 실제와 다른 이론을 가르치기 때문에 연습이 필요합니다. 결과적으로 이 책에서 배운 내용을 애플리케이션에 적용하기 시작하면 다음 2가지 문제에 직면할 수 있습니다.

첫 번째 문제는 실제 애플리케이션 쿼리가 이 책에 있는 간단한 예보다 일반적으로 더 복잡합니다. 쿼리 메트릭, 인덱스와 인덱싱, EXPLAIN 출력 등 많은 쿼리들이 있지만 한 번에 하나의 쿼리를 가져오고 1장, 2장 에서 배웠던 내용을 기억하세요. 전문가조차도 쿼리의 전체 내용을 풀고 이해하는 데 시간이 필요합니다.

두 번째 문제는 실제 애플리케이션 성능이 워크로드의 한족 측면에 거의 의존하지 않는다는 것입니다. 느린 쿼리를 수정하면 의심할 여지 없이 도움이 되지만 충분하지 않을 수 있습니다. MySQL에서 더 많은 성능이 필요할수록 전체 워크로드를 더 많이 최적화해야 합니다. 결국 이 책의 모든 장에서 얻은 지식을 적용해야 합니다.

