
복제 지연은 원본 MySQL 인스턴스에서 쓰기가 발생하는 시간과 해당 쓰기가 복제 MySQL 인스턴스에 적용되는 시간 사이의 지연입니다. 복제는 네트워크를 통하므로 네트워크 지연 시간이 발생합니다. 따라서 모든 데이터베이스에서 복제 지연은 당연한 현상입니다.

이번 장에서는 복제 지연이 무엇인지, 왜 발생하는지, 어떤 위험이 있는지 그리고 무엇을 할 수 있는지 등 성능과 관련하여 복제 지연을 소개합니다.


1. MySQL 복제의 기본 용어를 소개하고 그 복제 지연이 발생하는 기술적 기원, 즉 빠른 데이터베이스와 네트워크에도 불구하고 복제 지연이 일어나는 이유를 추적합니다.
2. 복제 지연의 주요 원인을 설명합니다.
3. 복제 지연의 위험인 데이터 손실을 설명합니다.
4. 다중 스레드 복제를 사용할 수 있는 보수적인 구성을 제공하여 지연 시간을 크게 줄입니다.
5. 높은 정밀도로 복제 지연을 모니터링하는 방법을 설명합니다.
6. 복제 지연의 복구 속도가 느린 이유를 설명합니다.


---


## 1. MySQL의 복제 유형

##### \[원본에서 복제본으로]

원본에서 복제본으로의 복제는 MySQL이 20년 이상 사용해 온 기본 복제 유형입니다. MySQL 복제는 원본에서 복제본으로의 복제를 의미합니다.

아래 그림은 원본에서 복제본으로의 복제에 대한 기초를 보여 줍니다.

![[Pasted image 20240129204536.png]]


원본 MySQL 인스턴스는 클라이언트가 데이터를 쓰는 MySQL 서버입니다. MySQL 복제는 쓰기 가능한 여러 원본을 지원하지만 쓰기 충돌 처리의 어려움으로 인해 잘 사용되지 않습니다. 결과적으로 쓰기 가능한 단일 원본이 일반적입니다.


복제본 MySQL 인스턴스는 원본에서 데이터 변경 사항을 복제하는 모든 MySQL 서버입니다. 데이터 변경은 행, 인덱스, 스키마 등에 대한 수정입니다. 복제본은 스플릿 브레인을 방지하기 위해 항상 읽기 전용이어야 합니다.

아래 원본에서 복제본으로의 데이터 흐름을 확인해보겠습니다.

1. 트랜잭션 커밋 중에 데이터 변경 사항은 원본의 바이너리 로그에 기록됩니다. 바이너리 로그 이벤트의 데이터 변경 사항을 기록하는 디스크에 있는 파일입니다.
2. 복제본의 I/O 스레드는 원본 바이너리 로그에서 바이너리 로그 이벤트를 덤프합니다. (원본의 바이너리 로그 덤프 스레드는 슬레이브에서 이벤트 요청 시 해당 이벤트를 전송하는 목적 전용으로 사용됩니다.)
3. 복제본의 I/O 스레드는 복제본의 릴레이 로그에 바이너리 로그 이벤트를 기록합니다. 릴레이 로그는 원본 바이너리 로그 이벤트들을 복제본 로컬에 복사한 디스크 파일입니다.
4. SQL 스레드는 릴레이 로그에서 바이너리 로그 이벤트를 읽습니다.
5. SQL 스레드는 바이너리 로그 이벤트를 복제본 데이터에 적용합니다.
6. 복제본은 데이터 변경 사항을 바이너리 로그에 기록합니다.


MySQL 복제는 비동기식이 기본입니다. 원본에서 트랜잭션은 1단계 후에 완료되고 나머지 단계는 비동기식으로 발생합니다. MySQL은 반동기식 복제를 지원합니다. 원본에서 트랜잭션은 3단계 후에 완료됩니다.

복제본은 바이너리 로그를 작성하는 데 필요하지 않지만(6단계) 복제본이 원본이 될 수 있으므로 고가용성을 위한 표준 관행입니다. 이것이 데이터베이스 장애 조치가 작동하는 방식입니다.

> 원본이 죽거나 유지 관리를 위해 중단되면 복제본이 승격되어 새 원본이 됩니다.


#### 바이너리 로그 이벤트

바이너리 로그 이벤트는 접할 일이 없을 낮은 수준의 세부 사항이지만 애플리케이션이 실행한 트랜잭션의 직접적인 결과입니다. 복제는 쓰기가 이미 완료된 트랜잭션 커밋 중에 데이터 변경 사항이 바이너리 로그에 커밋되므로 개별 쓰기가 아닌 트랜잭션과 바이너리 로그 이벤트에 중점을 둡니다.

아래 예를 살펴봅니다.

```sql
BEGIN
UPDATE t1 SET c='val' WHERE id=1 LIMIT 1;
DELETE FROM t2 LIMIT 3;
COMMIT;
```

위 쿼리는 4개의 연속 이벤트가 트랜잭션을 구성합니다.

- BEGIN을 위한 이벤트
- 1개의 행 이미지가 있는 UPDATE 문에 대한 이벤트
- 3개의 행 이미지가 있는 DELETE 문에 대한 이벤트
- COMMIT을 위한 이벤트

로-레벨에서는 SQL 문이 기본적으로 사라지고 복제는 이벤트와 행 이미지의 스트림입니다. 행 이미지는 수정 전, 후 행의 바이너리 스냅숏입니다. 단일 SQL 문은 수 많은 행 이미지를 생성할 수 있으며, 복제하는 동안 지연을 일으키는 큰 트랜잭션을 생성할 수 있으므로 중요한 세부 정보입니다.


#### 복제 지연

복제 지연은 복제본에 변경 사항을 적용하는 것(5단계)이 원본에 변경 사항을 커밋하는 것보다 느릴 때 발생합니다. MySQL 바이너리 로그, MySQL 네트워크 프로토콜과 일반적인 네트워크는 매우 빠르고 효율적이어서 그 사이의 단계는 거의 문제가 되지 않습니다.

복제본의 I/O 스레드는 네트워크에서 읽고 디스크에 차례대로 쓰는 비교적 쉬운 과정이므로 바이너리 로그 이벤트를 릴레이 로그에 빠른 속도로 쓸 수 있습니다. 그러나 SQL 스레드에는 변경 사항을 적용하는 훨씬 더 어렵고 시간이 많이 걸리는 과정이 있습니다. 결과적으로 I/O 스레드는 SQL 스레드를 능가하고 복제 지연은 아래 그림과 같습니다.

![[Pasted image 20240129211240.png]]


> 즉, I/O 스레드가 SQL 스레드를 능가하기 때문에 복제 지연이 발생합니다.


엄밀히 말하면 위 그림에서 단일 SQL 스레드는 복제 지연을 유발하지 않으며 제한 요소일 뿐입니다. 이때 원인은 원본의 트랜잭션 처리량이 높아서이며, 이는 애플리케이션이 사용 중일 때는 좋은 문제지만 그럼에도 불구하고 문제입니다.
해결책으로는 더 많은 SQL 스레드가 필요한 것인데 이는 이후에 다시 다루도록 하겠습니다.

반동기식 복제는 복제 지연을 해결하거나 예방하지 않습니다. 반동기식 복제를 사용하면 각 트랜잭션에 대해 MySQL은 복제본이 트랜잭션에 대한 바이너리 로그 이벤트를 릴레이 로그에 기록했음을 확인할 때까지 기다립니다.(3단계)

> 복제에는 지연이 따르기 마련이지만, MySQL 복제는 매우 빠르므로 이를 잘못 이해해서는 안 됩니다.
> 물론 매우 빠르지만 복제 지연이 발생하는 3가지 원인을 다음 절에서 얘기하도록 하겠습니다.


##### \[그룹 복제]

그룹 복제는 MySQL이 5.717 버전부터 지원하는 새로운 복제 유형입니다. 그룹 복제는 그룹 합의 프로토콜을 사용하여 데이터 변경 사항을 동기화하고 그룹 구성원을 관리하는 기본과 보조 인스턴스의 MySQL 클러스터를 생성합니다.


---


## 2. 복제 지연의 3가지 원인

복제 지연에는 트랜잭션 처리량, 장애 후 재구축, 네트워크 문제라는 3가지 주요 원인이 있습니다.

##### 1) 트랜잭션 처리량

트랜잭션 처리량은 원본의 속도가 복제본의 SQL(적용자) 스레드가 변경 사항을 적용할 수 있는 속도보다 빠를 때 복제 지연을 유발합니다. 애플리케이션이 정상으로 바쁘게 움직인 탓에 이런 문제가 발생했다고 해서 원본 쪽의 속도를 줄일 수는 없습니다.

대신 해결책은 더 많은 SQL(적용자) 스레드를 실행하여 복제본의 속도를 높이는 것입니다. 이후에 다중 스레드 복제를 조정하여 복제본 성능을 개선하는 데 중점을 두겠습니다.

과도하게 많은 행을 수정하는 대규모 트랜잭션은 원본보다 복제본에 더 큰 영향을 미칩니다. 예를 들어 원본에서 실행하는 데 2초가 걸리는 큰 트랜잭션은 병렬로 실행되므로 다른 트랜잭션을 차단하지 않을 가능성이 큽니다. 그러나 단일 스레드 복제본에서 이 큰 트랜잭션이 다른 모든 트랜잭션을 2초 동안 차단합니다.

> 해결책은 더 작은 트랜잭션입니다.

어느 시점에서 트랜잭션 처리량은 단일 MySQL 인스턴스의 용량을 초과합니다. 트랜잭션 처리량을 늘리려면 데이터베이스를 샤딩하여 확장해야 합니다.


##### 2) 장애 후 재구축

MySQL이나 하드웨어에 장애가 발생하면 인스턴스가 수리되어 다시 복제 토폴로지로 들어갑니다. 또는 새 인스턴스가 기존 인스턴스에서 복제되어 실패한 인스턴스를 대신합니다. 어느 쪽이든 고가용성을 회복하기 위해 복제 토폴로지가 재구축됩니다.

수리된 인스턴스는 오프라인 상태에서 놓친 모든 바이너리 로그 이벤트를 복제하고 따라 잡는 데 몇 분, 몇 시간 또는 며칠이 걸립니다. 이러한 복제 지연은 무시할 수 없고 모든 데이터를 따라잡으면 어떤 지연도 정당화됩니다.

> 장애는 불가피하고 따라잡는 데 시간이 걸리므로 유일한 해결책은 복제 지연이 장애 후 재구축과 대기로 인한 것임을 인식하는 것입니다.


##### 3) 네트워크 문제

네트워크 문제로 인해 원본에서 복제본으로 바이너리 로그 이벤트 전송이 지연되면 복제 지연이 발생합니다.(2단계). 엄밀히 따지면 복제가 아닌 네트워크가 지연되는 것이지만, 아무리 따지더라도 지연이라는 최종 결과가 바뀌지는 않습니다. 복제본은 원본 뒤에 있습니다. 이때 네트워크 엔지니어를 불러 근본 원인인 네트워크를 고쳐야 합니다.



---


## 3. 위험 : 데이터 손실

복제 지연은 데이터 손실입니다. MySQL은 비동기 복제가 기본이므로 이 사실이 적용됩니다. 다행스럽게도 반동기식 복제는 커밋된 트랜잭션을 잃지 않는 옵션입니다.

##### \[비동기식 복제]

![[Pasted image 20240129212622.png]]

위 그림은 원본이 충돌한 시점을 보여줍니다.

충돌 원인이 MySQL이라면 자동으로 다시 시작하고 충돌 복구를 수행한 다음 정상 작동을 재개합니다. (기본으로 복제본은 자동으로 다시 연결되고 복제도 재개됩니다.)

MySQL은 올바르게 구성되었을 때 정확한 지속성이 있으므로 커밋된 트랜잭션 4와 5는 손실되지 않습니다. 단, 충돌 복구를 완료하는 데 몇 분 또는 몇 시간이 걸릴 수 있다는 문제가 있습니다.


하드웨어나 운영체제가 충돌의 원인이거나 어떤 이유로든 손상된 MySQL 인스턴스를 신속하게 복구할 수 없다면 DBA가 장애 조치하고 트랜잭션 4와 5는 잃게 됩니다. 이것은 이상적인 해결책이 아니지만 대안이 더 나빠서 표준이 된 관행입니다. 즉, 손상도니 MySQL 인스턴스를 복구하는 동안 장시간 운영 중단이 발생하는데, 이에는 몇 시간 또는 며칠이 걸릴 수 있는 정확한 데이터 포렌식이 필요합니다.

> MySQL을 포함하여 모든 하드웨어와 소프트웨어에는 장애가 발생하므로 비동기식 복제를 사용할 때 데이터 손실은 불가피합니다.


##### \[반동기식 복제]

반동기식 복제를 사용하면 원본은 적어도 하나의 복제본이 각 트랜잭션을 승인할 때까지 기다립니다. 확인 응답은 복제본이 트랜잭션에 대한 바이너리 로그 이벤트를 릴레이 로그에 기록했음을 의미합니다. 따라서 트랜잭션은 복제본의 디스크에 안전하게 있지만 복제본은 아직 적용하지 않았습니다. 확인 응답은 적용할 때가 아니라 수신했을 때 보내므로 완전 동기가 아니라 반동기라고 합니다.

![[Pasted image 20240129223205.png]]


반동기 복제를 사용하면 커밋된 모든 트랜잭션이 적어도 하나의 복제본에 복제되었음을 보장합니다. 이 문맥에서 커밋된 트랜잭션은 클라이언트가 실행한 COMMIT 문을 반환했음을 의미합니다. 아래 네 단계는 바이너리 로깅과 반동기 복제를 사용할 때 트랜잭션이 커밋되는 방식을 매우 단순화한 것입니다.

1. 트랜잭션 커밋 준비
2. 데이터 변경 사항을 바이너리 로그로 플러시
3. 하나 이상의 복제본에서 응답 대기
4. 트랜잭션 커밋

InnoDB 트랜잭션 커밋은 2단계 커밋입니다. 두 단계(1, 2단계) 사이에서 데이터 변경 사항이 기록되고 바이너리 로그에 플러시되며, MySQL은 적어도 하나의 복제본이 트랜잭션에 대해 응답할 때까지 기다립니다.

반동기식 복제의 요점은 커밋된 모든 트랜잭션이 적어도 하나의 복제본으로 복제되도록 보장하며, 실패하면 연결당 커밋되지 않은 트랜잭션 하나만 손실될 수 있다는 것입니다.


반동기식 복제가 MySQL의 기본값이 아닌 이유는 뭇엇일까요??
- 반동기식 복제는 가용성을 떨어뜨립니다.
	- 반동기식 복제는 트랜잭션을 보호하지만 이 보호는 모든 연결에 대한 현재 트랜잭션이 지연, 시간 초과, 또는 COMMIT에서 실패할 수 있음을 의미합니다.
	- 반면에 비동기식 복제를 사용하는 COMMIT은 본질적으로 즉시 수행되며 원본의 스토리지가 작동하는 한 보장됩니다.


기본적으로 반동기식 복제는 복제본이 충분하지 않거나 원본이 응답 대기 시간을 초과하면 비동기식으로 되돌아갑니다.
네트워크 지연 시간이 원본의 트랜잭션 처리량을 암시적으로 제한하므로 반동기식 복제의 성능을 위해서는 원본과 복제본이 빠른 로컬 네트워크에 있어야 합니다.


---


## 4. 지연 감소 : 다중 스레드 복제

MySQL 복제는 비동기식이고 단일 스레드입니다. 복제본에 하나의 SQL 스레드가 있습니다. 반동기식 복제도 단일 스레드입니다. 단일 SQL 스레드는 복제 지연을 일으키지 않지만 제한 요소입니다.

해결책은 다중 스레드 복제로, 다중 SQL 스레드는 트랜잭션을 병렬로 적용합니다. 다중 스레드 복제본에서 SQL 스레드를 적용자 스레드라고 합니다.

다중 스레드 복제는 MySQL을 사용하는 엔지니어에게는 간단하지만, MySQL로서는 간단하지 않은 해결책입니다. 트랜잭션은 무작위 순서로 적용될 수 없습니다. 트랜잭션 간에 종속성이 있을 수 있습니다.

아래 표에는 다중 스레드 복제를 사용하고 구성하기 위한 보수적인 시작점으로 3가지 시스템 변수가 있습니다.

![[Pasted image 20240129224055.png]]

> 5.7.22 이전의 MySQL에서는 다중 스레드 복제를 사용하지 않는 것이 좋습니다.


복제 토폴로지의 모든 MySQL 인스턴스에서 고가용성에 사용되는 3가지 변수를 모두 설정합니다.

replica_parallel_workers 변수는 다중 스레드 복제를 사용하는 설정의 하나입니다. 시작할 때는 4개의 적용자 스레드가 좋고, 워크로드와 하드웨어에 최적화된 적용자 스레드 수를 찾으려면 튜닝해야 합니다.

다중 스레드 복제의 전체 성능을 활용하려면 replica_parallel_type을 사용해야 합니다. 오늘날에는 replica_parallel_type = LOGICAL_CLOCK 이 최선입니다. 그 이유는 replica_preserve_commit_order를 사용할 때 단점이 없고 데이터베이스에 관계없이 트랜잭션을 병렬로 적용하므로 병렬화 기능이 향상되기 때문입니다.

replica_preserve_commit_order는 기본으로 비활성화되어 있지만 다중 스레드 복제본이 순서에 맞지 않게 커밋할 수 있어서 최선이라고 생각하지 않습니다. 즉, 원본에서 커밋된 것과 다른 순서로 트랜잭션을 커밋합니다. 해당 설정을 사용하면 트랜잭션은 여전히 병렬로 적용되지만, 일부 트랜잭션은 이전 트랜잭션이 먼저 커밋될 때까지 기다릴 수 있습니다.

> 위에서 언급한 변수 외에 추가로 binlog_transaction_dependency_tracking, binlog_group_commit_sync_delay 변수를 확인해야 합니다.



---


## 5. 모니터링

복제 지연을 모니터링하는 가장 좋은 방법은 전용 도구를 사용하는 것입니다. 하지만 먼저 SHOW REPLICA STATUS 명령문으로 확인할 수 있는 악명 높은 복제 지연 메트릭인 Seconds_Behind_Source를 살펴보겠습니다.

Seconds_Behind_Source는 복제본의 현재 시각에서 SQL 스레드가 실행 중인 바이너리 로그 이벤트의 타임스탬프를 뺀 것과 같습니다. 복제본의 현재 시각이 T = 100 이고 SQL 스레드가 타임스탬프 T = 80 인 바이너리 로그 이벤트를 실행 중이라면, Seconds_Behind_Source는 20 입니다.

해당 메트릭은 비교적 정확하지만 3가지 문제가 있습니다.

첫 번째 문제는 모든 것이 작동하지 않을 때 발생합니다. Seconds_Behind_Source는 바이너리 로그 이벤트 타임스탬프에만 의존하므로 바이너리 로그 이벤트가 도착하기 전에 어떠한 문제도 상징적으로 보거나 신경쓰지 않습니다.

두 번째 문제는 Seconds_Behind_Source가 0과 0이 아닌 값 사이를 반복한다는 것입니다. 예를 들어 한 순간에 500초의 지연을 보고하고, 다음 순간에는 0 지연을 보고하고 다시 다음 순간에 500초의 지연을 보고하는 경우가 있습니다.

세 번째 문제는 Seconds_Behind_Source가 엔지니어들이 정말로 알고 싶어하는 질문인 "복제본이 언제 따라잡을 수 있나요?\" 에 정확하게 답하지 못한다는 것입니다. Seconds_Behind_Source의 값은 적용 중인 현재 이벤트가 원본에서 실행된 지 얼마나 지났는지만 나타냅니다.

> 요점은 복제본이 원본과 다른 속도로 트랜잭션을 적용하며 그 차이를 알 수 없으므로 Seconds_Behind_Source는 복제본이 언제 따라잡을지 정확하게 표시할 수 없습니다.

> 이러한 문제에도 불구하고 Seconds_Behind_Source는 복제본이 원본을 따라잡는 데 걸리는 시간에 대한 대략적인 추정치를 제공합니다.


> 결국 복제 지연을 모니터링하는 최상의 방법은 전용 도구를 사용하는 것입니다.



---


## 6. 복구 시간

복제본에 상당한 지연 시간이 발생할 때 가장 시급한 질문은 언제 복구될 것인가 입니다. 복제본은 언제 원본을 따라잡아 최신 트랜잭션을 실행할까요?? 정답은 없습니다. 그러나 복제 지연은 원인이 해결되면 항상 복구됩니다.

![[Pasted image 20240129225845.png]]

복제 지연의 일반적이고 중요한 특성은 지연 증가와 복제본 복구 시작 사이의 변곡점입니다. 위 사진에서 75 시간을 의미합니다.

복제 지연이 시작되면 지연이 증가함에 따라 상황이 점점 더 심각해 보입니다. 그러나 이것은 정상입니다. 복제본이 손상되지 않았다고 가정하면 SQL 스레드가 열심히 동작하지만 원인은 아직 해결되지 않았으므로 바이너리 로그 이벤트의 백로그가 계속해서 증가합니다. 원인이 지속되는 한 복제 지연은 증가합니다.

원인이 수정되지 않으면 복제본이 복구되지 않으므로 이론적으로 변곡점 이전의 복구 시간은 그다지 의미가 없습니다. 복제 지연이 꾸준히 증가하고 있을 때 값에 구애받지 말고 원인을 해결하는 데 집중해야 합니다.

> 정답은 없고 지연이 항상 복구된다는 개념으로 돌아가서, 결론은 정확한 복구 시간은 처음 생각했던 것만큼 유용하거나 의미가 없다는 것입니다. 복제본이 복구되는 정확한 시간을 알 수 있더라도 기다리는 수밖에 없습니다.



---


## 요점 정리

이번 장에서는 MySQL 복제 지연을 살펴봤는데, 복제는 MySQL 고가용성의 기초이며 복제 지연은 데이터 손실입니다. 이번장의 요점은 다음과 같습니다.

- MySQL에는 비동기식, 반동기식 그리고 그룹 복제의 3가지 복제 유형이 있습니다.
- 비동기식 복제가 기본값입니다.
- 비동기식 복제는 실패 시 수많은 트랜잭션을 잃을 수 있습니다.
- 반동기식 복제는 실패 시 커밋된 트랜잭션을 잃지 않으며 클라이언트 연결당 커밋되지 않은 트랜잭션 하나만 손실합니다.
- 그룹 복제는 MySQL 복제와 고가용성의 미래입니다. 이것은 MySQL 인스턴스를 클러스터로 전환합니다.
- MySQL 비동기와 반동기 복제의 기본은 바이너리 로그 이벤트로 인코딩된 트랜잭션을 원본에서 복제본으로 보내는 것입니다.
- 반동기식 복제는 적어도 하나의 복제본이 트랜잭션 수신과 저장을 확인 응답할 때까지 원본에서 트랜잭션을 커밋합니다.
- 복제본에는 원본에서 바이너리 로그 이벤트를 가져와 로컬 릴레이 로그에 저장하는 I/O 스레드가 있습니다.
- 복제본에는 로컬 릴레이 로그에서 바이너리 로그 이벤트를 실행하는 하나의 SQL 스레드가 기본으로 있습니다.
- 다중 SQL 스레드를 실행하기 위해 다중 스레드 복제를 활성화할 수 있습니다.
- 복제 지연에는 3가지 주요 원인이 있습니다. 원본의 높은 트랜잭션 처리량, 장애 후 재구축, 네트워크 문제입니다.
- SQL 스레드는 복제 지연의 제한 요소입니다. 스레드가 많을수록 트랜잭션을 병렬로 적용하면 지연이 줄어듭니다.
- 반동기식 복제로 인해 복제 지연이 발생할 수 있습니다.
- 복제 지연은 특히 비동기식 복제에서 데이터 손실입니다.
- 다중 스레드 복제를 활성화하는 것이 복제 지연을 줄이는 가장 좋은 방법입니다.
- 복제 지연에 대한 MySQL 메트릭인 Seconds_Behind_Source는 오해의 소지가 있으므로 그것에 의존하지 마세요
- 전용 도구를 사용하면 초 단위로 MySQL 복제 지연을 측정하고 보고합니다.
- 복제 지연으로 인한 복구 시간은 부정확하고 계산하기 어렵습니다.
- MySQL은 항상 원인이 해결되면 결국 복구됩니다.



