
해당 챕터에서는 간접 쿼리 최적화에 대한 얘기를 합니다. 직접 쿼리 최적화가 많은 문제를 해결하지만 전부를 해결해주는 것은 아닙니다. 즉, 적절하게 인덱스가 되어 있는 쿼리가 있지만 여전히 느린 상황을 접할 수도 있습니다. 

이때 쿼리가 접근하는 데이터부터 시작하여 쿼리를 중심으로 최적화를 시작해야 합니다.

데이터 크기가 작을 땐 조약돌 한 줌을 들고 언덕을 걷거나 뛰는 것처럼 데이터를 다루기 쉬워서 일반적으로 직접 쿼리 최적화로 충분합니다. 그러나 데이터 크기가 증가함에 따라 간접 쿼리 최적화가 점점 더 중요해집니다.

> 데이터가 적을수록 시스템 리소스(CPU, 램, 스토리지...)가 적게 필요하므로 데이터를 줄임으로써 성능을 향상할 수 있습니다.


이번 장에서는 아래 3가지 부분을 설명합니다.

1. MySQL 성능의 세 가지 비밀을 밝힙니다.
2. "최소 데이터의 원칙" 이라고 부르는 것과 그것의 의미를 소개합니다.
3. 데이터를 빠르고 안전하게 삭제하거나 보관하는 방법을 다룹니다.



---



## 1. 세 가지 비밀

#### 인덱스가 도움이 되지 않을 수 있다.

아이러니하게도 여러분은 다수의 느린 쿼리가 인덱스 조회를 사용할 것으로 예상합니다. 그러나 이는 두 가지 이유로 아이러니입니다.

1. 인덱스 성능에서 핵심이지만 좋은 인덱스라도 쿼리가 느릴 수 있습니다.
2. 인덱스와 인덱싱에 대해 학습한 후 엔지니어는 인덱스 스캔과 테이블 스캔을 피하는 데 너무 능숙해져서 [[2. 인덱스와 인덱싱#인덱스 조회|인덱스 조회]]만 남게 되는데, 이는 바람직하지만 여전히 아이러니한 면이 있습니다.

인덱스 없이는 성능을 달성할 수 없지만 인덱스가 무한한 데이터 크기에 대해 무한한 영향력을 제공한다는 의미는 아닙니다.

> 인덱스에 대한 믿음을 잃지 말고 인덱스가 도움이 되지 않을 수 있는 다음과 같은 상황을 알아야 합니다.


1) 인덱스 스캔

인덱스 스캔은 테이블이 커질수록 인덱스도 함께 커지므로(더 많은 테이블 행, 더 많은 인덱스값) 영향력이 점점 감소합니다. 인덱스 스캔은 테이블의 행 수가 증가할수록 인덱스 스캔을 사용하는 쿼리에 대한 응답 시간도 늘어나므로 반드시 지연 시간이 발생합니다.


2) 행 찾기

인덱스 조회를 사용하는 느린 쿼리를 최적화할 때 확인하는 첫 번째 쿼리 메트릭은 조회된 행입니다. 일치하는 행을 찾는 것이 쿼리의 기본 목적이지만 좋은 인덱스를 사용하더라도 쿼리가 너무 많은 행을 검사할 수도 있습니다. 검사할 행이 너무 많으면 응답 시간이 허용되지 않는 지점이 됩니다.

아래 사진에 나온 접근 유형들은 최대 하나의 행과 일치합니다.

![[Pasted image 20231212134444.png]]

EXPLAIN 계획의 type 필드가 위 표에 나열한 접근 유형 가운데 하나가 아니라면 rows 필드와 조회된 쿼리 메트릭 행에 주의를 기울여야 합니다. 너무 많은 행을 검사하는 것은 어떤 인덱스 조회든 관계없이 느려집니다.

매우 낮은 인덱스 [[2. 인덱스와 인덱싱#최고의 선택도|선택도]]는 인덱스 조회를 느리게 하는 공범일 가능성이 높습니다. 선택도는 카디널리티를 테이블의 행 수로 나눈 값입니다. MySQL은 너무 많은 행과 일치할 수 있어서 선택도가 매우 낮은 인덱스를 선택하지 않을 것입니다.

세컨더리 인덱스는 행을 읽기 위해 프라이머리 키에서 두 번째 조회가 필요하므로, 선택도가 매우 낮은 인덱스를 피하고 더 나은 인덱스가 없다는 가정하에 풀 테이블 스캔을 수행하는 것이 더 빠를 수 있습니다.

> 선택도가 높다는 의미는 결국 인덱스 한 개의 행에 맞는 행의 개수가 거의 1대 1이라는 의미입니다. 즉 unique 인덱스일 가능성이 더 높다는 의미입니다.

인덱스 선택도는 카디널리티와 테이블의 행 수를 대상으로 하는 기능이라는 것을 기억해야 합니다. 카디널리티는 일정하게 유지되지만 행 수가 증가하면 선택도가 감소합니다. 따라서 테이블이 작을 때 도움이 되었던 인덱스가 테이블이 커지게 되면 도움이 되지 않을 수 있습니다.


3) 테이블 조인

중첩 반복 조인 알고리즘은 조인을 위해 접근한 전체 행 수가 각 테이블에 대해 접근한 행의 곱이었습니다. 즉, EXPLAIN 계획에서 rows 값을 곱합니다. 테이블 당 100개의 행반 있는 3개 테이블 조인은 100만 개의 행에 접근할 수 있습니다.

따라서 이를 방지하려면 조인된 각 테이블에 대한 인덱스 조회가 표 3-1에서 나열된 접근 유형 중 하나를 사용하여 하나의 행만 일치하는 것이 가장 좋습니다. 인덱스 조회가 없으면 테이블 조인이 힘들어집니다. 그러나 인덱스가 있더라도 인덱스가 단일 행과 일치하지 않으면 테이블 조인에 어려움을 겪습니다.


4) 작업 세트 크기

인덱스는 메모리에 있을 때만 유용합니다. 쿼리가 조회하는 인덱스 값이 메모리에 없으면 MySQL은 디스크에서 값을 읽습니다. 

> 정확히 말하면 인덱스를 구성하는 B-트리 노드는 16KB 페이지에 저장되고, MySQL은 필요에 따라 메모리와 디스크 간에 페이지를 교환합니다.


디스크에서 읽는 것이 메모리에서 읽는 것보다 훨씬 느리지만, 한 가지 주요 문제는 인덱스가 메모리를 놓고 경쟁한다는 것입니다. 메모리는 제한적이지만 인덱스가 많고 테이블 크기 대비 많은 비율의 값을 자주 조회할 때는 MySQL이 자주 사용하는 인덱스값을 메모리에 유지하려고 시도하기 때문에, 인덱스 사용으로 인해 스토리지 입출력이 증가하게 됩니다.

이러한 입출력 증가는 두 가지 이유로 드물게 발생합니다.
첫째, MySQL은 자주 사용하는 인덱스값을 메모리에 유지하는 데 탁월합니다.
둘째, 자주 사용하는 인덱스값과 이들이 참조하는 프라이머리 키 행을 작업 세트라고 하며, 일반적으로 테이블 크기에서 작은 비율을 차지합니다.

> 둘째로 소개한 이유는 예를 들어, 데이터베이스의 크기는 500GB일 수 있지만 애플리케이션은 1GB의 데이터에만 자주 접근한다면, 이러한 사실을 고려해 DBA는 보통 전체 데이터 크기의 10%에 해당하는 메모리를 할당하여 표준 메모리값에 맞춥니다.

작업 세트의 크기가 사용할 수 있는 메모리보다 훨씬 커지면 인덱스가 도움이 되지 않을 수 있습니다. 인덱스 사용은 스토리지 입출력에 부담을 주고 모든 것을 느리게 만듭니다.
결국, 최선의 해결책은 큰 작업 세트에 원인이 되는 데이터 크기와 접근 패턴을 해결하는 것입니다.

> 애플리케이션이 단일 MySQL 인스턴스에서 작업 세트의 크기가 적절한 크기의 메모리에 맞지 않을 정도로 많은 데이터를 저장하고 접근해야 할 때 해결책은 샤딩입니다.


#### 데이터가 적을수록 좋다.

숙련된 엔지니어는 거대한 데이터베이스를 축하하기보다 처리합니다. 성능, 관리, 비용 등 모든 면에서 데이터 크기가 적을수록 좋기 때문에 데이터가 크게 줄어들 때를 축하합니다. 당연히 데이터 크기를 적절하게 유지하는 것이 거대한 데이터베이스를 처리하는 것보다 쉽습니다.

적절하게 필요한 양의 데이터라면 최적화하고 관리하는 데 시간과 노력을 기울일 가치가 있습니다. 문제는 데이터 크기가 아니라 제한 없이 증가하는 데이터입니다.

> 데이터 크기 때문에 문제가 발생하기 전에 제한 없이 증가하는 데이터에 문제를 제기해야 합니다.


#### QPS가 낮을수록 좋다.

![[Pasted image 20231212145143.png]]


1) QPS는 숫자에 불과하며 원시 처리량을 측정한 값이다.

QPS는 일반적으로 쿼리나 성능에 대해 질적인 정보를 제공하지 않습니다. 똑같은 QPS에서도 수많은 질적 차이가 발생합니다. 1000QPS에서 select 1 을 실행하려면 시스템 리소스가 거의 필요하지 않지만, 똑같은 QPS에서 복잡한 쿼리는 모든 시스템 리소스에 많은 부담을 줄 수 있습니다.


2) QPS값은 객관적인 의미가 없다.

QPS는 좋거나 나쁘지도 않고, 높거나 낮지도 않으며, 전형적이거나 비전형적이지도 않습니다. QPS값은 애플리케이션과 관련해서만 의미가 있습니다. 어플리케이션에서 2000QPS에서 갑자기 100QPS는 중단을 나타내는 급격한 하락일 수 있지만 300QPS에서 100QPS는 정상적인 변동일 수 있습니다. QPS는 또한 시간, 요일, 계절, 휴일 등과 같은 외부 요인에도 영향을 받습니다.


3) QPS를 높이기는 어렵다.

데이터 크기는 1GB에서 100GB로 100배 정도는 비교적 쉽게 증가할 수 있습니다. 그러나 QPS를 100배 높이기는 매우 어렵습니다.

> 이러한 점들을 요약하면 QPS는 질적이지 않고 애플리케이션과 관련만 있을 뿐이며 높이기 어렵습니다. 요점을 말하자면 QPS는 도움이 되지 않습니다.


---


## 최소 데이터 원칙

저자는 최소 데이터 원칙을 "필요 데이터만 저장과 접근" 으로 정의합니다.


#### 데이터 접근

필요 이상으로 많은 데이터에 접근하지 마세요. 접근은 MySQL이 쿼리를 실행하기 위해 수행하는 모든 작업을 의미합니다. 아래 표는 데이터 접근 효율성을 확인할 때 쿼리에 적용할 수 있는 점검표입니다.

![[Pasted image 20231212150158.png]]

타당함이나 균형을 유지하는 측면에서 단일 점검 항목을 무시해도 성능에는 영향을 미치지 않습니다. 이들 항목은 모범 사례입니다. 습관이 될 때까지 반복해 사용하면 점검표를 완전히 무시하는 엔지니어들보다 MySQL로 더 큰 성과와 성능을 얻게 됩니다.


1) 필요한 열만 반환

쿼리는 필요한 열만 반환해야 합니다. SELECT * 쿼리를 실행하지 마세요. 이는 테이블에 BLOB, TEXT, 또는 JSON 열이 있을 때 특히 중요합니다.


2) 쿼리 복잡성 감소

쿼리는 될 수 있는 한 단순해야 합니다. 쿼리 복잡도는 쿼리를 구성하는 모든 테이블, 조건, SQL 절을 나타냅니다. 이러한 맥락에서 복잡도는 엔지니어가 아니라 쿼리와 관련이 있습니다.

복잡한 쿼리는 MySQL이 아니라 엔지니어에게 문제입니다. 쿼리가 복잡할수록 분석하고 최적화하기가 더 어렵습니다. 처음부터 쿼리를 단순하게 유지하고 될 수 있으면 쿼리 복잡성을 줄여야 합니다.


3) 행 접근 제한

쿼리는 될 수 있는 한 적은 수의 행에 접근해야 합니다. 너무 많은 행에 접근하는 것은 일반적으로 놀라운 일로 다가옵니다. 엔지니어가 의도한 것은 아닙니다. 시간 경과에 따른 데이터 증가가 일반적인 원인이 됩니다.

데이터 증가와 단순한 실수가 교차하는 지점에서 가장 중요한 원인은 범위와 목록을 제한하지 않는 것입니다. MySQL이 col 에 대해 범위 스캔을 수행할 때 col > 75 와 같은 개방형 범위는 수많은 행에 접근하게 합니다. 실제로 테이블이 작다고 가정하더라도, 특히 col 의 인덱스가 비고유 인덱스일 때는 테이블이 커짐에 따라 행 접근이 사실상 제한되지 않는다는 점에 유의해야 합니다.

LIMIT 절은 행을 일치시킨 후 결과 세트에 LIMIT가 적용되므로 행 접근을 제한하지 않습니다. ORDER BY ... LIMIT 최적화는 예외입니다. MySQL이 인덱스 순서대로 행에 접근할 수 있을 때, 일치하는 행을 찾다가 LIMIT 수만큼 발견되면 행 읽기를 중지합니다. 그러나 재미있는 점은 EXPLAIN은 이 최적화가 사용될 때 보고하지 않습니다.

아래 쿼리를 보겠습니다. 아래 행의 결과가 8 이라고 가정하겠습니다.

```sql
SELECT * FROM elem WHERE a > 'Ag' ORDER BY a;
```

EXPLAIN은 LIMIT 2 절이 있더라도 rows: 8 을 보고합니다.

![[Pasted image 20231212151010.png]]

다음과 같은 이유로 MySQL이 ORDER BY ... LIMIT 최적화를 사용하여 두 행(LIMIT 2)에만 접근한다고 추론할 수 있습니다.

- 쿼리는 인덱스(type: range)를 사용합니다.
- ORDER BY 열은 해당 인덱스의 맨 왼쪽 접두사입니다(key: a)
- Extra 필드는 Using filesort를 보고하지 않습니다.

범위와 목록 제한과 관련하여 확인해야 할 중요한 요소는 애플리케이션이 쿼리에 사용되는 입력을 제한하는가? 입니다.

> 때때로 한 번에 수천 개의 행을 검색하여 MySQL이 쿼리 실행 계획을 변경하게 됩니다. 이때의 해결책은 간단했습니다. 애플리케이션 입력을 요청당 1000개의 값으로 제한하는 것입니다.

쓰기는 일반적으로 InnoDB가 일치하는 행을 갱신하기 전에 접근하는 모든 행을 잠그므로 행 접근을 제한하는 것이 중요합니다. 결과적으로 InnoDB는 예상보다 더 많은 행을 잠글 수 있습니다.

테이블을 조인할 때 행 접근을 제한하는 것도 중요합니다. 조인 시 각 테이블의 몇 개 행이 성능을 빠르게 떨어뜨립니다. 저자는 인덱스 조회 없이 테이블 조인이 어렵다는 점을 지적했습니다.

각 쿼리에 대해 행 접근을 제한하는 것은 무엇인지 접근 패턴에 대해 알아야 합니다. EXPLAIN을 사용하여 예상되는 행 접근(rows 필드)을 확인하고 조회된 행을 모니터링하여 너무 많은 행에 접근하는 것에 대한 놀라움을 방지하세요


4) 결과 세트 제한

쿼리는 될 수 있는 한 적은 수의 행을 반환해야 합니다. 이것은 쿼리에 LIMIT 절을 넣는 것보다 더 관련이 있으므로 확실히 도움이 됩니다. 

- 애플리케이션이 일부 행을 사용할 때 발생합니다.
	- where 조건을 사용하는 대신 행을 필터링하는 애플리케이션 코드에서 이를 확인할 수 있습니다.
	- 애플리케이션은 더 많은 행을 선택하여 복잡한 쿼리를 피하고, MySQL에서 애플리케이션으로 일치하는 행을 옮기는 경우가 있을 수 있습니다. 이 기술은 응답 시간을 단축할 때에만 유용합니다.

- 쿼리에 ORDER BY 절이 있고 애플리케이션이 정렬된 행의 일부분을 사용할 때 발생합니다.
	- 행의 순서가 결정적인 특징입니다.
	- 애플리케이션은 쿼리에 LIMIT 20 절을 추가하는 것만큼이나 간단할 수 잇습니다.
	- 애플리케이션에서 나머지 980개 행을 사용하지 않는다면 쿼리가 LIMIT 20 절을 추가하여 해당 행을 반환하지 않도록 해야 합니다.
	- 이때 한 번에 20개의 행을 사용하여 페이징 처리할 수 있는데, ORDER BY ... LIMIT 최적화를 사용할 수 있을 때만 LIMIT 20 OFFSET N 으로 요청된 페이지를 가져오는 것이 더 빠르고 효율적일 수 있습니다.
	- 최적화가 없으면 LIMIT, OFFSET을 적용하기 전에 모든 행을 찾고 정렬해야 하므로 최적화가 필요합니다.

> 최적화가 없더라도 또 다른 해결책이 있습니다. 크지만 합리적인 LIMIT 절입니다. 예를 들어, 애플리케이션 사용량을 측정하고 대부분의 요청이 처음 5개 페이지만 사용할 때 LIMIT 100 절로 처음 5개 페이지를 가져오고 대부분의 요청에 대한 결과 세트 크기를 90%로 줄입니다.


- 애플리케이션이 결과 세트를 집계하기만 할 때 발생합니다.
	- 만약 애플리케이션이 결과 세트를 집계하고 개발 행을 사용하는 경우는 허용됩니다.
	- 안티패턴은 결과 세트를 제한하는 SQL 집계 함수를 사용하는 대신 결과 세트를 집계하기만 하는 것입니다.
	- 개발자들은 값의 개수를 셀 때 group by 절보다 코드로 표현하는 것이 더 쉬울 수도 있지만, 후자는 결과 세트를 제한하는 데 사용해야 합니다.
	- 쿼리는 애플리케이션 코드가 아닌 SQL에서 집계하도록 하여 결과 세트를 제한할 수 있습니다.
	- 고윳값 추출은 MySQL에서 DISTINCT 를 사용하여 결과 세트를 제한할 수도 있습니다.
	- 참고로 SELECT DISTINCT a, b FROM elem 은 a와 b열의 값이 있는 고유 행 목록을 반환합니다.

![[Pasted image 20231212152228.png]]


5) 행 정렬 피하기

쿼리는 행 정렬을 피해야 합니다. MySQL 대신 애플리케이션에서 행을 정렬하면 ORDER BY 절을 제거하여 쿼리 복잡성을 줄이고 애플리케이션 인스턴스에 작업을 분산시켜 더 좋은 확장성을 가질 수 있습니다.

LIMIT 절이 없는 ORDER BY 절은 삭제할 수 있고 애플리케이션이 행을 정렬할 수 있음을 알리는 신호입니다. ORDER BY 절이 있지만 LIMIT 절이 없는 쿼리를 찾은 다음 애플리케이션이 MySQL 대신 행을 정렬할 수 있는지를 판단합니다.


#### 데이터 스토리지

필요 이상으로 많은 데이터를 저장하지 마세요. 데이터는 여러분에게 중요하지만 MySQL에게는 큰 부담입니다. 아래 표는 효율적으로 데이터를 저장하는지 확인하는 점검표입니다.

![[Pasted image 20231212153331.png]]

6개 항목 모두에 체크할 수 있다면 데이터를 어떤 크기로든 확장할 수 있는 적절한 위치에 있을 것입니다.


1) 필요한 행만 저장됨

애플리케이션이 변경 사항이 늘어남에 따라 엔지니어는 애플리케이션에 저장된 내용을 추적하지 못할 수 있습니다. 데이터 스토리지 문제가 아니라면 엔지니어는 무엇을 저장하는지 보거나 물어볼 이유가 없습니다.
여러분이나 다른 누군가가 애플리케이션이 무엇을 저장하고 있는지 검토한 지 오래되었다면 저장되는 데이터를 살펴보아야 합니다.


2) 모든 열이 사용됨

필요한 행만 저장하는 것보다 한 단계 더 심층적인 방법은 필요한 열만 저장하는 것입니다. 애플리케이션의 변경 사항이 늘어남에 따라 엔지니어는 특히 객체 관계형 매핑(ORM)을 사용할 때 열을 추적하지 못할 수 있습니다.


3) 모든 열이 간결하고 실용적임

필요한 행만 저장하는 것보다 두 단계 더 심층적인 방법은 모든 열을 간결하고 실용적으로 만드는 것입니다.

> 간결함은 가장 작은 데이터 타입을 사용하여 값을 저장하는 것을 의미하고 실용적이라는 것은 너무 작아서 사용자나 애플리케이션에 번거롭거나 오류가 발생하기 쉬운 데이터 타입을 사용하지 않는 것을 의미합니다.

고전적인 안티패턴은 VARCHAR(255) 입니다.

열의 문자 세트에 주의하세요. 열의 문자 세트는 명시적으로 정의하지 않으면 테이블의 문자 세트가 기본값이며 기본적으로 서버의 문자 세트를 사용합니다.

BLOB, TEXT, JSON 데이터 타입은 매우 보수적으로 사용하세요. 불필요한 공간이나 쓸데없는 데이터, 일반 버킷 용도로 사용하지 마세요


4) 모든 값이 간결하고 실용적임

필요한 행만 저장하는 것보다 세 단계 더 심층적인 방법은 모든 값을 간결하고 실용적으로 만드는 것입니다.
값을 압축하는 세 가지 방법인 최소화, 인코딩, 중복 제거를 알아보겠습니다.

- 최소화
	- 값을 최소화하려면 공백, 주석, 헤더 등 불필요하고 관련 없는 데이터를 제거하세요
	- SQL문을 최소화하는 것은 중요한 점을 인식하게 합니다. 즉, 값을 최소화하는 것이 경미한 게 아니라는 것입니다.
	- SQL문은 무의미한 문자열이 아니라 구문 인식을 통해 정확하게 최소화해야 합니다.
	- 값을 최소화하는 방법을 고려할 때는 데이터 형식부터 시작해 보세요. 데이터 형식의 구문과 의미는 어떤 데이터가 불필요하고 관련이 없는지를 결정합니다.

- 인코딩
	- 값을 인코딩할 때는 사람이 읽을 수 있는 값에서 기계가 읽을 수 있는 값으로 변환합니다.
	- 컴퓨터에 데이터를 저장할 때 가장 효율적인 방법은 컴퓨터에 맞게 인코딩하는 것입니다.
		- 안티패턴의 전형적인 예는 IP 주소를 문자열로 저장하는 것입니다.
		- 또 다른 유사한 예의 안티패턴은 UUID를 문자열로 저장하는 것입니다.

- 중복 제거
	- 중복 값을 제거하려면 열을 일대일 관계가 있는 다른 테이블로 정규화해야 합니다.
	- 아래 그림에서 원래 genre가 같이 있던 테이블에 SMALLINT UNSIGNED 데이터 타입으로 정수 1을 저장하며 데이터 크기를 감소시킬 수 있습니다.
	- 이러한 방식으로 값 중복 제거는 데이터베이스 정규화에 의해 수행됩니다.
	- 그러나 값 데이터 중복 제거는 데이터베이스 정규화의 목표나 목적이 아닙니다.
	- 흥미로운 반전으로 비정규화라는 것이 있습니다.
		- 비정규화는 정규화와 반대로 관련 데이터를 하나의 테이블로 결합하는 것입니다.
		- 비정규화는 테이블 조인과 수반되는 복잡성을 제거하여 성능을 향상시키는 기술입니다.
		- 의도적으로 속도를 위해 중복 데이터와 교환한 것입니다.

![[Pasted image 20231212154407.png]]


5) 모든 세컨더리 인덱스가 사용되며 중복되지 않음

사용되지 않는 인덱스와 중복 인덱스를 피하는 것은 항상 바람직한 생각이지만, 인덱스는 데이터의 복사본이므로 데이터 크기에 특히 중요합니다.

인덱스를 삭제하면 인덱스 크기와 같은 데이터 크기만 복구됩니다 .인덱스 크기를 확인하는 세 가지 방법이 있습니다.

1. INFORMATION_SCHEMA.TABLES를 쿼리하는 것입니다.

```sql
SELECT 
	TABLE_NAME, DATA_LENGTH, INDEX_LENGTH
FROM
	INFORMATION_SCHEMA.TABLES
WHERE
	TABLE_TYPE = 'BASE TABLE' AND TABLE_SCHEMA = 'employees';
```

![[Pasted image 20231212155224.png]]

DATA_LENGTH 는 프라이머리 키의 크기입니다. INDEX_LENGTH는 모든 세컨더리 인덱스의 크기입니다. 마지막 4개 테이블에는 세컨더리 인덱스가 없고 프라이머리 키만 있습니다.


2. SHOW TABLES STATUS

첫 번째 방법인 INFORMATION_SCEHMA.TABLES를 쿼리하는게 더 좋습니다.

3. mysql.innodb_index_status 테이블 조회

```sql
SELECT
	index_name, SUM(stat value) *@@ninodb_page size size 
FROM
	mysql.innodb_index_stats 
WHERE 
	stat_name ='size'
	AND database_name = 'employees'
	AND table_name = 'dept_emp' 
GROUP YB index_name;
```

세 번째 방법은 현재 각 인덱스의 크기를 확인하는 유일한 방법입니다.
테이블 employees.dept_emp에는 프라이머리 키와 dept_no라는 세컨더리 인덱스의 두 가지 인덱스가 있습니다. 열 크기에는 바이트 단위의 각 인덱스 크기가 포함되며, 이는 실제로 인덱스 페이지 수에 InnoDB 페이지 크기(기본값은 16KB)를 곱한 것입니다.

> 인덱스 사용량과 인덱스 크기를 정기적으로 확인하고 사용하지 않는 인덱스와 중복 인덱스를 신중하게 삭제하여 전체 데이터 크기를 줄이세요


6) 필요한 행만 유지됨

저장할 때 행이 필요할 수 있지만, 시간이 지남에 따라 변경해야 합니다. 더 이상 필요하지 않은 행은 삭제합니다. 다음 절에서 어떻게 데이터를 삭제하는지 보겠습니다.


---


## 데이터 삭제 또는 보관

데이터가 관리하기 어려울 정도로 쌓이고 있는데 지켜보기만 한다면 반드시 문제가 발생합니다.

애플리케이션에 부정적인 영향을 미치지 않으면서 데이터를 삭제하거나 보관하는 방법을 알아보겠습니다. 이러한 문제를 해결하는 방법은 거의 데이터 삭제에 있으므로 데이터 삭제만 언급합니다.

데이터를 보관하려면 먼저 데이터를 복사한 다음 삭제해야 합니다. 데이터 복사는 애플리케이션에 영향을 미치지 않도록 비잠금 SELECT 문을 사용한 다음, 애플리케이션이 접근하지 않는 다른 테이블이나 데이터 스토리지에 복사된 행을 작성해야 합니다. 비잠금 SELECT를 사용하더라도, MySQL과 애플리케이션이 처리할 수 있는 수준 이상으로 QPS가 증가하지 않도록 복사 프로세스의 속도를 제한해야 합니다.


#### 도구

데이터를 삭제하거나 보관하려면 여러분만의 도구를 직접 작성해야 합니다. 반가운 소식은 데이터를 삭제하고 보관하는 것이 어렵지 않으며 애플리케이션에 비해 간단할 수 있습니다. 중요한 부분은 SQL 문을 실행하는 반복문을 조절하는 것입니다.

```java
for {
	rowsDeleted = execute("DELETE FROM table LIMIT 1000000")
	if rowsDeleted == 0 {
		break
	}
}
```

LIMIT 1000000 절이 너무 크고 for 반복문 사이에 지연이 없습니다. 해당 의사 코드는 애플리케이션 중단을 유발할 수 있습니다. 배치 크기는 안전하고 효과적인 데이터 보관 도구에서 핵심입니다.


#### 배치 크기

행이 작고(BLOB, TEXT, JSON 열 없음) MySQL에 큰 부하가 없을 때, 단일 DELETE 문에서 1,000개 이하의 행을 수동으로 삭제한는 것이 안전합니다. 수동이란, 각 DELETE 문을 병렬이 아닌 직렬로 하나씩 실행함을 의미합니다.

행을 빠르고 안전하게 삭제할 수 있는 비율은 쿼리 응답 시간이나 복제 지연에 영향을 주지 않고 MySQL과 애플리케이션이 유지할 수 있는 배치 크기에 따라 결정됩니다. 배치 크기는 DELETE 문당 삭제되는 행 수로, LIMIT 절로 제어되고 필요한 경우 단순 지연인 스로틀로 조절됩니다.

배치 크기는 실행 시간으로 조정되며 500ms는 좋은 시작점입니다. 즉, 각 DELETE 문을 실행하는 데 500ms를 넘지 않아야 함을 의미합니다.


1) 복제 지연

원본 MySQL 인스턴스의 실행 시간은 복제본 MySQL 인스턴스에서 복제 지연을 생성합니다. 원본에서 DELETE 문을 실행하는 데 500ms가 걸렸다면 복제본에서 실행하는 데 500ms가 걸리므로 500ms의 복제 지연이 발생합니다. 복제 지연을 피할 수는 없지만 데이터 손실이므로 최소화해야 합니다.


2) 스로틀링

어떤 경우에는 보정된 배치 크기로 쿼리 실행 시간이 제한되어 QPS가 제한되므로 지연이나 스로틀링 없이 DELETE 문을 실행하는 것이 안전합니다. 실행하는 데 500ms가 걸리는 쿼리는 연속 2QPS에서만 실행할 수 있습니다.

스로틀링이 없으면 대량 쓰기가 다른 쿼리를 방해하고 애플리케이션에 영향을 줄 수 있습니다. 데이터를 삭제할 때 스로틀링 조절이 가장 중요합니다. 항상 DELETE문 사이의 지연으로 시작하므로 복제 지연을 모니터링하세요

예를 들어 배치 크기를 500ms 실행 시간으로 보정하려면 배치 크기를 1000(LIMIT 1000) 으로 시작하고 DELETE 문 사이에 200ms의 지연을 둡니다. 200ms는 긴 지연이지만 배치 크기를 보정한 후 이를 줄입니다. 가능하면 목표치보다 약간 낮은 수준으로 배치 크기를 설정하는 것이 좋습니다.

배치 크기를 보정하고 스로틀을 설정하면 쿼리 응답 시간에 영향을 주지 않고 삭제할 수 있는 초당 행 수인 batch size * DELETE QPS를 마침내 계산할 수 있습니다.


#### 로우 락 경합

쓰기 작업이 많은 워크로드의 경우, 대량 작업으로 인해 로우 락 경합이 발생할 수 있습니다. 쿼리는 동일한 행에서 로우 락을 획득하기 위해 대기합니다. 이 문제는 주로 INSERT와 UPDATE 문에 영향을 미치지만, 삭제된 행이 기존의 행과 산재되어 있다면 DELETE 문도 영향을 받을 수 있습니다.

문제는 보정된 시간 내에 실행해도 배치 크기가 너무 크다는 것입니다. 예를 들어, MySQL은 500ms 내에서 100,000개의 행을 삭제할 수 있지만 해당 행에 대한 잠금이 애플리케이션이 갱신하는 행과 겹치면 로우 락 경합이 발생합니다.

해결책은 훨씬 더 짧은 실행 시간(예: 100ms)으로 보정하여 배치 크기를 줄이는 것입니다. 극단적인 경우에는 작은 배치 크기, 긴 지연 등도 늘려야 할 수 있습니다. 이렇게 하면 로우 락 경합이 줄어들어 애플리케이션에는 좋지만 데이터 아카이빙 속도가 느려집니다. 이런 상황에는 마법 같은 해결책이 없습니다.

> 더 적은 데이터와 더 적은 QPS로 피하는 것이 가장 좋습니다.



#### 공간과 시간

데이터를 삭제해도 디스크 공간이 확보되지 않습니다. 행 삭제는 물리가 아닌 논리적이며 많은 데이터베이스에서 일반적인 성능 최적화입니다. 500GB의 데이터를 삭제하면 500GB의 디스크 공간이 아니라 500GB의 여유 페이지가 생깁니다. 즉, 데이터를 삭제하면 사용할 수 있는 디스크 공간이 아니라 여유 페이지가 생성됩니다.

여유 페이지는 성능에 영향을 미치지 않으며 InnoDB는 새 행이 삽입될 때 여유 페이지를 재사용합니다. 삭제된 행이 곧 새 행으로 교체되고, 디스크 공간이 제한되지 않는 경우 여유 페이지와 회수되지 않은 디스크 공간은 문제가 되지 않습니다.

단, 동료들을 염두에 둬야 합니다. 회사에서 자체 하드웨어를 실행하고 애플리케이션용 MySQL이 다른 애플리케이션용 MySQL과 디스크 공간을 공유한다면 다른 애플리케이션에서 사용할 수 있는 디스크 공간을 낭비하지 마세요

InnoDB에서 디스크 공간을 회수하는 가장 좋은 방법은 no-op인 ALTER TABLE ... ENGINE=INNODB 문을 실행하여 테이블을 재구성하는 것입니다.

> 이런 해결책은 애플리케이션에 영향을 주지 않고 프로덕션 환경에서 거대한 InnoDB 테이블을 온라인으로 재구성할 수 있다는 것입니다.


MySQL은 사용자에게 줄 수 있는 모든 클럭 사이클과 디스크 입출력 프로세서를 사용할 것입니다. 그러나 일상의 세계에서는 애플리케이션에 영향을 미치지 않도록 상당한 제한을 두며 데이터를 삭제해야 합니다. 직설적으로 말하자면 생각보다 시간이 훨씬 많이 걸릴 것입니다.

> 중요한 것은 배치 크기에 자세히 설명한 대로 올바르게 완료하면 잘 보정되고 지속 가능한 대량 작업은 며칠 또는 몇 주 동안 실행될 수 있습니다.



#### 바이너리 로그 역설

데이터를 삭제하면 데이터가 생성됩니다. 이 역설은 데이터 변경 사항이 바이너리 로그에 기록되기 때문에 발생합니다. 테이블에 큰 BLOB, TEXT, JSON 열이 포함된 경우, MySQL 시스템 변수 binlog_row_image는 full 설정이 기본이므로 바이너리 로그 크기가 급격히 증가할 수 있습니다. 이 변수는 행 이미지가 바이너리 로그에 기록되는 방식을 결정하고, 세 가지로 설정할 수 있습니다.

- full : 모든 열(전체 행)의 값을 기록합니다.
- minimal : 변경된 열의 값과 행을 식별하는 데 필요한 열을 기록합니다.
- noblob : 필요하지 않은 BLOB과 TEXT 열을 제외한 모든 열의 값을 기록합니다.

바이너리 로그의 전체 행 이미지에 의존하는 외부 서비스가 없는 경우 minimal 또는 noblob을 사용하는 것이 안전하고 권장됩니다.

역설적으로 서버에 데이터를 삭제하고 테이블을 재구성하기에 충분한 디스크 여유 공간이 있는지 확인해야 합니다.



---


## 요점 정리

이번 장에서는 성능과 관련하여 데이터를 조사하고 데이터 접근과 스토리지를 줄이는 것이 성능 향상을 위한 기술이라고 주장했습니다. 요점은 다음과 같습니다.

- 데이터가 적을수록 성능이 향상됩니다.
- QPS는 자산이 아니라 부채이므로 낮을수록 좋습니다.
- 인덱스는 MySQL 성능을 위해 필요하지만 도움이 되지 않는 경우가 있습니다.
- 최소 데이터 원칙은 필요한 데이터만 저장하고 접근한다는 이미입니다.
- 쿼리가 될 수 있는 한 적은 수의 행에 접근하도록 합니다.
- 필요 이상으로 많은 데이터를 저장하지 마세요. 데이터는 여러분에게 가치가 있지만 MySQL에게는 무거운 짐입니다.
- 데이터를 삭제하거나 보관하는 것은 중요하며 성능을 향상합니다.