
접근 패턴은 애플리케이션이 MySQL을 사용하여 데이터에 접근하는 방법입니다. 접근 패턴을 변경하면 MySQL 성능에 큰 영향을 미치지만, 일반적으로 다른 최적화보다 더 많은 노력이 필요합니다.

> 따라서 반드시 먼저 쿼리, 인덱스, 데이터를 최적화한 다음 접근 패턴을 최적화하게 됩니다.

MySQL은 애플리케이션에 대해 충분히 빠릅니다. 진짜 질문은 애플리케이션이 MySQL을 효율적으로 사용하느냐는 것입니다. 저자가 수년 동안 MySQL을 사용해 본 결과 MySQL 성능은 애플리케이션에 의해 제한되는 것이지 그 반대는 아니라고 확신하고 있습니다.

이번 장에서는 아래 6가지에 대해 설명합니다.

1. 애플리케이션과 별개로 MySQL이 수행하는 작업과 이것이 중요한 이유
2. 데이터베이스 성능이 선형으로 확장되지 않는다는 것을 증명합니다. 대신 성능이 불안정해지는 한계가 있습니다.
3. 일부 애플리케이션이 MySQL에서 뛰어난 반면 다른 애플리케이션은 그렇지 못하는지 이유를 설명합니다.
4. 데이터 접근 패턴을 열거합니다.
5. 데이터 접근 패턴을 개선하거나 수정하기 위한 몇 가지 애플리케이션 변경 사항을 제시합니다.
6. 더 좋고 빠른 하드웨어라는 오랜 주제를 다시 살펴봅니다.


---


## 1. MySQL은 아무것도 하지 않는다.

애플리케이션이 유휴 상태(시스템이 작업 가능하지만 실제적인 작업이 없는 상태)일 때 MySQL은 유휴 상태입니다. 애플리케이션이 바쁘게 쿼리를 실행 중이면 MySQL도 바쁘게 해당 쿼리를 실해 중입니다. 따라서 MySQL이 느리게 실행되는데 외부 문제가 없다면 원인은 MySQL을 구동하는 애플리케이션뿐입니다.

일부 데이터 스토리지에는 시스템에 고스트가 있습니다. 언제든지 실행될 수 있으며 최악의 경우 성능을 저하시킬 수 있는 내부 프로세스입니다. MySQL은 애플리케이션이 사용자가 모르는 쿼리를 실행하지 않는 한 시스템에 고스트가 없습니다.

쿼리는 다른 쿼리에 영향을 줍니다. 이에 대한 일반적인 용어는 쿼리 경합입니다. 즉, 쿼리가 경쟁하고 공유 리소스를 기다릴 때입니다. 로우 락 경합, CPU 경합 등 특정 유형의 경합이 있습니다. 쿼리 경합은 MySQL이 다른 작업을 하느라 바쁜 것처럼 보이게 만들 수 있지만, 오해하지 마세요. MySQL은 애플리케이션 쿼리만 실행할 뿐입니다.

> 즉, MySQL에서 일어나는 모든 일은 애플리케이션과 연관되는 것이지 MySQL이 문제가 아니다.



---


## 2. 한계에 도달하면 성능이 불안정해진다.

부하가 증가함에 따라 데이터베이스 성능은 시스템 용량을 100% 사용할 때까지 증가한 다음, 성능이 일정하게 유지되는 것을 선형 스케일링이라고 합니다.

![[Pasted image 20231220161428.png]]

선형 스케일링은 모든 DBA 엔지니어의 이상이지만 실현될 수 없습니다. 대신 아래 그림은 부하, 시스템 용량과 관련된 데이터베이스 성능의 현실을 보여줍니다.

![[Pasted image 20231220161515.png]]

데이터베이스 성능은 시스템 용량의 100% 미만의 한계까지만 부하가 증가합니다. 현실적으로 데이터베이스 성능의 한계는 시스템 용량의 80 ~ 95% 입니다. 부하가 한도를 초과하여 증가하면 데이터베이스 성능이 불안정해집니다. 처리량, 응답 시간, 기타 메트릭은 정상 값에서 현저하게 변동합니다. 최고 사용률인 상태에서 결국 일부 쿼리의 성능이 저하되고, 최악의 경우 운영 중단이 발생합니다.

아래는 범용 확장성 법칙에 대한 수식입니다.

![[Pasted image 20231220161653.png]]

| 항  | 설명                                                                |
| --- | ------------------------------------------------------------------- |
| X   | 처리량                                                              |
| N   | 부하: 동시 요청, 실행중인 프로세스, CPU 코어, 분산 시스템의 노드 등 |
| y   | 동시성: 이상적인 병렬 처리                                          |
| a   | 결합: 공유 리소스를 기다리는 중                                     |
| b   | 일관성: 공유 리소스를 조정                                          |

성능을 제한하는 것보다 더 나쁜 일관성은 역행 성능을 유발합니다. 즉, 높은 부하에서 성능이 오히려 감소합니다. 역행이라는 용어는 절제된 표현이고 사실 시스템은 더 느리게 실행되는 것이 아니라 무너지고 있다고 할 수 있습니다.


아례 예시를 통해 좀 더 알아보겠습니다.

![[Pasted image 20231220161919.png]]

1. 상승기(오전 6시 ~ 9시)
	- 애플리케이션은 상승 초기에는 안정적이었지만 메트릭이 꾸준히 상승하고 있는 것을 보여 주고 있었기 때문에 개발자들은 긴장하기 시작했습니다.

2. 한계점(오전 9시 ~ 정오)
	- 애플리케이션은 한계점이 유지되는 동안 불안정한 상태로 오프라인 상태처럼 보였습니다.
	- CPU 사용량과 QSP가 꾸준히 높은 상태로 유지되고 있었지만, 실행 중인 스레드는 다른 이야기를 합니다.
	- 위 그림에서 표시된 실행 중인 스레드의 톱날 패턴은 MySQL이 불안정해졌음을 나타내는 신호였습니다.
	- 하나의 쿼리를 실행하는 데 하나의 스레드가 필요하므로 실행 중인 스레드의 큰 변동은 쿼리가 시스템을 통해 원활하게 흐르지 못한다는 것을 나타냅니다.
	- 대신 쿼리가 MySQL에게 불규칙하게 부하를 세게 주고 있었습니다.

3. 수정(정오 ~ 오후 3시)
	- 트랜잭션 처리량 증가는 그 자체로 소멸되었기 때문에 수정 사항은 트랜잭션 처리량을 줄이는 것이었습니다.
	- 정오에 애플리케이션 개발자는 트랜잭션 처리량을 줄였고 결과는 차트에서 명확해집니다.
	- CPU 사용량이 50%로 떨어졌고 QPS와 실행 중인 스레드도 안정적인 변동 폭으로 돌아갔습니다.

일반적으로 높은 부하는 애플리케이션을 불안정하게 하여 MySQL에서 부하가 증가하는 것을 방지합니다. 다시 말해, MySQL을 한계까지 밀어붙이기 전에 애플리케이션이 실패합니다.

- 일부러 부족한 하드웨어를 사용하지 않는 한 한계에 도달하기 어렵습니다.
	- 애플리케이션이 CPU, 램, 스토리지와 같은 모든 하드웨어를 동시에 완전히 활용하는 것도 어렵습니다.
	- 애플리케이션은 모든 하드웨어를 동시에 완전히 활용하기 훨씬 전에 하드웨어 한 부분에서 병목 현상을 일으킬 가능성이 가장 큽니다.
	- 이때 애플리케이션은 데이터베이스 성능의 한계에 도달한 것이 아니라 오직 해당 하드웨어의 한계에 도달한 것입니다.

- 높은 부하로 인해 MySQL이 느리게 응답한다고 해서 한계에 도달했다는 의미는 아닙니다.
	- 동시성이 증가하면 한계가 증가하므로 느린 데이터베이스 성능이 한계에 도달했음을 의미하지는 않습니다.


---


## 3. 도요타와 페라리

페라리가 도요타보다 훨씬 빠른 이유는 무엇일까요? 정답은 공학 설계와 세부 사항에서의 차이입니다.
도요타는 고속 주행을 목표로 설계되지 않았습니다.

고속과 마찬가지로 고성능은 억지 기법이나 무차별적으로 달성되는 것이 아닙니다. 고성능을 목표로 한 치밀한 설계의 산물입니다. 페라리는 모든 세부 사항에서 더 빠르도록 설계되었으므로 도요타보다 빠릅니다.



---


## 4. 데이터 접근 패턴

데이터 접근 패턴은 애플리케이션이 MySQL을 사용하여 데이터에 접근하는 방법입니다.  접근 패턴에 대한 3가지 세부 정보를 명확히 정의하겠습니다.

1. 접근 패턴을 복수형으로 논의하는 것이 너무 일반적이어서 서로 모호해지기 시작합니다.
	- 그러나 그것들이 구분되지 않는 부분들이 아니라는 것을 이해하는 것이 중요합니다.
	- 애플리케이션에는 많은 접근 패턴이 있습니다. 편의상 복수형으로 논의되지만 실제로는 접근 패턴을 개별적으로 수정합니다.

2. 접근 패턴은 궁극적으로 쿼리를 참조하며 여러분은 접근 패턴을 변경하기 위해 쿼리와 애플리케이션을 변경하지만 쿼리가 초점이 아닙니다.
	- 구현이 나닌 인터페이스에 집중하세요
	- 이를 통해 서로 다른 데이터 스토리지에 대한 접근 패턴을 구상하고 적용할 수 있습니다.

3. 접근 패턴은 이름과 기술적인 특성 목록으로 구성됩니다.
	- 이름은 접근 패턴을 식별하고 다른 엔지니어와 소통하는 데 사용됩니다.

아래 목록은 접근 패턴을 식별하기 위한 접근 방식입니다.
- 팀과 브레인스토밍하여 가장 명백하고 일반적인 접근 패턴을 식별합니다.
- 쿼리 보고를 사용하여 가장 느린 상위 접근 패턴을 식별합니다.
- 덜 알려진 접근 패턴에 대한 코드를 자세히 알아봅니다.

이 장의 목표인 접근 패턴을 변경하여 간접 쿼리 최적화를 달성하려면 최소한 첫 번째나 두 번째 접근 방식을 한 번은 따라야 합니다.

지금부터 MySQL에 대한 데이터 접근 패턴의 9가지 특성을 살펴보겠습니다.


#### 읽기/쓰기

SELECT라는 읽기 접근은 명확합니다. 간단하게 정리해 INSERT, UPDATE, DELETE는 항상 쓰기 접근으로 간주합니다. 내부적으로 읽기와 쓰기는 같지 않습니다. 이것은 기술적 영향이 다르고 MySQL의 다른 내부 부분을 호출합니다.

읽기/쓰기 특성은 읽기와 쓰기를 확장하는 데 서로 다른 애플리케이션 변경이 필요하므로 가장 기본적이고 보편적인 특성 중 하나입니다. 애플리케이션이 읽기 중심인지 스기 중심인지 알면 신속하게 관련 애플리케이션 변경에 집중할 수 있어서 중요합니다.


#### 처리량

처리량(QPS)과 데이터 접근의 변동은 무엇일까요? 우선 처리량은 성능이 아닙니다. 1QPS에 불과한 낮은 처리량의 접근만으로도 큰 피해를 줄 수 있습니다.

변동(QPS가 증가하고 감소하는 방식)도 똑같이 중요합니다. QPS는 일정 기간 동안 증감합니다. 일반적으로 업무 시간 때마다 QPS가 더 높아지고 한밤중에는 QPS가 낮아집니다. 문제는 업무 시간에 QPS가 높아지면 개발자가 스키마 변경을 수행하거나 데이터를 재처리할 수 없다는 것입니다.


#### 데이터 수명

접근 데이터의 수명은 얼마나 됩니까? 수명은 시간이 아니라 접근 순서에 상대적입니다. 애플리케이션이 10분 동안 백만 개의 행을 삽입하는 경우, 첫 번째 행은 10분이 지나서가 아니라 접근한 마지막 행이라서 가장 오래된 행입니다. 애플리케이션이 첫 번째 행을 갱신하면 가장 최근에 접근한 행이므로 가장 최신 행이 됩니다. 그리고 애플리케이션이 첫 번째 행에 다시는 접근하지 않고 다른 행에 지속해서 접근하면 첫 번째 행이 점점 더 오래된 행이 됩니다.

이 특성은 작업 세트에 영향을 미치기 때문에 중요합니다. 일반적으로 작업 세트는 자주 사용되는 인덱스값과 이 값이 참조하는 프라이머리 키 행이며 일반적으로 테이블 크기에서 작은 비율입니다. MySQL은 될 수 있는 한 많은 데이터를 메모리에 보관하고, 데이터 수명은 메모리의 데이터가 작업 세트의 일부인지 아닌지에 대해 영향을 미칩니다. 일반적으로 MySQL은 알고리즘과 데이터 구조 덕분에 작업 세트를 메모리에 유지하는 데 탁월하기 때문입니다.

![[Pasted image 20231222005039.png]]

데이터에 접근하면 데이터가 메모리에 최신 상태로 바뀌어 유지되고, 이 데이터는 자주 접근되기 때문에 이 데이터를 포함하는 작업 세트는 메모리에 남게 됩니다. 이것이 MySQL이 적은 메모리와 많은 데이터를 가지고 있어도 빠르게 운영할 수 있는 이유입니다.

오래된 데이터에 자주 접근하는 것은 여러 면에서 문제가 됩니다. 데이터는 여유 페이지(메모리 내)에 적재됩니다. MySQL은 사용할 수 있는 모든 메모리를 사용하지만 여유 페이지도 몇 개 유지합니다. 사용할 수 있는 여유 페이지가 있을 때는 정상인데, 문제는 스토리지에서 데이터를 읽는 것은 속도가 느리다는 것뿐입니다. 비정상적으로 여유 페이지가 하나도 없다면 문제가 3배로 악화됩니다.

첫째, MySQL은 가장 최근에 사용한 목록에서 추적하여 오래된 페이지를 제거해야 합니다.
둘째, 오래된 페이지가 더티(데이터 변경 사항이 디스크에 유지되지 않는 경우)일 때 MySQL은 이ㅡㄹ 제거하기 전에 플러시해야 하는데, 플러시는 속도가 느립니다.
셋째, 스토리지에서 데이터를 읽는 속도가 느리다는 원래 문제가 남아 있습니다.

> 간단히 말해서 오래된 데이터를 자주 가져오는 것은 성능에 문제가 있습니다.

> 오래된 데이터는 시간이 아니라 접근과 관련이 있다는 것을 기억하세요. 일주일 전에 마지막으로 로그인한 사용자의 프로필이 시간에 따라 반드시 오래된 것은 아니지만, 수백만 개의 다른 프로필 데이터에 접근했다면 상대적으로 오래된 것입니다.



#### 데이터 모델

접근 방식이 나타내는 데이터 모델은 무엇입니까? MySQL은 관계형 데이터 스토리지지만 일반적으로  키-값, 문서, 복잡한 분석, 그래프 등과 같은 다른 데이터 모델과 함께 사용됩니다. 비관계형 접근은 MySQL에 상당히 부적합하므로 잘 알고 있어야 합니다.

데이터 모델의 특성은 다른 특성처럼 프로그래밍 방식으로 측정할 수 없습니다. 대신 여러분은 접근 방식이 제시하는 데이터 모델을 결정해야 합니다. 접근 방식에 이상적인 데이터 모델을 결정한 다음, 해당 데이터 모델로 구축된 데이터 스토리지를 사용하세요


#### 트랜잭션 격리

데이터 접근에 필요한 트랜잭션 격리는 무엇입니까? 격리성(고립성)은 원자성, 일관성, 격리성, 지속성 등 4가지 ACID 속성 중 하나입니다. InnoDB의 모든 쿼리는 기본적으로 단일 SELECT 문을 포함하여 트랜잭션에서 실행됩니다. 따라서 접근이 필요하든 필요하지 않든 격리됩니다.

트랜잭션 격리에 대한 질문에 대한 대답은 크게 3가지 범주 중 하나로 분류됩니다.

1. 없음(None)
	- 이것은 비트랜잭션 스토리지 엔진에서 올바르게 실행됩니다.
	- 격리는 쓸모없는 오버헤드일 뿐이지만, 문제를 일으키거나 성능에 눈에 띄게 영향을 미치지는 않습니다.

2. 기본(Default)
	- 아마도 데이터 접근에는 격리가 필요하지만 어떤 수준이 필요한지 알 수 없거나 불분명합니다.
	- 애플리케이션은 MySQL의 기본 트랜잭션 격리 수준인 REPEATABLE READ로 올바르게 작동합니다.

3. 특정(Specific)
	- 데이터 접근은 같은 데이터에 접근하는 다른 트랜잭션과 동시에 실행되는 트랜잭션의 일부이므로 특정 격리 수준이 필요합니다.
	- 특정 격리 수준이 없으면 데이터에 접근할 때 잘못된 버전의 데이터를 볼 수도 있으며 이는 애플리케이션에 심각한 문제가 됩니다.


저자의 경험상 가장 일반적인 범주는 '기본'이며 MySQL의 기본 트랜잭션 격리 수준인 REPEATABLE READ가 대부분의 경우에 정확하기 때문에 중요합니다. 그러나 이 특성에 대한 대답은 없음 이나 특정으로 이어져야 합니다.

데이터 접근에 격리가 필요하지 않다면 트랜잭션 데이터 스토리지가 필요하지 않을 수 있습니다. 그렇지 않고 데이터 접근에 격리가 필요하다면 이제 격리 수준과 그 이유를 구체적으로 알 수 있습니다.

> 필요한 격리 수준과 그 이유를 알면 MySQL에서 다른 데이터 스토리지로 접근 방식을 변환하고 이동할 수 있습니다.


#### 읽기 일관성

강력한 일관성은 읽기가 가장 최신 값을 반환함을 의미합니다. 원본 MySQL 인스턴스에 대한 읽기는 강력한 일관성을 가지지만, 트랜잭션 격리 수준에 따라 현재 값을 결정합니다.

장시간 실행되는 트랜잭션은 오래된 값을 읽을 수 있지만 트랜잭션 격리 수준과 관련하여 기술적으로는 현재 값입니다. 이것은 모든 데이터 스토리지에 해당하지는 않습니다. 예를 들어 AWS DynamoDB는 최종 일관성 읽기로 기본 설정되며 강력한 일관성 읽기는 옵션이고 더 느리며 더 비쌉니다.

최종 일관성은 읽기가 이전 값을 반환할 수 있지만 결국에는 현재 값을 반환함을 의미합니다. MySQL 복제본에 대한 읽기는 복제 지연으로 인해 차이가 발생하지만 최종적으로 일관성이 있게 됩니다. 결국 지속 시간은 복제 지연과 거의 같으며 1초 미만이어야 합니다. 읽기 접근을 제공하는 데 사용되는 보제본을 읽기 복제본이라고 합니다.

MySQL 세계에서는 공통적으로 모든 접근은 원본 인스턴스를 사용하는데, 기본적으로 모든 읽기가 강력하게 일관적입니다. 그러나 읽기에 강력한 일관성이 요구되지 않는 경우도 흔합니다. 특히 복제 지연이 1초 미만일 때 그렇습니다.


#### 동시성

데이터를 동시에 접근합니까? 동시성이 제로라면 데이터에 접근할 대 동시에 같은 데이터를 읽거나 쓰지 않는다는 것을 의미합니다. 같은 데이터를 다른 시간에 읽거나 쓰는 경우에도 동시성은 제로입니다.
높은 동시성은 같은 데이터를 동시에 자주 읽기나 쓰기로 접근하는 것을 의미합니다.

동시성은 쓰기 접근에 대해 로우 락이 얼마나 중요한지를 나타냅니다. 당연히 같은 데이터에 대한 쓰기 동시성이 높을수록 로우 락 경합이 커집니다. 로우 락 경합으로 인해 발생하는 응답 시간이 증가해도 허용될 만한 시간이라면 허용되지만 대기 시간을 초과하면 허용되지 않습니다. 이러한 상황에 2가지 해결책만 있습니다. 바로 동시성을 낮추거나(접근패턴 변경) 쓰기 확장을 위한 샤드 구성입니다.

또한 동시성은 읽기 접근에 캐시를 얼마나 적용할 수 있는지를 나타냅니다. 같은 데이터를 높은 동시성으로 읽지만 자주 변경되지 않을 때는 캐시에 적합합니다.


#### 행 접근

행에 접근하는 방법은 무엇입니까? 행 접근에는 3가지 유형이 있습니다.

- 포인트 접근 : 단일 행
- 범위 접근 : 두 값 사이의 정렬된 행
- 임의 접근 : 임의의 순서로 된 여러 행

이 특성은 단순해 보이지만 2가지 이유로 쓰기 접근에 중요합니다.

1. 갭 락
	- 비고유 인덱스를 사용하는 범위와 임의 접근 쓰기는 갭 락으로 인해 로우 락 경합을 약화시킵니다.

2. 데드락
	- 임의 접근 쓰기는 데드락에 대한 설정이며, 데드락은 두 트랜잭션이 다른 트랜잭션에 필요한 로우 락을 보유하는 경우입니다.

행 접근은 샤딩 방법을 계획할 때도 중요합니다. 효과적으로 샤딩하려면 접근 패턴이 단일 샤드를 사용해야 합니다. 포인트 접근은 하나의 행, 하나의 샤드와 같은 샤딩에서 가장 잘 작동합니다. 범위와 임의 접근은 샤딩과 함께 작동하지만 너무 많은 샤드에 접근하여 샤딩의 이점을 무효화하지 않도록 신중한 계획이 필요합니다.


#### 결과 세트

데이터 접근이 결과 세트를 그룹화, 정렬, 또는 제한을 합니까? 이 특성은 대답하기 쉽습니다. 접근 방법에 GROUP BY나 ORDER BY 또는 LIMIT 절이 있습니까? 이러한 각 절은 다른 데이터 스토리지에서 접근 방법이 어떻게 변경이 될지, 어떻게 실행이 될지에 대해 영향을 미칩니다.


---


## 5. 애플리케이션 변경

데이터 접근 패턴을 변경하려면 애플리케이션을 변경해야 합니다. 이 절에 제시된 변경 사항은 전체가 아닌 일반적인 것으로, 매우 효과적이지만 애플리케이션에 크게 의존합니다. 결과적으로 각 변경 사항은 자신의 팀과 더 많은 논의와 계획이 필요합니다.

첫 번째를 제외한 모든 변경 사항에는 추가 인프라가 필요하다는 미묘한 공통점이 있습니다. 즉, 간접 쿼리 최적화에는 더 많은 노력이 필요합니다.

> 앞선 챕터에서 살펴본 직접 쿼리 최적화와 데이터 변경은 훨씬 적은 노력이 필요하며, 직접 쿼리 최적화는 대부분은 아니지만 많은 성능 문제를 해결해 줍니다.


#### 코드 감사

사람이 코드를 확인하지 않아도 그 코드가 얼마나 오랫동안 존재하고 실행될 수 있었는지 알면 놀랄지도 모릅니다. 모든 코드를 감사할 필요는 없으며 데이터베이스에 접근하는 코드만 감사하면 됩니다. 물론 실제 쿼리를 살펴보고 쿼리가 수행하는 비즈니스 로직인 컨텍스트도 고려해야 합니다.

아래와 같은 쿼리를 찾아보세요

- 더 이상 필요하지 않은 쿼리
- 너무 자주 실행되는 쿼리
- 너무 빠르거나 자주 재실행되는 쿼리
- 크거나 복잡한 쿼리 - 단순화할 수 있는지 여부

코드가 ORM을 사용하거나 모든 종류의 데이터베이스 추상화를 사용하는 경우 기본값과 구성을 다시 확인해 보세요. 한 가지 고려 사항은 일부 데이터베이스 라이브러리가 모든 쿼리 실행 후 경로를 확인하기 위해 SHOW WARNING을 실행한다는 것입니다. 보통은 문제가 되지 않지만 상당한 낭비이기도 합니다. 또한 드라이버 기본값, 구성과 릴리스 정보를 다시 확인해 보세요

애플리케이션이 실행하는 쿼리를 확인하기 위해 쿼리 프로파일을 사용하여 코드를 간접적으로 감사합니다. 알 수 없는 쿼리를 찾았고 애플리케이션에서 해당 쿼리를 실행하지 않는 것이 확실하다면 데이터 스토리지를 운영하는 사람에게 확인해 보세요.

마지막으로 가장 간과하는 사항은 MySQL 오류 로그를 검토하는 것입니다. 오류 로그에는 오류, 경고 등의 내용이 없어야 합니다.


#### 오프로드 읽기

기본적으로 소스라고 하는 단일 MySQL 인스턴스는 모든 읽기와 쓰기를 제공합니다. 프로덕션 환경에서 소스에는 모든 쓰기를 복제하는 또 다른 MySQL 인스턴스인 복제본이 최소한 하나 이상 있어야 합니다.

소스에서 읽기를 오프로드하여 성능을 향상시킬 수 있습니다. 이 기술은 MySQL 복제본이나 캐시 서버를 제공하여 읽기 작업을 처리합니다.

첫째, 소스의 부하를 줄이고 나머지 쿼리를 더 빠르게 실행시켜 여유 시간과 시스템 리소스를 확보합니다.
둘째, 읽기를 제공하는 복제본이나 캐시가 쓰기에 사용되지 않으므로 오프로드된 읽기에 대한 응답시간이 향상됩니다. 높은 처리량, 짧은 대기 시간 읽기를 달성하는 데 일반적으로 사용되는 윈-윈 기술입니다.

MySQL 복제와 캐시 쓰기에는 고유하고 피할 수 없는 지연이 있으므로 복제본이나 캐시에서 읽은 데이터는 현재 값으로 보장되지 않습니다. 결과적으로 복제본과 캐시의 데이터는 짧은 지연 후에 최신 데이터가 되며 최종 일관성을 갖게 됩니다. 따라서 복제본이나 캐시에서 읽기를 제공하기 전에 다음 사항을 확인해야 합니다.

> 오래된(결국 일관성이 있는) 데이터 읽기가 허용됨으로썽 ㅐ플리케이션이나 해당 사용자에게 문제를 일으키지 않아야 합니다.

최종 일관성이 허용된다는 요구 사항 외에도 오프로드된 읽기는 다중 명령문 트랜잭션의 일부가 아니어야 합니다. 다중 명령문 트랜잭션은 소스에서 실행되어야 합니다.

복제본이나 캐시에서 읽기를 제공하기 전에 복제본이나 캐시가 오프라인 상태일 때 애플리케이션 성능이 떨어진 상태로 실행될 경우 어떻게 하나요? 라는 질문에 정확하게 답해야 합니다.

> 복제본이나 캐시가 오프라인 상태일 때 성능이 저하된 상태로 실행되도록 애플리케이션을 설계, 구현, 테스트하는 것이 필수입니다.

마지막 요점은 모든 읽기를 오프로드하면 안 된다는 것입니다. 오프로드 읽기는 복제본이나 캐시가 수행할 수 있는 작업을 처리함으로써 소스에서 시간을 낭비하지 않기 때문에 성능이 향상됩니다. 따라서 느린 읽기를 오프로드하는 것부터 시작하세요

> 이 기술은 강력합니다. 몇 가지만 오프로드해도 성능을 크게 향상시킬 수 있으므로 읽기를 하나씩 오프로드합니다.


#### MySQL 복제본

모든 프로덕션 MySQL 설정에는 이미 최소한 1개 이상의 복제본이 있고, 2개 이상의 복제본이 있는 것은 흔한 일입니다. 따라서 MySQL 복제본을 사용하여 읽기를 제공하는 것이 일반적입니다. 인프라가 이미 있는 상태에서 소스 대신 오프로드 읽기에 복제본을 사용하도록 코드를 수정하기만 하면 됩니다.

복제본이 읽기로 사용될 수 있다고 가정하면 다음 3가지 이유로 캐시 서버보다 선호됩니다.

- 가용성
	- 복제본은 고가용성에 기반을 두므로 소스와 같은 가용성을 가져야 합니다.

- 유연성
	- 이전 절에서는 느린 읽기 작업을 오프로드하는 것부터 시작해야 한다고 했습니다.
	- 캐시는, 특히 캐시 서버의 CPU와 메모리는 구성 매개변수에 의해 제한되어 있습니다.
	- 반면에 고가용성을 위해 사용되는 복제본은 소스와 같은 하드웨어를 가져야 하므로 여유 리소스가 있습니다.

- 단순함
	- 애플리케이션은 복제본을 소스와 동기화 상태로 유지하기 위해 아무것도 할 필요가 없습니다. 
	- 애플리케이션은 캐시를 사용하여 갱신, 무효화, 제거를 관래해야 합니다.
	- 그러나 진정한 단순함은 복제본에 쿼리 변경이 필요하지 않다는 것입니다.

> 하지만, 캐시 서버는 MySQL보다 엄청 빠를 수 있다는 장점이 있습니다.


#### 캐시 서버

캐시 서버는 SQL, 트랜잭션, 지속성 있는 스토리지로 인해 방해받지 않습니다. 따라서 MySQL보다 매우 빠르지만 제대로 사용하려면 애플리케이션에서 더 많은 작업이 필요합니다. 앞 절에서 언급했듯이 애플리케이션은 캐시 갱신, 무효화, 제거를 관리해야 합니다.

캐시는 자주 접근하지만 드물게 변경되는 데이터에 적합합니다. MySQL 복제본의 경우 모든 변경 사항이 복제되기 대문에 이는 고려할 사항이 아니지만, 캐시는 애플리케이션이 넣은 내용만 저장합니다.

> 캐시가 실패하고 복구될 때 애플리케이션이 예상대로 작동하는지 확인하기 위해 테스트하고 캐시를 사용할지 말지 결정하세요


#### 쓰기 대기열에 넣기

대기열을 사용하여 쓰기 처리량을 안정화합니다. 아래 사진은 불안정하고 불규칙한 쓰기 처리량을 보여줍니다.

![[Pasted image 20231222014351.png]]

현재 불안정한 쓰기 처리량으로 성능을 수용할 수 있더라도 불안정한 처리량은 규모에 따라 악화되므로 성공의 비결이 아닙니다. 즉, 절대 안정적이지 않습니다.
대기열을 사용하면 아래 그림처럼 애플리케이션이 안정적인 속도로 변경을 처리할 수 있습니다.

![[Pasted image 20231222014442.png]]

쓰기 대기열과 안정적인 쓰기 처리량의 진정한 힘은 애플리케이션이 엄청난 양의 요청에 우아하고 예측 가능하게 응답할 수 있다는 것입니다. 대기열을 사용하면 엄청난 양의 요청들이 MySQL에 영향을 주지 않습니다. 요청들이 대기열에 들어가고 평소처럼 변경 사항을 처리합니다. 유일한 차이점은 일부 변경 사항이 평소보다 늦게 처리된다는 것입니다.

쓰기 대기열에 넣기는 구현할 가치가 있는 다른 이점을 제공합니다.

한 가지 장점은 MySQL 가용성에서 애플리케이션을 분리한다는 것입니다. 애플리케이션은 MySQL이 오프라인일 때 변경 사항을 적용할 수 있습니다.

또 다른 장점은 손실되거나 버려진 변경 사항을 복구하는 데 사용할 수 있다는 것입니다. 단계가 실패하거나 시간이 초과되면 애플리케이션이 변경 내용을 다시 대기열에 넣어 재시도할 수 있습니다.

세 번째 장점은 대기열이 Kafka와 같은 이벤트 스트림인 경우 변경사항을 재실행할 수 있다는 것입니다.


#### 데이터 분할

데이터는 여러분에게 가치가 있지만 MySQL에는 부담입니다. 데이터를 삭제하거나 보관할 수 없을 때 최소한 데이터를 분할해야 합니다.

먼저 MySQL 파티셔닝이 있습니다. MySQL은 파티셔닝을 지원하지만 특별한 처리가 필요합니다. 적용하거나 유지 보수가 쉬운 일이 아니며 일부 타사 MySQL 도구는 이를 지원하지 않습니다. 따라서 MySQL 파티셔닝을 사용하지 않는 것이 좋습니다.

애플리케이션 개발자가 구현하기에 가장 유용하고 일반적이며 더 쉬운 데이터 파티셔닝 유형은 핫 데이터와 콜드 데이터 즉, 자주 접근하는 데이터와 자주 접근하지 않는 데이터를 분리하는 것입니다.

핫 데이터와 콜드 데이터를 분리하는 것은 주로 핫 데이터에 대한 최적화입니다. 콜드 데이터를 다른 곳에 저장하면 3가지 즉각적인 이점이 있습니다.

더 많은 핫 데이터가 메모리에 적합하고, 쿼리가 콜드 데이터를 검사하는 데 시간을 낭비하지 않으며, 작업이 더 빠릅니다. 핫 데이터와 콜드 데이터를 분리하는 것은 접근 패턴이 완전히 다른 경우 후자에 대한 최적화이기도 합니다. 오래된 결제는 더 이상 각 결제에 대한 행이 필요하지 않은 단일 데이터 개체로 월별로 그룹화할 수 있습니다. 이때 문서나 키-값 스토리지가 콜드 데이터를 저장하고 접근하는 데 더 적합할 수 있습니다.

콜드 데이터는 같은 데이터베이스의 다른 테이블에 보관할 수 있습니다. 통제된 INSERT ... SELECT 문을 사용하여 핫 테이블에서 선택하고 콜드 테이블에 삽입하면 비교적 쉽습니다. 그런 다음 핫 테이블에 보관된 콜드 데이터를 DELETE 합니다. 일관성을 위해 트랜잭션에서 모든 것을 마무리합니다.

> 위 방법은 매우 간단하고 효과적입니다. 자주 접근하지 않는 데이터를 자주 접근하는 데이터의 접근 경로 밖으로 옮겨 성능을 향상시키세요


#### MySQL을 사용하지 않기

가장 중요한 변화는 MySQL이 접근 패턴에 가장 적합한 데이터 스토리지가 아닐 때 MySQL을 사용하지 않는 것입니다.
MySQL은 최선의 선택이 아닐 때에도 광범위한 데이터와 접근 패턴에 대해 놀라운 확장성을 제공합니다. 그러나 이것을 당연하게 여기지 마세요.


---


## 6. 더 좋고 빠른 하드웨어

하드웨어를 확장해야 하는 정확한 시점은 언제입니까

먼저 접근 패턴을 수정할 때까지 하드웨어를 확장하지 않습니다. 그러나 때때로 엔지니어는 그러한 애플리케이션을 변경하는 데 필요한 여유 시간이 없습니다.

아래 표에서 왼쪽 열에서 모든 항목과 오른쪽 열에서 최소 2개 이상의 항목에 체크해야 한다면 강력하게 하드웨어를 확장해야 할 시점이 되었음을 의미합니다.

| 1. 모두 체크                         | 2. 적어도 2개 이상 체크                      |
| ------------------------------------ | -------------------------------------------- |
| 응답 시간이 너무 깁니다.             | CPU 사용률이 80% 이상입니다.                 |
| 느린 쿼리가 최적화되었습니다.        | 실행 중인 스레드가 CPU 코어 수보다 많습니다. |
| 데이터가 삭제 또는 보관되었습니다.   | 메모리가 전체 데이터 크기의 10% 미만입니다.  |
| 접근 패턴을 검토하고 최적화했습니다. | 스토리지 IOPS 사용률이 80% 이상입니다.      |

위 표의 왼쪽 열은 1장 이후의 모든 것에 대한 반복이지만, 하드웨어 확장에 돈을 쓰는 것에 대한 명백한 정당화이기도 합니다. 오른쪽 열은 하드웨어가 같이 작동하기 때문에 적어도 2개 이상의 체크가 필요합니다.

스토리지 IOPS 활용도의 경우 애플리케이션이 읽기 집약적인지 쓰기 집약적인지에 따라 추가 고려 사항이 있습니다.

- 읽기 집약
	- 읽기 집약적인 접근 패턴에서 지속적으로 IOPS(Input/Output Operations Per Second)가 높은 것은 부족한 IOPS가 아니라 메모리 부족 때문일 수 있습니다.
	- 작업 세트가 메모리보다 훨씬 크고 읽기 처리량이 유난히 높다는 2가지 요인이 결합하면 읽기 IOPS가 높아질 수 있습니다.
	- 이러한 조합으로 인해 MySQL은 디스크와 메모리 간에 너무 많은 데이터를 교화하여 문제가 높은 IOPS로 표시됩니다. 이것은 드물지만 가능합니다.

- 쓰기 집약
	- 쓰기 집약적인 접근 패턴에서 지속적으로 높은 IOPS가 발생하는 원인은 IOPS가 충분하지 않기 때문일 수 있습니다.
	- 간단히 말해서 스토리지는 데이터를 원하는 만큼 빠르게 쓸 수 없습니다.
	- 쿼리, 데이터, 접근 패턴을 이미 최적화했으므로 이 시점에서 유일한 해결책은 더 많은 스토리지 IOPS를 확보하는 것입니다.


---


#### 요점 정리

이 장에서는 MySQL을 효율적으로 사용하도록 애플리케이션을 변경하는 방법을 결정하는 데이터 접근 패턴에 중점을 두었습니다. 중요한 요점은 다음과 같습니다.

- MySQL은 애플리케이션 쿼리만 실행하고 그 외에는 아무것도 하지 않습니다.
- 데이터베이스 성능은 하드웨어 용량의 100%에 다다를 때 불안정해집니다.
- 일부 애플리케이션은 모든 세부 사항이 고성능에 맞추어 설계되었으므로 MySQL 성능에서 훨씬 뛰어납니다.
- 접근 패턴은 애플리케이션이 MySQL을 사용하여 데이터에 접근하는 방법입니다.
- 다른 해결 방법을 최대한 적용해 본 후 하드웨어 확장을 통해 성능을 향상시킵니다.

