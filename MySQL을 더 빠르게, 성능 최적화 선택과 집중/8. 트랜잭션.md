
InnoDB가 스토리지 엔진의 기본값이고 사실상 표준입니다. 따라서 모든 MySQL 쿼리는 단일 SELECT 문이라도 기본적으로 트랜잭션에서 실행됩니다. 애플리케이션 워크로드(쿼리, 인덱스, 데이터 그리고 접근 패턴)가 잘 최적화되면 트랜잭션 성능과 관련된 문제가 없습니다. 

이 장에서는 일반적인 문제를 피하기 위해 MySQL 트랜잭션을 검토합니다.

1. 트랜잭션 격리 수준과 관련된 로우 락입니다.
2. ACID 속성(MVCC와 언두 로그)을 보장하면서 InnoDB가 동시 데이터 접근을 관리하는 방법을 검토합니다.
3. 변경 내역 목록 길이와 문제가 있는 트랜잭션을 나타내는 방법을 설명합니다.
4. 피해야 할 트랜잭션의 일반적인 문제를 열거합니다.
5. MySQL 에서 트랜잭션 세부 정보를 보고하는 방법입니다.


---

## 1. 로우 락

읽기는 행을 잠그지 않지만 (select ... for share 와 select ... for update 제외), 쓰기는 항상 행을 잠급니다. 테이블은 인덱스이므로, 행은 인덱스 레코드입니다. InnoDB 로우 락은 인덱스 레코드 갭 때문에 로우 락이 아니라 레코드 락 관점에서 논의됩니다. 갭은 아래 그림에 표시된 것처럼 두 인덱스 레코드 사이의 값 범위입니다.  2개의 프라이머리키 레코드, 2개의 의사 레코드(하한과 상한), 3개의 공백입니다.

![[Pasted image 20240206001255.png]]

인덱스 레코드는 2에서 시작하거나 5에서 끝나지 않으며, 엄밀히 말하면 하한과 상한에서 시작하고 끝납니다. 갭은 인덱스값이 없는 점선 상자로 표시됩니다.

- \[0, 2)
- (2, 5)
- (5, 4294967295]

애플리케이션은 행 단위로 처리하고 InnoDB 로우 락은 레코드 단위로 처리합니다. 이 절의 예는 갭 락이 상당히 광범위하고 개별 레코드 락보다 더 중요하다는 것을 보여줍니다.

데이터 잠금 이라는 용어는 모든 유형의 잠금을 나타냅니다. 많은 유형의 데이터 잠금이 있지만 아래 표에는 기본적인 InnoDB 데이터 잠금이 나열되어 있습니다.

![[Pasted image 20240206001508.png]]


아래 예시 테이블을 통해 InnoDB의 잠금에 대해 간단하게 알아보겠습니다.

```sql
CREATE TABLE `elem` (
	`id` int unsigned NOT NULL,
	`a` char(2) NOT NULL,
	`b` char(2) NOT NULL,
	`c` char(2) NOT NULL,
	PRIMARY KEY (`id`),
	KEY `idx_a` (`a`)
) ENGINE=InnoDB;
```

![[Pasted image 20240206001652.png]]

위의 elem 테이블은 고유하지 않은 인덱스 idx_a 는 a 열만 포함하고 행은 2개 뿐이며 2개의 프라이머리 키 값을 생성합니다.

#### 1) 레코드와 넥스트-키 락

프라이머리 키를 사용하여 행을 일치시키는 elem 테이블에 대한 UPDATE는 기본 트랜잭션 격리 수준인 REPEATABLE READ에서 4개의 데이터 잠금을 획득합니다.

![[Pasted image 20240206001817.png]]

첫 번째 행은 lock_type 열에 표시된 대로 테이블 락입니다.
두 번째 행은 모든 열에 표시된 대로 프라이머리 키값 2에 대한 레코드 락입니다.
세 번째 행은 의사 레코드의 넥스트-키 락입니다.
네 번째 행은 프라이머리 키값 5에 대한 넥스트-키 락입니다.

![[Pasted image 20240206001930.png]]


트랜잭션 격리 수준인 READ COMMITTED 는 넥스트-키 락을 포함하는 갭 락을 비활성화 합니다.

![[Pasted image 20240206002104.png]]

READ COMMITTED 트랜잭션의 동일한 UPDATE 문은 아래 그림처럼 일치하는 행에서만 레코드 락을 획득합니다.

![[Pasted image 20240206002150.png]]

READ COMMITTED를 사용하지 않는 이유는 무엇일까요? 이 질문은 완전히 특정 애플리케이션, 심지어 특정 쿼리로 만드는 접근 패턴 특성과 관련이 있습니다. 트랜잭션에서 READ COMMITTED 에는 2가지 중요한 부작용이 있습니다.

- 동일한 읽기 문을 다시 실행하면 다른 행을 반환할 수 있습니다.
- 동일한 쓰기 문을 다시 실행하면 다른 행에 영향을 미칠 수 있습니다.

트랜잭션이 잘못된 데이터를 읽거나 쓰거나 반환하지 않을 것으로 확신한다면 READ COMMITTED는 락과 언두 로그를 줄여서 성능을 향상하는 데 도움이 될 것입니다.

#### 2) 갭 락

갭 락은 순수하게 다른 트랜잭션이 갭에 행을 삽입하는 것을 금지하고 방지합니다. 이것이 갭 락의 전부입니다.
모든 갭 락은 다른 갭 락과 호환되므로 다중 트랜잭션이 같은 갭을 잠글 수 있습니다. 그러나 갭 락은 다른 트랜잭션이 갭에 행을 삽입하는 것을 방지하므로, 갭을 잠그는 유일한 트랜잭션일 때는 하나의 트랜잭션만 갭에 행을 삽입할 수 있습니다. 같은 갭에 대한 둘 이상의 잠금은 모든 트랜잭션이 갭에 행을 삽입하는 것을 방지합니다.

갭 락의 목적은 좁습니다. 다른 트랜잭션이 갭에 행을 삽입하지 못하도록 방지하는 것입니다. 그러나 갭에 접근하는 모든 쿼리가 갭 락을 만드므로 생성은 광범위합니다. 아무것도 읽지 않으면 행 삽입을 차단하는 갭 락이 생성될 수 있습니다.

```sql
BEGIN
SELECT * FROM elem WHERE id = 3 FOR SHARE;
```

![[Pasted image 20240206002638.png]]

위 예제에서 중요한 것은 SELECT가 어떤 행과도 일치하지 않는다는 것입니다. elem 테이블의 프라이머리 키값은 3이 아니라 2와 5입니다. 행도 없고 잠금도 없을까요?? 그렇지 않습니다. REPEATABLE 과 SELECT ... FOR SHARE 로 갭에 접근하면 아래 그림처럼 단독 갭 락을 호출합니다.

![[Pasted image 20240206002754.png]]

단독 갭 락 이라고 부르는 이유는 넥스트-키 락이나 삽입 의도 잠금을 수반하지 않기 때문입니다.

![[Pasted image 20240206002851.png]]

위 사진에서 첫 번째 결과는 IN 대신 BETWEEN을 사용한 것입니다. 두 트랜잭션 모두 REPEATABLE READ 이고 두 쿼리 모두 정확히 같은 EXPLAIN 계획(프라이머리 키에 대한 범위 접근)을 가집니다. 그러나 새 쿼리는 일치하는 행에서만 레코드 락을 획득합니다.

![[Pasted image 20240206002945.png]]

똑같은 EXPLAIN 계획이 있고 행이 일치하더라도 쿼리는 행에 다르게 접근합니다. BETWEEN 은 갭에 접근하므로 넥스트-키 락을 사용하여 갭을 잠급니다. IN은 갭에 접근하지 않으므로 레코드 락을 사용합니다.

> 갭 락은 READ COMMITTED를 사용하여 쉽게 비활성화할 수 있습니다.


#### 3) 세컨더리 인덱스

세컨더리 인덱스는 로우 락, 특히 고유하지 않은 인덱스와 관련하여 잠재적으로 광범위한 결과를 초래합니다.

```sql
BEGIN;
UPDATE elem SET c='' WHERE a BETWEEN 'Ar' AND 'Au';
```

![[Pasted image 20240206003216.png]]

아래 그림은 6개의 레코드 락(세컨더리 인덱스에 4개, 프라이머리 키에 2개)을 보여 줍니다.

![[Pasted image 20240206003247.png]]

UPDATE는 두 행만 일치하지만 전체 세컨더리 인덱스를 잠가 값을 삽입하지 못하게 합니다.

READ COMMITTED는 일치하는 행만 레코드 락으로 잠기므로 고유하지 않은 세컨더리 인덱스에 대해서도 갭 락을 방집합니다.

#### 4) 삽입 의도 잠금

삽입 의도 잠금은 갭이 다른 트랜잭션에 의해 잠기지 않을 때 트랜잭션이 갭에 행을 삽입함을 의미하는 특별한 유형의 갭 락입니다. 갭 락만 삽입 의도 잠금을 차단합니다. 삽입 의도 잠금은 3가지 이유로 특별합니다.

- 삽입 의도 잠금은 미래의 잡업을 나타내므로 갭을 잠그지 않습니다. 다른 트랜잭션이 보유한 갭 락이 없을 때 행을 삽입하는 것입니다.
- 삽입 의도 잠금은 다른 트랜잭션이 보유한 갭 락과 충돌할 때만 생성되고 보고됩니다. 그렇지 않으면 행을 삽입하는 트랜잭션에서 삽입 의도 잠금이 생성되거나 보고되지 않습니다.
- 삽입 의도 잠금이 생성되면 한 번 사용하고 한 번 허용되면 즉시 해제됩니다. 그러나 InnoDB는 트랜잭션이 완료될 때까지 계속 보고합니다.

> 어떤 의미에서 삽입 의도 잠금은 접근을 차단하지 않기 때문에 잠금이 아닙니다.


---


## 2. MVCC와 언두 로그

InnoDB는 다중 버전 동시성 제어(MVCC)와 언두 로그를 사용하여 ACID의 A, C, I 속성을 수행합니다. MVCC는 행에 대한 변경 사항이 행의 새 버전을 생성함을 의미합니다.

![[Pasted image 20240206003806.png]]

REPEATABLE READ 트랜잭션에서 첫 번째 읽기는 SELECT가 실행되는 순간 데이터베이스의 가상 보기인 일관된 스냅숏을 설정합니다. 이때 설정된 스냅숏은 해당 트랜잭션이 끝날 때까지 유지되며, 이후의 모든 읽기는 데이터베이스의 변경 내역에서 오직 이 시점의 행 접근에만 사용됩니다.

MySQL은 언두 로그를 사용하여 행을 롤백하고 버전 1을 재구성합니다. 원본 트랜잭션이 커밋되고 다른 활성 트랜잭션이 이전 스냅숏을 보유하고 있지 않다고 가정하면, 새 트랜잭션이 항상 현재 행 버전으로 시작하기 때문에 mySQL은 관련된 모든 언두 로그를 제거할 수 있습니다.

READ COMMITTED 트랜잭션에서 각 읽기는 새 스냅숏을 설정합니다. 결과적으로 각 읽기는 커밋된 최신 행 버전에 접근하므로 READ COMMITTED입니다. 스냅숏이 사용되기 때문에 언두 로그가 계속 생성되지만, 각 스냅숏은 읽기 기간 동안만 유지됩니다.

> 스냅숏은 읽기에만 영향을 미치며 쓰기에는 사용되지 않습니다.
> 쓰기는 트랜잭션 격리 수준에 관계없이 트랜잭션이 끝날 때까지 유지되는 언두 로그를 생성합니다.

> 언두 로그는 버퍼 풀 페이지에 있으므로 메모리를 사용하고 주기적으로 디스크로 플러시됩니다.


---

## 3. 변경 내역 목록 길이

변경 내역 목록 길이(HLL)는 제거 또는 플러시되지 않은 이전 행 버전의 양을 측정합니다. HLL의 가장 간단한 기능 단위는 변경입니다. HLL 값이 10,000 이면 10,000개의 변경으로 읽을 수 있습니다. HLL이 제거 또는 플러시되지 않은 이전 행 버전의 양을 측정한다고 할 수 있습니다.

100,000 보다 큰 HLL은 문제이므로 무시하면 안 됩니다. HLL은 이론적으로는 최댓값을 가지지만 MySQL의 성능은 그 값보다 훨씬 이전에 떨어질 것이 분명합니다. 언두 로깅은 매우 효율적이어서 MySQL 성능이 떨어지거나 최악의 경우 장애가 발생하는 HLL 값과 관련하여 HLL에는 큰 여유가 있습니다. MySQL이 200,000에서 충돌하는 것을 보았지만 200,000 을 훨씬 넘겨 잘 실행되는 것도 보았습니다. 한 가지 확실한 것은 HLL이 확인되지 않고 증가하면 성능이 눈에 띄게 느려지거나 MySQL이 충돌하는 문제가 발생한다는 점입니다.

> MVCC, 언두 로그 그리고 HLL은 모두 정상이고 좋은 절충안입니다. 즉, 많은 동시성을 위한 약간의 성능 저하입니다. HLL이 지나치게 큰 경우에만 원인을 해결하기 위한 조치를 취해야 합니다.


---

## 4. 일반적인 문제

BEGIN 으로 시작하여 여러 쿼리를 실행하고 COMMIT 으로 끝나는 다중 명령문 트랜잭션이 문제입니다. 트랜잭션이 커밋될 때까지 잠금과 언두 로그가 유지되기 때문에 다중 명령문 트랜잭션의 성능 영향은 해당 부분의 합계보다 클 수 있습니다.

#### 1) 대규모 트랜잭션(트랜잭션 크기)

대규모 트랜잭션은 과도한 수의 행을 수정합니다. 전체 데이터베이스에 500,000개의 행이 있고 하나의 트랜잭션이 250,000개의 행을 수정한다면 이는 과도한 것입니다.

트랜잭션이 기본 격리 수준인 REPEATABLE READ에서 실행 중이라면 갭 락으로 인해 수정된 행보다 더 많은 수의 레코드를 잠근 것으로 가정해야 안전합니다. 트랜잭션이 READ COMMITTED 격리 수준에서 실행 중이라면 수정된 각 행에 대한 레코드 락만 획득합니다.

결론적으로, 트랜잭션은 작을 수록 더 좋습니다. 해결 방법은 트랜잭션에서 너무 많은 행을 수정하는 쿼리를 찾아 더 적은 수로 행을 수정하도록 변경하는 것입니다.


#### 2) 오래 실행되는 트랜잭션

오래 실행되는 트랜잭션은 완료하는 데 너무 오래 걸립니다. 얼마나 오래 걸려야 오래 걸리는 것인지는 조건에 따라 다릅니다.

- 애플리케이션 또는 사용자에게 허용되는 것보다 더 깁니다.
- 다른 트랜잭션과 문제를 일으킬 만큼 충분히 깁니다.
- 변경 내역 목록 길이 경로를 발생시킬 만큼 충분히 깁니다.

성능 문제를 사전에 해결하지 않는 한, 두 번째와 세 번째 지점이 오래 실행되는 트랜잭션의 원인일 가능성이 큽니다. 애플리케이션이 쿼리 사이에 대기하지 않는다고 가정하면 오래 실행되는 트랜잭션에는 2가지 원인이 있습니다.

- 트랜잭션을 구성하는 쿼리가 너무 느립니다.
- 애플리케이션이 트랜잭션에서 너무 많은 쿼리를 실행합니다.

첫 번째 원인은 1 ~ 5 장에서 살펴본 기법으로 해결합니다.
두 번째 원인은 트랜잭션에서 실행되는 쿼리 수를 줄이도록 애플리케이션을 수정하여 해결할 수 있습니다.


#### 3) 지연된 트랜잭션

지연된 트랜잭션이 BEGIN 이후, 쿼리 사이 또는 COMMIT 이전에 너무 오래 대기하고 있습니다. 지연된 트랜잭션은 오래 실행되는 트랜잭션일 가능성이 크지만 원인은 다릅니다. 쿼리 대기 시간이 아니라 쿼리 간 대기 시간입니다.

기술적으로 말하면 BEGIN에서 COMMIT 까지의 트랜잭션 응답 시간은 쿼리 응답 시간의 합보다 훨씬 큽니다. 지연된 트랜잭션이 쿼리 사이를 대기 중이므로 MySQL은 책임이 ㅇ벗습니다. 대기는 애플리케이션에 의해 발생하며 그 이유는 무한합니다.


#### 4) 버려진 트랜잭션

버려진 트랜잭션은 활성 클라이언트 연결이 없는 활성 트랜잭션입니다. 버려진 트랜잭션의 2가지 주요 원인은 다음과 같습니다.

- 애플리케이션 연결 누수
- 반쯤 닫힌 연결


---

## 5. 보고

트랜잭션과 관련된 보고 내용으로 해당 내용은 필요한 경우 책을 찾아보는 것을 권장합니다. 크게 아래 내용에 대한 보고 쿼리들을 소개하고 있습니다.

- 활성 트랜잭션: 최신
- 활성 트랜잭션: 요약
- 활성 트랜잭션: 쿼리 수행 내역
- 커밋된 트랜잭션: 요약


---

## 요점 정리

이번 장에서는 일반적인 문제를 피하는 것과 관련하여 MySQL 트랜잭션을 살펴봤습니다. 요점은 아래와 같습니다.

- 트랜잭션 격리 수준은 로우 락에 영향을 미칩니다.
- 기본 InnoDB 데이터 잠금은 다음과 같습니다. 레코드 락(단일 인덱스 레코드 락), 넥스트-키 락(단일 인덱스 레코드와 그 앞의 레코드 간격 잠금), 갭 락(두 레코드 사이의 범위 잠금) 그리고 삽입 의도 잠금(갭에 INSERT를 허용. 잠금보다 대기 조건에 더 가까움).
- 기본 트랜잭션 격리 수준인 REPEATABLE READ는 접근되는 행 범위를 격리하기 위해 갭 락을 사용합니다.
- READ COMMITTED 트랜잭션 격리 수준은 갭 락을 비활성화합니다.
- InnoDB는 REPEATABLE READ 트랜잭션에서 일관된 스냅숏을 사용하여 다른 트랜잭션에 의한 행 변경에도 불구하고 읽기가 동일한 행을 반환하도록 합니다.
- 일관된 스냅숏을 위해서는 InnoDB가 언두 로그에 행 변경 사항을 저장하여 이전 행 버전을 재구성해야 합니다.
- 변경 내역 목록 길이(HLL)는 제거 또는 플러시되지 않은 이전 행 버전의 양을 측정합니다.
- HLL은 파멸의 전조입니다. HLL이 100,000보다 크면 항상 모니터링하고 경고합니다.
- 데이터 잠금과 언두 로그는 COMMIT 또는 ROLLBACK과 함께 트랜잭션이 종료될 때 해제됩니다.
- 트랜잭션을 둘러싼 4가지 일반적인 문제: 대규모 트랜잭션, 오래 실행되는 트랜잭션, 지연된 트랜잭션 그리고 버려진 트랜잭션
- MySQL 성능 스키마를 이용하면 자세한 트랜잭션을 확인할 수 있습니다.
- 트랜잭션 성능은 쿼리 성능만큼 중요합니다.
