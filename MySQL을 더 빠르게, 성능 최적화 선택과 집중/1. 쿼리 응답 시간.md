
## 쿼리 응답 시간

- 쿼리를 실행하는 데 소요되는 시간
- 같은 의미로 응답시간, 쿼리시간, 실행시간, 쿼리 지연시간 이라고도 합니다.
- 소요 시간은 MySQL이 쿼리를 받았을 때 시작되고 결과 세트를 클라이언트에 전송한 시점까지의 경과 시간을 의미합니다.

---

## 성능 관련 핵심 지표

쿼리 응답 시간은 누구나 진정으로 관심을 가지는 유일한 메트릭입니다.
우리에게는 **시간**이 의미가 있습니다.

> 결국 MySQL 성능에서 핵심 지표인 쿼리 응답 시간 향상에 집중해야 한다.


---

## 쿼리 보고

쿼리 보고는 쿼리 실행에 대해 중요한 통찰력을 제공하는 쿼리 매트릭의 모음을 나타냅니다.
- 소스 : 쿼리 메트릭은 2개의 소스에서 비롯되며 MySQL 배포 및 버전에 따라 다릅니다.
- 집계 : 쿼리 매트릭값은 정규화된 SQL 문법을 기준으로 그룹화되고 집계됩니다.
- 보고 : 쿼리 보고서는 고급 프로파일과 쿼리에 특화된 보고서로 구성됩니다.


#### 1. 소스

쿼리 메트릭은 슬로 쿼리 로그(slow query log)나 성능 스키마(perfermance schema)에서 비롯됩니다. 
- 슬로 쿼리 로그 : 디스크에 있는 로그 파일
- 성능 스키마 : performance_schema와 같은 이름의 데이터베이스입니다.

여러 상황을 고려해봐도 성능 스키마는 현재 모든 버전과 배포 버전에 포함되어 있으므로 쿼리 메트릭을 제공하는 가장 좋은 소스입니다. 성능 스키마는 로컬과 클라우드에서 작동하며, 일관성이 있습니다.
또한 성능 스키마는 MySQL을 심층 분석할 수 있는 풍부한 여타 데이터를 포함하므로 그 유용성은 쿼리 메트릭 차원을 훨씬 능가합니다.

> 슬로 쿼리 로그보다는 가능하면 성능 스키마를 사용하는 것이 좋습니다. 제공하는 정보가 성능 스키마에 비해 부족하기 때문입니다.


#### 2. 집계

쿼리를 어떻게 하면 고유하게 식별하여 쿼리가 속한 그룹을 결정하느냐가 중요합니다. 예를 들어, 시스템 메트릭(CPU, 메모리, 스토리지 등)은 호스트 이름이 고유하고 의미가 있으므로 호스트 이름별로 그룹화됩니다.

그러나 쿼리에는 호스트 이름처럼 고유하게 식별되는 속성이 없기 때문에 이를 해결하는 방법은 정규화된 SQL 문을 SHA-256 해시로 변환하는 것입니다.

![[Pasted image 20231120210437.png]]

MySQL은 SQL 문을 정규화하여 다이제스트 텍스트를 생성한 다음, 이에 대해 SHA-256 해시를 계산하여 다이제스트 해시를 생성합니다. 다이제스트 텍스트가 고유하므로 다이제스트 해시도 고유합니다.


![[Pasted image 20231120210610.png]]

위 2개의 쿼리는 논리적으로 사용자와 애플리케이션에서는 같을 수 있지만, 서로 다른 다이제스트로 정규화되므로 보고 측면에서는 서로 다른 쿼리입니다.

쿼리 정규화에서 한 가지 알아야 할 점은 값이 제거되므로 아래 두 쿼리는 같은 다이제스트로 정규화된다는 사실입니다. 이처럼 다이제스트는 두 쿼리가 같으므로 두 쿼리의 메트릭이 그룹화되고 집계되어 하나의 쿼리로 보고됩니다.

![[Pasted image 20231120211527.png]]


#### 3. 보고

거의 모든 쿼리 메트릭 도구는 **쿼리 프로파일**과 **쿼리 보고서**라는  2가지 수준의 계층 구조로 데이터를 제공합니다.

[ 쿼리 프로파일 ]

쿼리 프로파일에 느린 쿼리가 표시됩니다.
쿼리 보고를 위해 최상단에 구성된 것으로, 일반적으로 쿼리 메트릭 도구에 처음 표시되는 항목입니다. 쿼리 다이제스트와 함께 메트릭의 제한된 하위 세트를 제공하므로 프로파일이라고 부릅니다.

일반적으로 쿼리 시간이 기본 정렬 메트릭입니다. 쿼리 시간을 기준으로 쿼리를 정렬하면 가장 느리고 시간이 오래 걸리는 쿼리부터 확인할 수 있습니다.

- 쿼리 총시간
	- 쿼리 총시간은 실행 시간의 총합입니다.
	- 이 값은 MySQL이 실행하는 데 가장 많은 시간을 소비하는 쿼리가 어느 것인지에 대한 중요한 질문에 답하므로 가장 일반적인 집계치입니다.
	- A라는 쿼리는 1초이고 10번 실행되는 반면, B라는 쿼리는 0.1초이고 1000번 실행된다면 쿼리 총시간으로 정렬된 프로파일에서 B가 더 느린 쿼리입니다.
	- 즉, 쿼리 B를 최적화함으로써 MySQL의 시간을 가장 많이 확보할 수 있기 때문에 중요합니다.

- 실행 시간 비율
	- 실행 시간 비율은 쿼리 총시간을 실행 총시간으로 나눈 값입니다.
	- 예를 들어 쿼리 C의 쿼리 총시간이 321ms이고, 쿼리 D의 쿼리 총시간이 100ms이면 실행 총시간은 421ms입니다.
	- C는 321/421 * 100 = 762.% 이고 D는 23.8% 입니다.
	- 실행 시간 비율로 정렬된 프로파일에서 C가 가장 느린 쿼리입니다.

- 쿼리 부하
	- 쿼리 부하는 쿼리 총시간을 클럭 타임으로 나눈 것으로, 클럭 타임은 시간 범위에 대한 전체 초 수입니다.
	- 시간 범위가 5분이면 클럭 시간은 300초 입니다.
	- 예를 들어 쿼리 E의 쿼리 총시간이 250.2초이면 부하는 250.2s / 300s = 0.83 이고, F의 쿼리 총시간이 500.1s 라면 부하는 1.67 입니다.
	- 쿼리 부하별로 정렬된 프로파일에서는 쿼리 F는 부하가 가장 크므로 가장 느린 쿼리입니다.
	- 부하는 시간과 관련이 있지만 동시에 실행되는 쿼리의 다중 인스턴스와 같은 동시성을 미묘하게 나타내기도 합니다.

> 쿼리 부하가 평균적으로 1.0보다 작으면 쿼리가 동시에 실행되지 않습니다. 쿼리 부하가 1.0 보다 크면 쿼리 동시성을 나타냅니다.


[ 쿼리 보고서 ]

쿼리 보고서는 하나의 쿼리에 대해 알아야 할 모든 것을 보여줍니다. 이것은 쿼리 보고를 구성하는 두 번째 단계입니다.
일반적으로 쿼리 프로파일에서 느린 쿼리를 선택하는 것으로 시작합니다.

쿼리 보고서는 쿼리 메트릭 도구에 따라 크게 달라집니다. 가장 기본적인 최소 보고서에는 소스에서 비롯된 모든 쿼리 메트릭과 최소, 최대, 평균, 백분위수 등 해당 메트릭의 기본 통계값이 포함됩니다.
쿼리 분석에는 보고서의 쿼리 메트릭만 있으면 됩니다. 메타데이터는 수동으로 수집할 수 있습니다.

이렇게 쿼리 보고서가 있다면 쿼리 분석을 수행할 준비가 된 것입니다.


---


#### 4. 쿼리 분석

쿼리 분석의 목표는 느린 응답 시간을 해결하려는 것이 아니라 '쿼리 실행'을 이해하려는 것입니다. 느린 응답 시간을 해결하는 행위는 쿼리 분석 후 쿼리 최적화 과정에서 이루어집니다. 먼저 변경하려는 내용, 즉 쿼리 실행을 이해해야 합니다.

쿼리 실행은 서론에서 본론을 거쳐 결론으로 이어지는 하나의 이야기와 같습니다.

지금 부터 통찰력을 얻는 쿼리 분석에 대해 주요 방향을 설명하겠습니다.

> 지금 부터 설명할 9가지 메트릭은 어떤 쿼리 분석에서든 상당히 중요합니다.
> 성능 스키마는 9가지 필수 쿼리 메트릭을 모두 제공합니다.


[ 쿼리 시간 ]

- 쿼리 시간은 알고 있듯이 가장 중요한 메트릭입니다.
- 쿼리 시간에는 또 다른 메트릭인 잠금 시간이 포함되어 있습니다. 잠금 시간은 쿼리 시간에 내재된 시간이므로 쿼리 시간이 잠금 시간을 포함한다는 것은 당연합니다.
- 성능 스키마를 사용하면 전부는 아니지만 쿼리 실행의 많은 부분을 알 수 있습니다.
- 모든 쿼리가 트랜잭션 안에서 수행되므로 트랜잭션은 최상위 이벤트입니다.
- 명령문은 쿼리 메트릭이 적용되는 쿼리입니다.
- 단계는 명령문 실행 과정 내의 단계로, 명령문 구문 분석, 테이블 열기, 파일 정렬 수행과 같은 과정을 포함합니다.
- 대기는 시간이 걸리는 이벤트입니다.

![[Pasted image 20231120221522.png]]

- 성능 스키마 이벤트(트랜잭션, 명령문, 단계, 대기)는 쿼리 실행과 관련된 세부 사항입니다. 쿼리 메트릭은 명령문에 적용됩니다. 여러분이 쿼리를 더 깊이 파고들어야 할 때는 성능 스키마를 참조하세요


[ 잠금 시간 ]

- 잠금 시간은 쿼리를 실행하는 동안 잠금을 획득하여 사용한 시간입니다.
- 이상적으로 잠금 시간은 쿼리 시간의 극히 일부여야 하지만, 값은 상대적입니다.
- 비록 상대적인 값이지만, MySQL은 대기가 아니라 작업에 대부분의 시간을 사용해야 하므로 잠금 시간이 쿼리 시간의 50% 이상이면 문제라고 할 수 있습니다.

> [[트랜잭션과 잠금|MySQL 스토리지 엔진과 데이터 잠금]]
> 
> InnoDB 스토리지 엔진에서 잠금에는 테이블 락과 로우 락이 있습니다. 서버는 테이블과 테이블 락을 관리합니다. 로우 레벨 락은 이 잠금이 지원되는 스토리지 엔진이 관리합니다. InnoDB는 로우 레벨 락을 지원하므로 로우 락으로 데이터 접근을 관리합니다.
> 
> 서버에서 관리하는 메타데이터 락이 있는데 스키마, 테이블, 저장 프로그램 등의 접근을 제어합니다. 모든 쿼리는 접근하는 모든 테이블을 대상으로 메타데이터 락을 획득합니다. 메타 데이터 락은 쿼리가 아니라 트랜잭션이 끝날 때 해제됩니다.


- 성능 스키마의 잠금 시간에는 로우 락 대기가 포함되지 않고, 테이블과 메타데이터 락 대기만을 포함합니다.
- 즉, 성능 스키마에서는 확실히 메타데이터 락 대기입니다. 슬로 쿼리 로그에서는 로우 락 대기일 수 있지만 메타데이터 락 대기도 가능합니다.

테이블의 데이터를 변경하거나 작성하기 전에 행을 잠가야 하므로 잠금은 주로 쓰기에 사용됩니다. 쓰기에 대한 응답 시간은 부분적으로 잠금 시간에 따라 달라집니다. 로우 락을 획득하는 데 필요한 시간은 동시성에 따라 다릅니다. 즉, 얼마나 많은 쿼리가 같은 행에 동시에 접근하는지에 따라 다릅니다.

매우 자주 접근하는 행이라면 잠금 시간이 응답 시간에서 상당 부분을 차지할 수 있습니다.

읽기 에서는 비잠금 일기와 잠금 읽기가 있습니다. 
select ... for update 와 select ... for share  같이 2가지 잠금 읽기가 있고 단순 select는 비잠금 상태이며 일반적인 경우입니다.
위에서 얘기한 select for update와 for share가 유일한 잠금 읽기지만, 선택적 select를 사용한 쓰기를 잊으면 안 됩니다.

- insert ... select from s
- replace ... select from s
- update ... where ... select from s
- create table ... select from s

엄밀히 말해서 이러한 SQL문은 읽기가 아니라 쓰기지만, 선택적 select는 테이블 s의 공유 로우락을 획득합니다.

잠금 읽기, 특히 select ... for update는 확장이 어렵고 문제를 일으키는 경향이 있으며, 일반적으로 같은 결과를 얻을 수 있는 비잠금 해결책이 있기 대문에 피해야 합니다.

비잠금 읽기는 비차단을 의미하지 않습니다. select 쿼리는 접근하는 모든 테이블에서 공유 메타데이터 락을 획득해야 합니다.
alter table 은 배타 메타데이터 락을 획득하는 일반적인 작업입니다. 따라서 테이블 교체는 매우 빠르지만 배타 메타데이터 락이 유지되는 동안 모든 테이블 접근이 차단되므로 MySQL에 부하가 많을 때는 중단 현상이 눈에 띄게 발생할 수 있습니다.

![[Pasted image 20231120222925.png]]

위 그림은 쿼리 실행 중에 획득하고 해제되는 잠금을 보여줍니다.

1. 테이블에서 공유 메타데이터 락 획득
2. 의도 배타적 테이블 락 획득
3. 행 1 락 획득
4. 행 1 갱신(쓰기)
5. 행 2 락 획득
6. 행 2 락 해제
7. 행 3 락 획득
8. 행 3 갱신(쓰기)
9. 커밋 트랜잭션
10. 모든 락 해제

> 여기서 흥미로운 점은 성능 스키마의 잠금 시간에는 레이블 1과 2만 포함됩니다.
> 슬로 쿼리 로그에는 레이블 1, 2, 3, 5와 7이 포함됩니다.
> 
> 행 2는 잠겨 있다가 트랜잭션이 커밋되기 전에 갱신 없이 잠금이 해제됩니다. 이런 일이 발생할 수 있지만 항상 그런 것은 아니며 쿼리와 트랜잭션 격리 수준에 따라 다릅니다.



[ 조회된 행 ]

조회된 행은 MySQL이 쿼리 조건 절에 일치하는 행을 찾으려고 접근항 행의 수를 나타냅니다. 이것은 쿼리와 인덱스의 선택도를 나타냅니다.
쿼리와 인덱스의 선택도가 높을수록 MySQL이 일치하지 않는 행을 조회하는 데 낭비하는 시간이 줄어듭니다.

쿼리가 예상보다 많은 행을 조회하는 경우가 드문 일이 아닙니다. 그 원인은 일반적으로 쿼리나 인덱스의 선택도 때문이지만, 때로는 테이블이 예상보다 커져서 조회할 행이 많기 때문입니다.


[ 보낸 행 ]

보낸 행은 클라이언트에 반환된 행의 수를 나타냅니다. 보낸 행을 조회된 행과 비교하면 의미가 더해집니다.

- 보낸 행 = 조회된 행
	- 이상적인 경우는 보낸 행과 조회된 행이 같고, 특히 전체 행의 백분율로 계산했을 때 상대적으로 값이 작고, 허용할 수 있는 쿼리 응답 시간일 대입니다.
	- 비율과 관계없이 보낸 행과 조회된 행이 같고 값이 의심스러울 정도로 높으면 쿼리가 테이블 스캔을 유발한다는 것을 의미합니다.

> 조회하는 행 자체가 많을 경우 인덱스가 아닌 테이블 스캔을 할 수 있기 때문


- 보낸 행 < 조회된 행
	- 조회된 행보다 보낸 행이 작다는 것은 쿼리나 인덱스의 선택도가 좋지 않다는 신뢰할 만한 신호입니다.
	- 이 차이가 극심하면 왜 응답 시간이 느린지 설명할 수 있습니다.

- 보낸 행 > 조회된 행
	- select count(id) from t2 는 count(id) 값에 대해 1개 행을 보내지만 0개 행을 조회합니다.



[ 영향받은 행 ]

영향받은 행은 삽입, 갱신, 삭제된 행의 수를 나타냅니다. 엔지니어는 해당하는 행에만 영향을 미치도록 주의해야 합니다. 해당하지 않는 행이 변경되면 심각한 버그가 발생합니다.



[ 셀렉트 스캔 ]

셀렉트 스캔은 첫 번째로 접근한 테이블에서 수행한 전체 테이블 스캔 횟수를 나타냅니다. 이는 쿼리가 인덱스를 사용하지 않는다는 것을 의미하므로 일반적으로 성능에 좋지 않습니다.
셀렉트 스캔이 0이 아니면 쿼리 최적화를 강력하게 권장합니다.
셀렉트 스캔은 모두 0이거나 모두 1일 가능성이 큽니다. 0이면 정말 좋은 상황이며, 0이 아니면 쿼리를 최적화해야 합니다.



[ 셀렉트 풀 조인 ]

셀렉트 풀 조인은 조인된 테이블을 대상으로 전체 테이블을 스캔한 수를 나타냅니다. 이것은 셀렉트 스캔과 유사하지만 더 나쁩니다.
셀렉트 풀 조인은 항상 0이어야 합니다. 그렇지 않으면 쿼리 최적화를 해야 합니다.

여러 테이블이 있는 쿼리를 EXPLAIN 으로 확인하면, MySQL은 테이블 조인 순서를 위쪽으로 출력합니다.
셀렉트 스캔은 첫 번째 테이블에만 적용됩니다. 셀렉트 풀 조인은 두 번째와 후속 테이블에만 적용됩니다.

> 쿼리 실행 중에 테이블에서 발생하는 풀 조인의 수가 이전 테이블 행의 곱과 같아서 셀렉트 풀 조인은 셀렉트 스캔보다 더 나쁩니다.



[ 디스크에 생성된 임시 테이블 ]

디스크에 생성된 임시 테이블은 디스크에 생성된 임시 테이블의 수를 나타냅니다. 쿼리가 메모리에 임시 테이블을 만드는 것은 정상입니다. 그러나 메모리에 임시 테이블이 너무 커지면 MySQL은 임시 테이블을 디스크에 씁니다. 디스크 접근 속도가 메모리보다 자릿수가 다를 정도로 훨씬 느리므로 응답 시간에 영향을 미칩니다.

과도하게 사용되는 디스크의 임시 테이블은 쿼리 최적화가 필요함을 나타내거나, 어쩌면 시스템 변수인 tmp_table_size 가 너무 작음을 나타냅니다.

> 쿼리를 먼저 최적화하세요. 시스템 변수는 최후의 수단으로 변경해야 합니다. 특히 메모리 할당에 영향을 미치는 변수는 조심해서 변경해야 합니다.



[ 쿼리 카운트 ]

쿼리 카운트는 쿼리 실행 횟수를 나타냅니다. 이 값은 매우 낮고 쿼리가 느리지 않는 한 기준은 없고 임의적입니다.




[ 메타데이터와 애플리케이션 ]

쿼리 메트릭보다 쿼리 분석에 더 많이 사용하는 것이 있습니다. 바로 메타데이터입니다. 실제로 explain 계획과 각 테이브르이 구조, 이 2가지 메타데이터가 없으면 쿼리 분석을 완료할 수 없습니다.

그런데 쿼리 메트릭과 메타데이터보다 쿼리 분석에 더 많이 활용하는 것이 있습니다. 바로 애플리케이션입니다.
쿼리 메트릭과 메타데이터는 모든 쿼리 분석에 필수적이지만, 쿼리가 어떤 용도로 사용되는지 알 때 비로소 이야기가 완성됩니다.

> 쿼리 메트릭과 메타데이터, 애플리케이션으로 이야기를 완성하면 바람직합니다.



[ 상댓값 ]

각 쿼리 메트릭에서 객관적으로 긍정적으로 보는 유일한 값은 0입니다. 상대값은 메트릭과 메타데이터, 애플리케이션과 같은 전체 이야기를 고려할 때 비로소 의미가 있습니다.

- 평균
	- 평균에 속으면 안 됩니다.
	- 쿼리 수가 적을 때는 매우 크거나 작은 몇 개의 값이 평균 응답 시간을 왜곡할 수 있습니다.

- 백분위수
	- 백분위수는 평균이 갖는 문제를 보완합니다.
	- 백분위수를 간단히 설명하면 P95는 샘플의 95%가 이보다 작거나 같은 값입니다.
	- 객관적인 면에서 평균보다 대표성을 뜁니다.
	- 백분위수를 사용하는 또 다른 이유는 무시되는 값의 작은 비율을 특이값으로 간주하기 때문입니다.

- 최대
	- 최대 쿼리 시간은 백분위수가 갖는 문제를 보완하므로 어떤 값도 버리지 마세요
	- 최댓값은 평균과 같은 낙관이나 통계적 환영이 아닙니다.
	- 세계 어딘가에서 일부 애플리케이션 사용자는 최대 쿼리 응답 시간을 경험하였거나 몇 초 후에 절망하고 떠났습니다.
	- 그 이유를 알려고 한다면 답을 찾을 수 있습니다. 

> 평균과 백분위수, 최대는 유용하며 이들이 나타내는 것과 나타내지 못하는 것을 알고 있으면 됩니다.



---


#### 5. 쿼리 응답 시간 개선

쿼리 응답 시간을 개선하는 행위는 쿼리 최적화라 불리는 과정입니다. 저자는 그것을 적절한 기대치를 세우는 여정이라고 부릅니다.

[ 직접 쿼리 최적화 ]

직접 쿼리 최적화는 쿼리와 인덱스를 변경하는 것입니다. 이러한 변경으로도 성능 문제가 상당히 해결되므로 직접 쿼리 최적화에서 여정을 시작하겠습니다.
직접 쿼리 최적화가 필요 조건이지만 충분 조건은 아닙니다.
최적화된 쿼리는 다양한 상황에서 문제가 되거나 문제의 소지가 있습니다. 여러분이 쿼리를 더이상 최적화할 수 없을 때는 쿼리 주변을 최적화해야 하며, 이는 두 번째 여정인 간접 쿼리 최적화로 이어집니다.


[ 간접 쿼리 최적화 ]

간접 쿼리 최적화는 데이터와 접근 패턴을 변경하는 것입니다. 쿼리 변경 대신 쿼리가 접근하는 대상과 방법을 변경합니다. 쿼리 데이터, 접근 패턴은 성능과 관련하여 땔 수 없는 관계이므로 이러한 변경은 쿼리를 간접적으로 최적화해 줍니다. 하나의 변경 사항은 다른 것에 영향을 미치고 이는 쉽게 검증됩니다.

> 간접 쿼리 최적화가 여정에서 두 번째인 이유는 더 많은 노력이 필요하기 때문입니다. 직접 쿼리 최적화로 문제가 해결되면 간접 쿼리 최적화는 하지 않는 게 바람직합니다.



--- 



#### 6. 언제 쿼리를 최적화해야 할까

느린 쿼리는 늘 있게 마련입니다. 느린 쿼리를 수정하려고 시간을 투자하는게 항상 효율적인 것은 아니기 때문에 매번 쿼리를 최적화해서는 안 됩니다. 대신 쿼리 응답 시간이 허용될 만한 시간인지 판단해 보고 그렇지 않다면 쿼리를 계속 최적화합니다.

아래는 쿼리를 최적화해야 하는 3가지 상황입니다.

- 성능이 고객에게 영향을 미칠 때
	- 성능이 고객에게 영향을 미칠 때 쿼리를 최적화하는 것은 엔지니어의 의무입니다.

- 코드 변경 전후
	- 대부분의 엔지니어는 코드 변경 전후에 쿼리 최적화에 우선 순위를 두는 것에 반대하지 않지만, 저자의 경험에 따르면 그렇지 않은 경우도 있습니다.

- 한 달에 한 번
	- 코드와 쿼리가 변경되지 않더라도 데이터와 접근 패턴이라는 적어도 2가지 요소가 변경됩니다.



---



#### 7. MySQL을 더 빠르게

쿼리나 애플리케이션을 변경하지 않고 MySQL을 훨씬 더 빠르게 만드는 마법이나 비밀은 없습니다.

결론적으로 MySQL은 간단하게 빨라지지 않습니다. MySQL의 속도를 높이려면 직접 및 간접 쿼리 최적화라는 여정을 시작해야만 합니다.


---


#### 8. 요점 정리

이번 장에서 얘기한 주요 사항은 다음과 같습니다.

- 성능은 쿼리 응답 시간, 즉 MySQL이 쿼리를 실행하는 데 걸리는 시간입니다.
- 쿼리 응답 시간은 의미 있고 실행 가능하므로 MySQL 성능에서 핵심 지표입니다.
- 쿼리 메트릭은 슬로 쿼리 로그나 성능 스키마에서 비롯됩니다.
- 성능 스키마는 쿼리 메트릭 중 최상의 소스입니다.
- 쿼리 메트릭은 다이제스트에 의해 그룹화되고 집계됩니다.
- 쿼리 프로파일은 느린 쿼리를 보여 주며 느리다는 것은 정렬 메트릭과 관련됩니다.
- 쿼리 보고서는 하나의 쿼리를 대상으로 사용할 수 있는 모든 정보를 보여 주며 쿼리 분석에 사용합니다.
- 쿼리 분석의 목표는 느린 응답 시간을 해결하는 것이 아니라 쿼리 실행을 이해하녀는 것입니다.
- 쿼리 분석에는 쿼리 메트릭, 메타데이터, 애플리케이션 지식을 사용합니다.
- 쿼리 시간, 잠금 시간, 조회된 행, 보낸 행, 영향받은 행, 셀렉트 스캔, 셀렉트 풀 조인, 디스크의 임시 테이블, 쿼리 카운트와 같은 9가지 메트릭은 모든 쿼리 분석에서 매우 중요합니다.
- 쿼리 응답 시간을 향상 시키려면 직접 및 간접 쿼리 최적화라는 두 내용을 알아야 합니다.
	- 직접 쿼리 최적화는 쿼리와 인덱스를 변경하는 것입니다.
	- 간접 쿼리 최적화는 데이터와 접근 패턴을 변경하는 것입니다.
- 최소한 3가지 상황(성능이 고객에게 영향을 미칠때, 코드 변경 전후, 한달에 한번)에서 쿼리 프로파일을 검토하고 느린 쿼리를 최적화합니다.
- MySQL의 속도를 높이려면 응답 시간을 줄이거나 부하를 늘려야 합니다.