
MySQL의 단일 인스턴스에서 성능은 쿼리와 데이터, 접근 패턴, 하드웨어에 달렸습니다. 직간접적으로 쿼리 최적화를 꼼꼼하게 적용했는데도 더 이상 수용 가능한 성능을 발휘하지 못하면 애플리케이션 워크로드에 대한 단일 인스턴스의 MySQL 성능이 상대적 한계에 도달했다는 의미입니다. 이러한 상대적 한계를 뛰어넘으려면 애플리케이션 워크로드를 MySQL의 여러 인스턴스로 나누어 확장해야 합니다.

데이터베이스 샤딩은 여러 데이터베이스에 워크로드를 분산하여 성능을 향상시키는 스케일아웃 기술로 일반적이고 폭넓게 사용됩니다.
샤딩은 하나의 데이터베이스를 여러 개로 나눕니다. 각 데이터베이스는 샤드이며, 각 샤드는 일반적으로 별도의 하드웨어에서 실행되는 MySQL 인스턴스에 저장됩니다.

이번 챕터에서는 아래 4가지 주제에 걸쳐 샤딩의 기본 메커니즘을 소개합니다.

1. 단일 데이터베이스를 확장하지 않는 이유, 그리고 샤딩이 필요한 이유를 설명합니다.
2. 3장과 4장의 비유를 완성합니다. 조약돌이 바위보다 나은 이유입니다.
3. 관계형 데이터베이스 샤딩의 복잡한 주제를 간략하게 소개합니다.
4. 샤딩의 대안을 제시합니다.


---


## 1. 단일 데이터베이스를 확장하지 않는 이유

단일 애플리케이션이 단일 서버에 과부하를 일으킬 수 있다는 점에 의문을 제기하는 사람은 아무도 없습니다. 이것이 바로 MySQL뿐만 아니라 모든 유형의 서버와 애플리케이션을 수평 확장해야 하는 이유입니다.

애플리케이션 워크로드는 단일 서버의 속도와 용량을 크게 앞지를 수 있다는 기본적인 이유로 시작해서 5가지 이유를 알아보겠습니다.

#### 1) 애플리케이션 워크로드

데이터 크기는 늘어날수록 쿼리와 접근 패턴에 영향을 줍니다. 더 큰 하드 드라이브를 구입해도 문제가 해결되지 않습니다.
아래 그림에서 볼 수 있듯이 데이터를 저장할 수 있는 충분한 용량이 있지만 데이터가 워크로드의 유일한 부분은 아니기 때문입니다.

![[Pasted image 20240109234112.png]]

데이터는 워크로드의 한 부분일 뿐이고 나머지 두 부분(쿼리와 접근 패턴)을 무시할 수 없습니다. 많은 데이터가 있는 단일 서버에서 현실적으로 수용 가능한 성능을 발휘하려면 워크로드가 아래 그림과 같아야 합니다.

![[Pasted image 20240109234209.png]]

쿼리가 단순하고 인덱스가 매우 우수하며 접근 패턴이 단순하다면 단일 서버에 많은 데이터를 저장할 수 있습니다. 위 그림들을 통해 쿼리, 데이터, 접근 패턴으로 구성된 애플리케이션 워크로드가 하드웨어 용량에 맞아야 하므로 단일 데이터베이스에서는 더 이상 확장할 수 없음을 보여줍니다.

MySQL은 애플리케이션 워크로드가 단일 서버 하드웨어의 속도와 용량을 크게 앞지를 수 있기 때문에 규모에 따라 샤딩이 필요합니다.

#### 2) 쓰기

쓰기는 다음과 같은 몇 가지 이유로 단일 MySQL 인스턴스에서 확장하기 어렵습니다.

1. 단일 쓰기(원본) 인스턴스
- 프로덕션 환경에서 MySQL은 고가용성을 위해 복제 토폴로지에 연결된 여러 인스턴스를 사용합니다.
- 그러나 동시에 같은 행에 여러 번 쓸 수 있는 쓰기 충돌을 피하기 위해 쓰기는 단일 MySQL 인스턴스로 제한됩니다.
- MySQL은 모든 인스턴스에 다중 쓰기를 지원하지만 쓰기 충돌이 너무 번거로워서 이 기능은 잘 사용하지 않습니다.

2. 트랜잭션과 잠금
- 쓰기는 로우 락을 획득해야 하며 때로는 예상보다 훨씬 더 많은 행을 잠급니다.
- 같은 데이터에 대해 쓰기 작업량이 많은 워크로드라면 세계 최고의 하드웨어로도 도움이 되지 않습니다.

3. 페이지 플러싱(지속성)
- 페이지 플러싱은 MySQL이 디스크에서 변경 사항을 유지하는 지연된 프로세스입니다.
- 중요한 점은 페이지 플러싱이 쓰기 성능의 병목 현상이라는 것입니다.

4. 쓰기 확대
- 쓰기 확대는 필요 이상의 부가적인 쓰기를 말합니다.
- 세컨더리 인덱스가 가장 간단한 예입니다.

5. 복제
- 고가용성을 위해서는 복제가 필요하므로 모든 쓰기 작업은 다른 MySQL 인스턴스로 복제해야 합니다.
- MySQL은 비동기 복제, 반동기 복제 그리고 그룹 복제를 지원합니다.
- 모든 커밋을 하나 이상의 복제본에서 인지해야 하므로 네트워크 대기 시간에 대한 트랜잭션 처리량을 떨어뜨립니다.
- 네트워크 대기 시간은 밀리초 단위로 측정되므로 쓰기 성능에 미치는 영향은 눈에 띄지만, 커밋된 트랜잭션이 손실되지 않도록 보장하므로 절충할 가치가 있습니다.

> 규모가 큰 MySQL은 이러한 문제를 극복하고 쓰기 성능을 확장하기 위해 샤딩이 필요합니다.

#### 3) 스키마 변경

스키마 변경은 정기적인 작업 이상으로 필수 작업입니다. 또한 가장 큰 테이블은 그 크기가 사용량을 반영하고 사용량은 개발로 이어져 변화가 발생하므로 가장 큰 테이블이 자주 변경되는 것은 흔한 일이 아닙니다.

ghost 같은 온라인 스키마 변경 도구와 일부 내장 온라인 DDL 작업은 며칠 또는 몇 주 동안 실행될 수 있는데, 그런 긴 시간이 애플리케이션에는 문제가 되지 않으므로 정상으로 동작합니다.

그러나 긴 대기 시간은 눈에 띄지 않으므로 애플리케이션을 개발하는 엔지니어에게는 문제가 됩니다. 엔지니어가 스키마를 변경하기 위해 며칠 또는 몇 주를 기다릴 수 없으므로 규모에 맞는 MySQL 샤딩이 필요합니다.

#### 4) 작업

정확하고 세심한 주의를 기울여 쿼리를 직간접적으로 최적화하면 보기 전에는 믿지 못할 크기로 단일 데이터베이스를 확장할 수 있습니다. 그러나 앞에서 얘기한 작업 중 아래와 같은 내용은 없었습니다.

- 백업과 복원
- 실패한 인스턴스 재구축
- MySQL 업그레이드
- MySQL 종료, 시작, 충돌 복구

데이터베이스가 클수록 이러한 작업이 더 오래 걸립니다. 애플리케이션 개발자는 이러한 작업을 관리하지 않을 수 있지만, 데이터베이스를 관리하는 엔지니어들이 이용 불능 시간을 없게 하는 제로 다운타임 작업에 특별히 능숙하지 않으면 영향을 줄 것입니다.


---


## 2. 바위가 아닌 조약돌

바위보다 조약돌을 옮기는 것이 훨씬 쉽습니다. 규모가 큰 MySQL 샤딩은 작은 인스턴스를 많이 사용하여 달성합니다. 이 문맥에서 작다는 것은 2 가지를 의미합니다.

- 하드웨어가 수용할 수 있는 성능으로 애플리케이션 워크로드가 실행된다.
- 표준 작업에 허용되는 시간이 걸린다.

일단 데이터베이스가 샤딩되었다면 프로그래밍 방식으로 접근하므로 애플리케이션에서 샤드 수는 중요하지 않습니다. 그러나 운영, 특히 MySQL 인스턴스를 운영하는 엔지니어에게 샤드의 크기는 매우 중요합니다.


---

## 3. 샤딩: 간략한 소개

샤딩 방법과 구현은 반드시 애플리케이션 워크로드와 결합됩니다. 샤딩에는 아이디어에서 구현까지 2가지 경로가 있습니다.

1. 샤딩용으로 새로운 애플리케이션 설계
- 첫 번째이자 드문 경로는 애플리케이션이 처음부터 샤딩용으로 설계되는 경우입니다.
- 만약 새 애플리케이션을 개발한다면 나중에 마이그레이션하는 것보다 처음부터 샤딩하는 것이 훨씬 쉽습니다. 따라서 샤딩이 필요하다면 이 경로를 선택하는 것을 강력히 추천합니다.
- 샤딩이 필요한지 결정하려면 향후 4년 동안의 데이터 크기와 증가율을 추정해 보세요, 4년 안에 예상되는 데이터 크기가 현재 하드웨어 용량에 적합하다면 샤딩이 필요하지 않을 수 있습니다.
- 애플리케이션은 항상 무제한 데이터 세트를 정의할 때 제한을 둬야 합니다. 데이터가 무제한으로 커지도록 두지 마세요. 무제한 데이터 세트는 오래된 데이터가 자주 삭제되거나 보관되지 않는 한 샤딩이 필요함을 강하게 시사합니다.

2. 기존 애플리케이션을 샤딩으로 마이그레이션
- 숙련된 개발자로 구성된 팀과 함께 1년 이상의 기간을 잡고 마이그레이션을 계획하세요

> 샤딩은 두 경로에서 모두 복잡한 과정입니다. 샤딩을 시작하려면 샤드 키와 전략을 세우고 직면하게될 문제를 이해해야 합니다.

#### 샤드 키

MySQL을 분할하려면 애플리케이션이 프로그래밍 방식으로 데이터를 샤드에 매핑해야 합니다. 따라서 가장 근본적인 결정은 데이터를 분할하는 데 사용할 열인 샤드 키 입니다. 샤드 키는 데이터를 샤드에 매핑하기 위해 샤딩 전략과 함께 사용됩니다. MySQL에는 샤딩이라는 개념이 없으므로 그것에 대해 알지 못합니다. 따라서 다른 애플리케이션이 샤드 키로 데이터를 매핑하고 접근을 담당합니다.

이상적인 샤드 키에는 3가지 속성이 있습니다.

- 높은 카디널리티
	- 이상적인 샤드 키는 [[3. Resource/도서 정리/MySQL을 더 빠르게, 성능 최적화 선택과 집중/2. 인덱스와 인덱싱#최고의 선택도|카디널리티]]가 높아 데이터가 샤드 전체에 고르게 분산됩니다.

- 참조 애플리케이션 엔티티
	- 이상적인 샤드 키는 접근 패턴이 샤드를 교차하지 않도록 애플리케이션 엔티티를 참조합니다.
	- 예를 들어 결제 모듈에서 단일 고객에 대한 모든 결제가 같은 샤드에 위치해야 하므로 고객별 샤딩이 이상적입니다.

- 소규모
	- 샤드 키는 사용량이 많으므로 될 수 있는 한 작아야 합니다.
	- 전부는 아니더라도 대부분의 쿼리에는 분산 쿼리를 회피하기 위한 샤드 키가 포함됩니다.


#### 전략

샤딩 전략은 샤드 키값을 기준으로 데이터를 샤드에 매핑합니다. 애플리케이션은 샤드 키값에 해당하는 데이터를 사용하여 쿼리를 샤드로 라우팅하는 전략을 구현합니다.

해시, 범위, 조회와 관련해서 3가지 일반적인 전략이 있습니다. 3가지 모두 광범위하게 사용됩니다. 최선의 선택은 애플리케이션 접근 패턴, 특히 다음 3개 절에서 언급하는 행 접근에 따라 다릅니다.


##### 1) 해시 샤딩

해시 샤딩은 해시 알고리즘, 나머지 연산자, 샤드 수를 사용하여 해시 키값을 샤드에 매핑합니다.

![[Pasted image 20240110000630.png]]

이러한 경우 샤드 수를 변경하면 데이터와 샤드를 매핑하는 데 영향을 주게 됩니다. 다행이도 이 문제는 해결되었습니다.

일관된 해싱 알고리즘은 N에 독립적인 일관된 해시값을 출력합니다. 핵심은 일관성에 있습니다. 샤드가 변경될 때 해시값이 변경될 가능성은 여전히 있지만 훨씬 낮아집니다. 샤드가 변경될 가능성이 있으므로 일관된 해싱 알고리즘을 선택해야 합니다.

해시 샤딩은 값을 정수로 추상화하므로 모든 샤드 키에 대해 작동합니다. 이는 더 빠르거나 좋다는 의미가 아니라 해싱 알고리즘이 모든 샤드 키값을 자동으로 매핑하므로 더 쉽다는 의미입니다.


##### 2) 범위 샤딩

범위 샤딩은 아래 그림에 표시한 대로 연속적인 키값 범위를 정의하고 각 범위에 샤드를 매핑합니다.

![[Pasted image 20240110000907.png]]

키값 범위는 미리 정의해야 합니다. 이렇게 하면 데이터를 샤드에 매핑할 때 유연성을 얻을 수 있지만, 데이터가 샤드 전체에 고르게 분산되도록 하려면 데이터 분산에 대한 상세한 지식이 필요합니다.

범위 샤딩의 이점은 해시 샤딩과 달리 범위를 변경할 수 있어 데이터를 수동으로 재배치하는 데 도움이 된다는 것입니다. 범위 샤딩은 다음과 같은 경우에 잘 작동합니다.

- 샤드 키값의 범위는 제한적이다.
- 범위(최솟값과 최댓값)를 결정할 수 있다.
- 값의 분포를 알고 있으며 대부분 균일하다.
- 범위와 분포는 변경되지 않을 것이다.

포인트 접근은 행 접근이 범위에 고르게 분산되어 핫 샤드를 방지하는 한, 범위 샤딩과 잘 작동합니다. 범위 접근은 행 범위가 샤드 범위 내에 있는 한 범위 샤딩과 잘 작동합니다.


##### 3) 조회 샤딩

조회 샤딩은 샤드에 샤드 키값을 사용자 지정 매핑하는 것입니다. 아래 그림은 국가 코드 최상위 도메인을 샤드에 매핑하는 조회 테이블을 보여 줍니다.

![[Pasted image 20240110001234.png]]

조회 샤딩은 가장 유연하지만 조회 테이블을 유지 관리해야 합니다. 조회 테이블은 키-값 맵 역할을 합니다. 샤드 키값은 키이고 데이터베이스 샤드는 값입니다. 조회 테이블을 데이터베이스 테이블, 지속성 있는 캐시의 데이터 구조, 애플리케이션과 함께 배포된 구성 파일 등으로 구현할 수 있습니다.

조회 샤딩은 다음 예시에 적합한 이점이 있습니다. 인구가 매우 적은 모든 지역을 한 샤드에 매핑하는 것은 쉬운 일이지만, 해시나 범위 샤딩에서는 이런 사용자 지정 매핑을 수행할 수 없습니다. 조회 샤딩을 사용하면 해시와 범위 샤딩으로는 거의 불가능한 임의 접근으로 인한 교차 샤드 쿼리를 완화하기 위해 샤드 키값을 매핑할 수 있습니다.


#### 과제들

앞으로 소개할 과제들은 애플리케이션과 분할된 데이터베이스에 영향을 주므로 미리 계획을 수립하여 문제를 피하거나 완화할 방법을 알아 두면 좋습니다.

##### 1) 트랜잭션

트랜잭션은 여러 샤드에 걸쳐 작동하지 않습니다. 이것은 과제라기보다 방해 요소에 가깝습니다.
이 방해 요소는 피하는 것을 강력히 추천합니다. 애플리케이션 트랜잭션과 접근하는 데이터를 검토해 보고, 그런 다음 트랜잭션이 데이터에 접근하는 방식에 따라 작동하는 샤드 키와 전략을 선택해야 합니다.

##### 2) 조인

SQL 문은 여러 샤드에 걸쳐 테이블을 조인할 수 없습니다. 해법은 교차 샤드 조인입니다. 애플리케이션 조인은 여러 샤드에서 실행된 여러 쿼리의 결과입니다. 평범한 해법이 아니라 조인에 따라 복잡할 수도 있지만 실현 가능합니다.

##### 3) 교차 샤드 쿼리

교차 샤드 쿼리를 사용하려면 애플리케이션이 둘 이상의 샤드에 접근해야 합니다. 교차 샤드 쿼리는 지연 시간이 발생합니다. 여러 MySQL 인스턴스에 접근하는 데 내재된 지연입니다. 샤딩은 교차 샤드 쿼리가 표준이 아니라 예외일 때 가장 효과적입니다.

샤딩이 완벽하다면 모든 애플리케이션 요청은 한 샤드에만 접근합니다. 이것은 목표이지만 일부 애플리케이션은 효율적으로 샤딩된 경우에도 특정 요청을 수행하고자 여러 샤드에 접근해야 합니다. 따라서 한 샤드에만 접근하려고 무리하게 노력하지 않아도 됩니다.

교차 샤드 쿼리는 최소화해야 하지만, 애플리케이션 로직이 특정 요청에 교차 샤드 쿼리가 필요하다고 해도 이를 제거하려고 애쓰지 않아도 됩니다. 

관련 문제는 분산 쿼리, 즉 애플리케이션이 많은 샤드에 접근해야 하는 쿼리입니다. 적당한 수의 교차 샤드 쿼리는 불가피하지만 허용되고, 분산 쿼리는 샤딩의 목적과 이점에 반합니다. 따라서 분산 쿼리를 방지하고 제거해야 합니다. 애플리케이션에 분산 쿼리가 필요하지만 그렇게 할 수 없다면 샤딩은 아마도 적합한 해결책이 아니므로 접근 패턴을 변경해야 합니다.


##### 4) 리샤딩

리샤딩(또는 샤드 분할)은 하나의 샤드를 둘 이상의 새 샤드로 나눕니다. 리샤딩은 데이터 증가를 수용하는 데 필요하며, 샤드 간에 데이터를 재분산하는 데에도 사용할 수 있습니다.

샤딩은 더 많은 샤딩을 낳는다는 것이 샤딩의 어두운 면입니다. 만약 여러분이 한 번 샤딩하고 끝낼 수 있을까 라고 궁금해한다면 대답은 아마도 아닐 것 입니다. 리샤딩은 이전 샤드에서 새 샤드로 데이터 마이그레이션이 필요하므로 어려운 작업입니다.

데이터 마이그레이션 방법에 대한 3가지 높은 수준의 요구 사항만 언급하고 있습니다.

- 이전 샤드에서 새 샤드로의 초기 대량 데이터 복사
- 이전 샤드의 변경 사항을 새 샤드로 동기화(데이터 복사 도중과 이후)
- 새 샤드로 전화하기 위한 컷오버 프로세스


##### 5) 재조정

재조정은 접근을 더 균등하게 분산하기 위해 데이터를 재배치합니다. 핫 샤드를 처리하려면 재조정이 필요합니다. 목표는 모든 샤드에 동등한 접근과 성능이 나오는 것입니다.

재조정은 앞에서 살펴본 3가지 샤딩 전략에 따라 다릅니다.

- 해시 : 해시 알고리즘이 자동으로 데이터를 샤드에 매핑하기 때문에 해시 샤딩으로 데이터를 재배치하는 것은 사실상 불가능합니다. 한 가지 해결책은 재배치된 샤드 키가 포함된 조회 테이블을 사용하는 것입니다. 애플리케이션은 먼저 조회 테이블을 확인합니다. 샤드 키가 있으면 조회 테이블에 표시된 샤드를 사용합니다. 그렇지 않으면 해싱 알고리즘을 사용합니다.

- 범위 : 범위 샤딩으로 데이터를 재배치하는 것은 핫 샤드를 더 작고 분리된 샤드로 나누기 위해 범위를 재정의함으로써 가능합니다. 하지만 간단하지 않습니다. 이는 리샤딩과 같은 과정입니다.

- 조회 : 조회 샤딩으로 데이터를 재배치하는 것은 샤드에 대한 데이터 매핑을 제어하기 때문에 상대적으로 쉽습니다. 따라서 조회 테이블을 갱신하여 핫 데이터에 해당하는 샤드 키값을 다시 매핑합니다.


---

## 4. 대안들

샤딩은 복잡하며 사용자나 고객에게 직접적인 가치가 있는 것은 아닙니다. 확장성을 유지하는 것은 애플리케이션에 가치가 있지만 엔지니어에게는 까다로운 작업입니다. 이번 장에서는 관련 대안들을 소개하고 있습니다.

#### NewSQL
NewSQL은 스케일아웃을 기본으로 지원하는 관계형 ACID 호환 데이터 스토리지를 나타냅니다. 즉, 샤딩할 필요가 없는 SQL 데이터베이스입니다.

하지만 NewSQL은 MySQL 샤딩의 대안으로 검토해야 할 유망한 기술이지만 NewSQL은 MySQL을 쉽게 대체할 수 없습니다.


#### 미들웨어
미들웨어 솔루션은 애플리케이션과 MySQL 샤드 사이에서 작동합니다. 샤딩의 세부 사항을 숨기거나 추상화하거나 적어도 샤딩을 더 쉽게 만들려고 시도합니다. 직접적인 수동 샤딩이 너무 어렵고 NewSQL이 실행 불가능한 경우 미들웨어 솔루션이 그 격차를 해소하는 데 도움이 될 수 있습니다.


#### 마이크로서비스
샤딩은 하나의 애플리케이션과 해당 데이터, 특히 데이터 크기와 접근에 중점을 둡니다. 새로운 마이크로서비스와 해당 데이터베이스가 완전히 독립적이므로 샤딩보다 훨씬 쉽습니다.


#### MySQL을 사용하지 마세요
MySQL 샤딩의 대안을 솔직하게 평가하면 다른 데이터 스토리지나 기술이 더 잘 작동할 때는 MySQL을 사용하지 말라는 것으로 결론을 내려야 합니다.


---


## 요점 정리

이번 장에서는 MySQL을 확장하는 MySQL 샤딩의 기본 메커니즘을 소개했습니다. 요점은 다음과 같습니다.

- MySQL은 샤딩을 통해 수평 확장 됩니다.
- 샤딩은 하나의 데이터베이스를 여러 데이터베이스로 나눕니다.
- 애플리케이션 워크로드인 쿼리, 데이터, 접근 패턴의 조합이 단일 서버 하드웨어의 속도와 용량을 훨씬 능가하기 때문에 단일 데이터베이스를 기본적으로 확장하지는 않습니다.
- 하나의 거대한 데이터베이스보다 많은 작은 데이터베이스를 관리하는 것이 훨씬 쉽습니다. 바위가 아닌 조약돌입니다.
- 데이터는 신중하게 선택해야 하는 샤드 키로 샤딩됩니다.
- 샤드 키는 샤드에 데이터를 매핑하는 샤딩 전략과 함께 사용됩니다.
- 가장 일반적인 샤딩 전략은 해시, 범위, 조회입니다.
- 샤딩에는 해결해야 할 몇 가지 과제가 있습니다.
- 샤딩 전에 평가해 볼 만한 대안들이 있습니다.

