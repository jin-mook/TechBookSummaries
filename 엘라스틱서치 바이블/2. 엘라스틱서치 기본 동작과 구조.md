
이번 챕터에서는 엘라스틱서치의 기본 동작을 빠르게 둘러보고 기본 구조를 개괄적으로 살펴봅니다.


## 1. 엘라스틱서치 기본 동작 빠르게 둘러보기

#### 문서 색인

- \_id 를 지정하여 색인
	- 엘라스틱서치에 문서를 색인하려면 문서를 색인할 인덱스 이름, \_id 값을 지정하고 문서의 내용을 요청 본문에 담아서 REST API를 호출합니다.

```
PUT ［인덱스 이름]/_doc/[_id값］

{
［문서 내용］
}
```

- \_id 를 지정하지 않고 색인
	- \_id 값을 별도로 지정하지 않는다면 엘라스틱서치가 자동으로 해당 값을 생성해줍니다.
	- POST 메서드를 사용해 호출해야 합니다.

```
POST ［인덱스 이름]/_doc

{
 [문서 내용]
}
```


#### 문서 조회

문서를 조회할 때는 인덱스 이름과 \_id 값을 지정하여 GET 메서드로 호출합니다.

```
GET [인덱스 이름]/_doc/[_id값]
```


#### 문서 업데이트

- 문서를 업데이트할 때는 인덱스 이름과 \_id 값을 지정합니다.
- 요청 본문에는 부분 업데이트할 내용을 doc 필드 안에 지정합니다.
- 문서 업데이트 API는 색인 시에 사용한 \_doc 대신 \_update를 사용합니다.

```
POST [인덱스 이름]/_update/[_id값]
{
	"doc": {
		[문서 내용]
	}
}
```


#### 문서 검색

엘라스틱서치는 다양한 검색 쿼리를 가지고 있으며 이를 위한 전용 쿼리 DSL을 제공합니다. 검색을 위해서는 다음과 같이 인덱스 이름을 지정하고 그 뒤에 \_search를 붙여 GET 메서드를 사용합니다. 그리고 요청 본문에 엘라스틱서치 쿼리를 넣습니다.

그러나 GET 메서드에 요청 본문을 사용하는 API가 적절한지에 대한 의견이 많기 때문에 나중에 POST 메서드를 사용해도 동일하게 동작하도록 설계했습니다.

```
GET [인덱스 이름]/_search
POST [인덱스 이름]/_search
```

- 엘라스틱서치는 단순히 주어진 텍스트와 매칭되는 문서를 찾는 것이 아니라 문서를 분석해서 역색인을 만들어 두고 검색어를 분석해서 둘 사이의 유사도가 높은 문서를 찾는 것입니다.


#### 문서 삭제

문서 삭제 API는 인덱스 이름과 \_id 값을 지정하여 DELETE 메서드로 호출합니다.

```
DELETE [인덱스 이름]/_doc/[_id값]
```


---


## 엘라스틱서치 구조 개괄

![[Pasted image 20240115235739.png]]


- 문서(document) : 엘라스틱서치가 저장하고 색인을 생성하는 JSON 문서를 뜻합니다.

- 인덱스 : 문서를 모아 놓은 단위가 인덱스입니다. 클라이언트는 이 인덱스 단위로 엘라스틱서치에 검색을 요청하게 됩니다.

- 샤드 : 인덱스는 그 내용을 여러 샤드로 분리하여 분산 저장합니다. 또한 엘라스틱서치는 고가용성을 제공하기 위해 샤드의 내용을 복제해 둡니다. 원본 역할을 담당하는 샤드를 주 샤드라고 하고 복제본을 복제본 샤드라고 합니다.

- \_id : 인덱스 내 문서에 부여되는 고유한 구분자입니다. 인덱스 이름과 \_id 의 조합은 엘라스틱서치 클러스터 내에서 고유합니다.

- 타입 : 엘라스틱서치는 과거에 하나의 인덱스 안에 있는 여러 문서를 묶어서 타입이라는 논리 단위로 나눴습니다. 그러나 이 개념은 폐기됐으며 더 이상 사용되지 않습니다.

![[Pasted image 20240116000016.png]]


- 노드 : 엘라스틱서치 프로세스 하나가 노드 하나를 구성합니다. 엘라스틱서치 노드 하나는 여러 개의 샤드를 가집니다. 엘라스틱서치는 고가용성을 제공하기 위해 같은 종류의 샤드를 같은 노드에 배치하지 않습니다.

- 클러스터 : 이러한 엘라스틱서치 노드 여러 개가 모여 하나의 클러스터를 구성합니다.

- 노드의 역할 : 엘라스틱서치의 노드는 데이터 노드, 마스터 노드, 조정 노드 등 여러 역할 중 하나 이상의 역할을 맡아 수행합니다.


---


## 엘라스틱서치 내부 구조와 루씬

엘라스틱서치는 아파치 루씬을 코어 라이브러리로 사용하고 있습니다. 루씬은 문서를 색인하고 검색하는 라이브러리입니다.


#### 1. 루씬 flush

문서 색인 요청이 들어오면 루씬은 문서를 분석해서 역색인을 생성합니다. 최초 생성 자체는 메모리 버퍼에 들어갑니다.
문서 색인, 업데이트, 삭제 등의 작업이 수행되면 루씬은 이러한 변경들을 메모리에 들고 있다가 주기적으로 디스크에 flush 합니다.

![[Pasted image 20240116000310.png]]

루씬은 색인한 정보를 파일로 저장하기 때문에 루씬에서 검색을 하려면 먼저 파일을 열어야 합니다. 루씬은 파일을 연 시점에 색인이 완료된 문서만 검색할 수 있습니다. 이후 색인에 변경사항이 발생했고, 그 내용을 검색 결과에 반영하고 싶다면 파일을 새로 열어야 합니다.


엘라스틱서치는 내부적으로 루씬의 DirectoryReader 라는 클래스를 이용해 파일을 열고, 루씬의 색닝네 접근할 수 있는 IndexReader 객체를 얻습니다. 엘라스틱서치는 변경 내용을 검색에 반영하기 위해 루씬의 DirectoryReader.openIfChanged를 호출해 변경 사항이 적용된 새 IndexReader를 열어 준 뒤 기존 IndexReader를 안전하게 닫습니다. 이러한 작업을 엘라스틱서치에서는 <span style="color:#ffff00">refresh</span> 라고 합니다.


refresh 단계까지 온 데이터가 검색 대상이 됩니다. refresh는 어느 정도 비용이 있는 작업이기 때문에 엘라스틱서치는 색인이 변경될 때마다 refresh를 수행하지 않고 적절한 간격마다 주기적으로 실행합니다. 엘라스틱서치의 refresh API를 호출하면 필요에 따라 명시적으로 refresh 작업을 수행할 수 있습니다.


#### 2. 루씬 commit

루씬의 flush는 시스템의 페이지 캐시에 데이터를 넘겨주는 것까지만 보장할 뿐 디스크에 파일이 실제로 안전하게 기록되는 것까지 보장하지 않습니다. 따라서 루씬은 fsync 시스템 콜을 통해 주기적으로 커널 시스템의 페이지 캐시의 내용과 실제로 디스크에 기록된 내용의 싱크를 맞추는 작업을 수행합니다. 이를 루씬 <span style="color:#ffff00">commit</span> 이라고 합니다.

엘라스틱서치의 flush 작업은 내부적으로 이 루씬 commit을 거칩니다. 루씬의 flush 와 엘라스틱서치의 flush 는 다른 개념이기 때문에 이를 혼동하지 말아야 합니다. 엘라스틱서치의 flush는 엘라스틱서치 refresh 보다도 훨씬 비용이 드는 작업입니다. 그렇기 때문에 refresh와 마찬가지로 적절한 주기로 수행됩니다. 명시적으로 flush 작업을 수행할 수 있다는 것 역시 엘라스틱서치 refresh와 같습니다.

![[Pasted image 20240116004037.png]]


#### 3. 세그먼트

앞의 작업을 거쳐 디스크에 기록된 파일들이 모이면 세그먼트라는 단위가 됩니다. 이 세그먼트가 루씬의 검색 대상입니다. 세그먼트 자체는 불변인 데이터로 구성되어 있습니다. 즉, 새로운 문서가 들어오면 새 세그먼트가 생성됩니다. 기존 문서를 삭제하는 경우 삭제 플래그만 표시해 두고, 기존 문서에 업데이트가 발생한 경우에는 삭제 플래그를 표시하고 새 세그먼트를 생성합니다.

루씬의 검색은 모든 세그먼트를 대상으로 수행됩니다. 불변인 세그먼트의 개수를 무작정 늘려갈 수는 없기 때문에 루씬은 중간중간 적당히 세그먼트의 병합을 수행합니다. 세그먼트의 병합이 수행될 때 삭제 플래그가 표시된 데이터를 실제로 삭제하는 작업도 수행합니다.

![[Pasted image 20240116004247.png]]


#### 4. 루씬 인덱스와 엘라스틱서치 인덱스

여러 세그먼트가 모이면 하나의 루씬 인덱스가 됩니다. 루씬은 이 인덱스 내에서만 검색이 가능합니다. 엘라스틱서치 샤드는 이 루씬 인덱스 하나를 래핑한 단위입니다.

![[Pasted image 20240116004356.png]]


엘라스틱서치 샤드 여러 개가 모이면 엘라스틱서치 인덱스가 됩니다. 엘라스틱서치 레벨에서는 여러 샤드에 있는 문서를 모두 검색할 수 있습니다. 새 문서가 들어오면 해당 내용을 라우팅하여 여러 샤드에 분산시켜 저장, 색인합니다. 이후 클라이언트가 엘라스틱서치에 검색 요청을 보내면 엘라스틱서치는 해당하는 각 샤드를 대상으로 검색을 한 뒤 그 결과를 모아 병합하여 최종 응답을 만듭니다. 이런 구조를 통해 루씬 레벨에서는 불가능한 분산 검색을 엘라스틱서치 레벨에서는 가능하게 만들었습니다.

![[Pasted image 20240116004520.png]]


그리고 엘라스틱서치 인덱스를 구성하는 샤드는 여러 노드에 분산돼 있습니다. 이러한 노드가 모여서 하나의 엘라스틱서치 클러스터가 됩니다.


#### 5. translog

엘라스틱서치에 색인된 문서들은 루씬 commit 까지 완료되어야 디스크에 안전하게 기록됩니다. 그렇다고 문서에 변경사항이 있을 때마다 루씬 commit을 수행하기에는 commit 은 큰 비용이 드는 작업입니다. 하지만 변경사항을 모아서 commit 한다면 장애가 발생할 때 미처 commit 되지 않은 데이터가 유실될 우려가 있습니다. 이런 문제를 해결하기 위해 엘라스틱서치 샤드는 모든 작업마다 translog 라는 이름의 작업 로그를 남깁니다.

translog는 색인, 삭제 작업이 루씬 인덱스에 수행된 직후에 기록됩니다. translog 기록까지 끝난 이후에야 작업 요청이 성공으로 승인됩니다. 엘라스틱서치에 장애가 발생한 경우 엘라스틱서치는 샤드 복구 단계에서 translog를 읽습니다. translog 기록은 성공했지만 루씬 commit에 포함되지 못했던 작업 내용이 있다면 샤드 복구 단계에서 복구됩니다.

그런데 translog가 너무 커지면 샤드 복구에 시간이 오래 걸리게 됩니다. 이를 방지하기 위해서는 translog의 크기를 적절히 유지해줄 필요가 있는데, 앞에서 본 엘라스틱서치 flush는 루씬 commit을 수행하고 새로운 translog를 만드는 작업입니다. 이 엘라스틱서치 flush가 백그라운드에서 주기적으로 수행되며 translog의 크기를 적절한 수준으로 유지합니다.

![[Pasted image 20240116004933.png]]

