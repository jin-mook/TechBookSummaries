
## 클래스 단위로 잘 동작하도록 설계하기

일단 가장 중요한 것은 <span style="color:#ff0000">클래스 단위로도 잘 동작하게 설계해야 한다</span>는 접근 방법입니다.
클래스는 클래스 하나로도 잘 동작할 수 있게 설계해야 합니다. 또한 복잡한 초기 설정을 하지 않아도 곧바로 사용할 수 있게 만들어야 합니다. 그리고 클래스를 마음대로 조작해서 클래스 전체가 고장 나는 일(버그 발생)이 없게, 최소한의 조작 방법(메서드)만 외부에 제공해야 합니다.

#### 1) 클래스의 구성 요소

클래스는 기본적으로 다음 두 가지로 구성됩니다.

- 인스턴스 변수
- 메서드

이러한 구성에서 버그를 일으키는 악마를 적게 불러오려면, 메서드의 역할을 명확하게 해야 합니다. 그래서 잘 만들어진 클래스는 다음 두 가지로 구성됩니다.

- 인스턴스 변수
- 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메서드

위와 같은 구성을 지켜야 하는 이유를 생각해 봅시다.
데이터 클래스는 일반적으로 인스턴스 변수를 조작하는 로직이 다른 클래스에 구현되어 있습니다. 따라서 연관성을 알아채기 어려워서 코드가 중복될 수 있고, 수정하다가 중복 코드 중 일부를 그대로 두는 일이 생길 수 있으며, 가독성을 낮추기도 합니다.

또한 인스턴스를 생성하더라도 인스턴스 변수들은 아직 유효하지 않은 상태이므로, 초기화를 따로 해 줘야 합니다.

> 즉, 데이터 클래스는 다른 클래스가 여러 가지를 준비해 줘야만 잘 작동하고, 혼자서는 아무것도 할 수 없는 미성숙한 클래스라는 것을 알 수 있습니다.

#### 2) 모든 클래스가 갖추어야 하는 자기 방어 임무

소프트웨어에서 메서드, 클래스, 모듈 등의 기본적인 단위들은 그 자체로 버그 없이, 언제나 안전하게 사용할 수 있는 품질을 갖추고 있어야 합니다.

자신의 몸은 자신이 지켜야 합니다. 클래스 스스로 자기 방어 임무를 수행할 수 있어야 소프트웨어의 품질을 높이는 데 도움이 됩니다.


---

## 성숙한 클래스로 성장시키는 설계 기법

#### 1) 생성자로 확실하게 정상적인 값 설정하기

클래스 인스턴스를 생성하는 시점에 확실하게 인스턴스 변수가 정상적인 값을 갖게 만들면 됩니다. 즉, 적절한 초기화 로직을 생성자에 구현하면 됩니다.

생성자에서 잘못된 값이 유입되지 못하게 유효성 검사를 정의합니다. 즉, 잘못된 값이라면 바로 예외를 발생시키도록 구현합니다.

```java
class Money {

	int amount;
	Currency currency;

	Money(int amount, Currency currency) {
		if (amount < 0) {
			throw new IllegalArgumentException("금액은 0 이상의 값을 지정해주세요");
		}
		...

		this.amount = amount;
		this.currency = currency;
	}
}
```

> 참고로 위 코드의 생성자처럼 처리 범위를 벗어나는 조건을 메서드 가장 앞 부분에서 확인하는 코드를 가드라고 부릅니다.

가드를 통해 잘못된 값을 가진 Money 인스턴스는 존재할 수 없게 됩니다. 항상 안전하고 정상적인 인스턴스만 존재하게 되는 것입니다.

#### 2) 계산 로직도 데이터를 가진 쪽에 구현하기

클래스가 스스로 일을 할 수 있게 만들어 클래스를 성숙하게 만들어야 합니다.

> 데이터와 데이터를 조작하는 로직이 분리되어 있는 구조를 응집도가 낮은 구조라고 합니다.

#### 3) 불변 변수로 만들어서 예상하지 못한 동작 막기

인스턴스 변수를 변경하는 코드는 이해하기 어렵습니다. 변수의 값이 계속해서 바뀌면, 값이 언제 변경되었는지, 지금 값은 무엇인지 계속 신경 써야 합니다. 비즈니스 요구 사항이 바뀌어서 코드를 수정하다가 의도하지 않은 값을 할당하는 예상치 못한 부수 효과가 쉽게 발생할 수 있습니다.

이를 막으려면 final 키워드를 사용하여 인스턴스 변수를 불변으로 만듭니다.

#### 4) 변경하고 싶다면 새로운 인스턴스 만들기

인스턴스 변수를 불변으로 만들면 아예 변경할 수 없게 되는 것 아닌가 라고 생각할 수 있습니다.
하지만 방법이 있습니다. 인스턴스 변수의 내용을 변경하는 것이 아니라, 변경된 값을 가진 새로운 인스턴스를 만들어서 사용하면 됩니다.

```java
class Money {
	...

	Money add(int other) {
		int added = amount + other;
		return new Money(added, currency);
	}
}
```

합산 금액을 값으로 갖는 Money 인스턴스를 생성하고 리턴하는 로직입니다. 이렇게 하면 불변을 유지하면서도 값을 변경할 수 있습니다.

#### 5) 메서드 매개변수와 지역 변수도 불변으로 만들기

매개변수 값이 중간에 바뀌면, 값의 변화를 추적하기 힘들기 때문에 버그를 발생시키기도 합니다. 기본적으로 매개변수는 변경하지 않는 것이 좋습니다. 마찬가지로 final 키워드를 사용합니다.

#### 6) 엉뚱한 값을 전달하지 않도록 하기

예상하지 못한 부수 효과라는 악마 이외에도 다른 악마가 아직 남아있습니다. 바로 잘못된 값의 전달입니다. 아래 예제를 봅시다.

```java
final int ticketCount = 3;  // 티켓의 수
money.add(ticketCount);
```

가격이 아니라 티켓 수를 더하게 되는데 이런 코드는 컴파일을 통해 처리할 수 없습니다. 따라서 엉뚱한 값이 전달되지 않도록 하려면 Money 자료형만 매개변수로 받을 수 있게 메서드를 변경하면 됩니다.

```java
class Money {

	Money add(final Money other) {
		final int added = amount + other.amount;
		return new Money(added, currency);
	}
}
```

매개변수의 자료형을 int에서 Money로 변경했습니다. 따라서 Money 이외의 자료형을 전달할 수 없습니다. 엉뚱한 값이 전달되는 상황 자체를 막을 수 있게 되었습니다.

#### 7) 의미 없는 메서드 추가하지 않기

시스템 사양에 필요한 메서드만 정의합니다.


---

## 악마 퇴치 효과 검토하기

지금까지의 객체 지향 설계의 기본을 적용한 Money 클래스르 보겠습니다.

```java
class Money {
	final int amount;
	final Currency currency;

	Money(final int amount, final Currency currency) {
		if (amount < 0) {
			throw new IllegalArgumentException("금액은 0 이상의 값을 지정해주세요");
		}
		if (currency == null) {
			throw new NullPointerException("통화 단위를 지정해 주세요");
		}
		this.amount = amount;
		this.currency = currency;
	}

	Money add(final Money other) {
		if (!currency.equals(other.currency)) {
			throw new IllegalArgumentException("통화 단위가 다릅니다");
		}

		final int added = amount + other.amount;
		return new Money(added, currency);
	}
}
```

위 구조를 통해 새로운 악마가 끼어들 틈도 없는 단단한 구조가 되었음을 알 수 있습니다.

| 퇴치된 악마        | 이유                                                                                   |
| ------------- | ------------------------------------------------------------------------------------ |
| 중복 코드         | 필요한 로직이 Money 클래스 내부에 모여 있으므로, 다른 클래스에 중복 코드가 작성될 일이 줄어듬                             |
| 수정 누락         | 중복 코드가 발생하지 않으므로, 수정 시 누락이 발생할 일이 줄어듬                                                |
| 가독성 저하        | 필요한 로직이 모두 Money 클래스 내부에 모여 있어, 디버깅 또는 기능 변경 시 관련된 로직을 찾으러<br>돌아다니지 않아도 되므로 가독성이 높아짐 |
| 쓰레기 객체        | 생성자에서 인스턴스 변수의 값을 확정하므로, 초기화되지 않은 상태가 있을 수 없음                                        |
| 잘못된 값         | 잘못된 값을 막을 가드를 설치하고, 인스턴스 변수에 final 수식자를 붙여 불변으로 만들었으므로,<br>잘못된 값이 들어오지 않음            |
| 생각하지 못한 부수 효과 | final 수식자를 붙여 불변 변수로 만들었으므로, 부수 효과로부터 안전함                                            |
| 값 전달 실수       | 매개변수를 Money 자료형으로 바꿨으므로, 다른 자료형의 값을 실수로 넣었을 때 컴파일 오류가 발생함                            |

클래스 설계란 인스턴스 변수가 잘못된 상태에 빠지지 않게 하기 위한 구조를 만드는 것이라고 해도 과언이 아닙니다.
관련된 로직이 흩어져 있는 구조를 응집도가 낮은 구조라고 합니다. 반면 위에서 소개한 Money 클래스처럼 로직이 한곳에 모여 있는 구조는 응집도가 높은 구조라고 합니다.

도한 데이터와 그 데이터를 조작하는 로직을 하나의 클래스로 묶고, 필요한 절차(즉 메서드)만 외부에 공개하는 것을 캡슐화라고 합니다.


---

## 프로그램 구조의 문제 해결에 도움을 주는 디자인 패턴

응집도가 높은 구조로 만들거나, 잘못된 상태로부터 프로그램을 방어하는 등 프로그램의 구조를 개선하는 설계 방법을 디자인 패턴이라고 부릅니다.

| 디자인 패턴       | 효과                               |
| ------------ | -------------------------------- |
| 완전 생성자       | 잘못된 상태로부터 보호함                    |
| 값 객체         | 특정한 값과 관련된 로직의 응집도를 높임           |
| 전략(strategy) | 조건 분기를 줄이고, 로직을 단순화함             |
| 정책(policy)   | 조건 분기를 단순화하고, 더 자유롭게 만듬          |
| 일급 컬렉션       | 값 객체의 일종으로 컬렉션과 관련된 로직의 응집도를 높임  |
| 스프라우트 클래스    | 기존 로직을 변경하지 않고, 안전하게 새로운 기능을 추가함 |

> 사실 이 장의 Money 클래스는 완전 생성자와 값 객체라는 두 가지 디자인 패턴을 적용한 것입니다.

#### 1) 완전 생성자

완전 생성자는 잘못된 상태로부터 클래스르 보호하기 위한 디자인 패턴입니다.
쓰레기 객체를 방지하려면, 인스턴스 변수를 모두 초기화해야만 객체를 생성할 수 있게, 매개변수를 가진 생성자를 만들면 됩니다. 그리고 생성자 내부에서는 가드를 사용해서 잘못된 값이 들어오지 않게 만듭니다.

#### 2) 값 객체

값 객체(value object)란 값을 클래스로 나타내는 디자인 패턴입니다. 애플리케이션 내부에서 다루는 값과 개념들은 모두 값 객체로 만들 수 있습니다.

| 애플리케이션           | 값 객체로 만드는 값과 개념                   |
| ---------------------- | --------------------------------------------------- |
| 온라인 쇼핑몰          | 세금 제외 금액, 세금 포함 금액, 상품명, 주문 수 ... |
| 태스크 관리 도구       | 태스크 이름, 태스크 설명, 코멘트 ...           |
| 건강 관리 애플리케이션 | 연령, 성별, 키, 몸무게 ...                |
| 게임                   | 최대 HP, 공격력, MP ...                |

값 객체와 완전 생성자는 얻을 수 있는 효과가 거의 비슷하므로, 일반적으로 함께 사용합니다. '값 객체 + 완전 생성자'는 객체 지향 설계에서 폭넓게 사용되는 기법이라고 할 수 있습니다.