## SQL을 직접 다룰 때 발생하는 문제점

#### 1) 반복, 반복 그리고 반복

데이터베이스와 객체 구조와는 다른 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장하거나 조회할 수는 없습니다. 따라서 개발자가 객체지향 애플리케이션과 데이버테이스 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 직접 해주어야 합니다.

문제는 객체를 데이터베이스에 CRUD 하려면 너무 많은 SQL과 JDBC API를 코드로 작성해야 한다는 점입니다. 그리고 테이블마다 이런 비슷한 일을 반복해야 하는데, 개발하려는 애플리케이션에서 사용하는 데이터베이스 테이블이 100개라면 무수히 많은 SQL을 작성해야 하고 이런 비슷한 일을 100번은 더 반복해야 합니다. 데이터 접근 계층(DAO)을 개발하는 일은 이렇듯 지루함과 반복의 연속입니다.

#### 2) SQL에 의존적인 개발

회원 객체를 관리하는 기능을 개발했다고 가정하자. 이때 갑자기 회원의 연락처도 함께 저장해달라는 요구사항이 추가되었습니다. 이런 경우 관련 코드를 전부 수정해야 합니다.

Member 나 Team 처럼 비즈니스 요구사항을 모델링한 객체를 엔티티라고 합니다. DAO를 열어서 어떤 SQL이 실행되고 어떤 객체들이 함께 조회되는지 일일이 확인해야 합니다. 이것은 진정한 의미의 계층 분할이 아닙니다.

애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점을 요약하면 다음과 같습니다.

- 진정한 의미의 계층 분할이 어렵다.
- 엔티티를 신뢰할 수 없다.
- SQL에 의존적인 개발을 피하기 어렵다.

#### 3) JPA와 문제 해결

JPA에서는 이러한 문제를 어떻게 하는지 간단히 보겠습니다. JPA에서 CRUD API를 간단하게 구현해줍니다. JPA는 SQL을 개발자 대신 작성해서 실행해주는 것 이상의 기능을 제공합니다.


---

## 패러다임의 불일치

애플리케이션은 발전하면서 그 내부의 복잡성도 점점 커집니다. 지속 가능한 애플리케이션을 개발하는 일은 끊임 없이 증가하는 복잡성과의 싸움입니다. 복잡성을 제어하지 못하면 결국 유지보수하기 어려운 애플리케이션이 됩니다.

객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공합니다. 그래서 현대의 복잡한 애플리케이션은 대부분 객체지향 언어로 개발합니다.

관계형 데이터베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구합니다. 그리고 객체지향에서 이야기하는 추상화, 상속, 다형성 같은 개념이 없습니다. 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다릅니다. 이것을 객체와 관계형 데이터베이스의 패러다임 불일치 문제라 합니다. 따라서 객체 구조를 테이블 구조에 저장하는 데는 한계가 있습니다.

지금부터 이러한 패러다임 불일치로 인해 발생하는 문제를 보고 JPA를 통한 해결책도 알아보겠습니다.

#### 1) 상속

아래 그림처럼 객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없습니다.

![jpa1](../static/jpa/jpa1.png)


그나마 데이터베이스 모델링에서 이야기하는 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 가장 유사한 형태로 테이블을 설계할 수 있습니다.

![jpa2](../static/jpa/jpa2.png)


JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해줍니다. 개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 됩니다.

#### 2) 연관관계

객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회합니다. 반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회합니다.

![jpa3](../static/jpa/jpa3.png)


조금 어려운 문제도 있는데, 객체는 참조가 있는 방향으로만 조회할 수 있습니다. 반면에 테이블은 외래 키 하나로 양방향으로 조회가 가능합니다.

이처럼 객체지향 모델링을 사용하면 객체를 테이블에 저장하거나 조회하기가 쉽지 않습니다. 객체 모델은 외래 키가 필요 없고, 단지 참조만 있으면 됩니다. 반면에 테이블은 참조가 필요 없고 외래 키만 있으면 됩니다. 결국 개발자가 중간에서 변환 역할을 해야 합니다.

JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해줍니다. JPA는 team의 참조를 외래 키로 변환해서 적절한 insert sql 을 데이터베이스에 전달합니다. 객체를 조회할 때 외래 키를 참조로 변환하는 일도 JPArk cjflgownqslek.

#### 3) 객체 그래프 탐색

객체 연관관계가 아래 그림과 같다고 생각해봅시다.

![jpa4](../static/jpa/jpa4.png)


SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해집니다. 결국 어디까지 객체 그래프 탐색이 가능한지 알아보려면 데이터 접근 계층인 DAO를 열어서 SQL을 직접 확인해야 합니다.

JPA를 사용하면 객체 그래프를 마음껏 탐색할 수 있습니다. JPA는 연관된 객체를 사용하는 시점에 적절한 select sql을 실행합니다. 따라서 JPA를 사용하면 연관된 객체를 신뢰하고 마음껏 조회할 수 있습니다. 이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 <span style="color:#ff0000">지연 로딩</span>이라고 합니다.

#### 4) 비교

데이터베이스는 기본 키의 값으로 각 로우를 구분합니다. 반면에 객체는 동일성과 동등성 비교라는 두 가지 비교 방법이 있습니다.

- 동일성 비교는 == 비교입니다. 객체 인스턴스의 주소 값을 비교합니다.
- 동등성 비교는 equals() 메서드를 사용해서 객체 내부의 값을 비교합니다.

JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장합니다. 그러므로 다음 코드에서 member1과 member2는 동일성 비교에 성공합니다.

```java
String memberId = "100";
Memeber memeber1 = jpa.find(Member.class, memberId);
Memeber memeber2 = jpa.find(Member.class, memberId);

member1 == member2. // 같다.
```


---

## JPA란 무엇인가

JPA는 자바 진영의 ORM 기술 표준입니다. JPA는 아래 그림처럼 애플리케이션과 JDBC 사이에서 동작합니다.

![jpa5](../static/jpa/jpa5.png)


그렇다면 ORM 이란 무엇일까. ORM(Object-Relational Mapping) 은 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻입니다. ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해줍니다.

ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐만 아니라 앞서 이야기한 다양한 패러다임의 불일치 문제들도 해결해줍니다. 따라서 객체 측면에서는 정교한 객체 모델링을 할 수 있고 관계형 데이터베이스는 데이터베이스에 맞도록 모델링하면 됩니다. 그리고 둘을 어떻게 매핑해야 하는지 매핑 방법만 ORM 프레임워크에게 알려주면 됩니다.

#### 1) JPA 소개

아래 그림을 보면 JPA는 자바 ORM 기술에 대한 API 표준 명세입니다. 이 중에 하이버네이트 구현체가 가장 대중적입니다.

![jpa6](../static/jpa/jpa6.png)

#### 2) 왜 JPA를 사용해야 하는가

- 생산성
	- 지루하고 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 됩니다.
	- 이런 기능들을 사용하면 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있습니다.

- 유지보수
	- SQL을 직접 다루면 엔티티에 필드를 하나만 추가해도 관련된 등록, 수정, 조회 SQL과 결과를 매핑하기 위한 코드를 모두 변경해야 합니다.

- 패러다임의 불일치 해결
	- JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결해줍니다.

- 성능
	- JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공합니다.

- 데이터 접근 추상화와 벤더 독립성
	- 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 합니다.

![jpa7](../static/jpa/jpa7.png)

- 표준
	- 다른 구현 기술로 손쉽게 변경할 수 있습니다.

