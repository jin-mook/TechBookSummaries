
객체는 참조(주소)를 사용해서 관계를 맺고 테이블은 외래 키를 사용해서 관계를 맺습니다. 이 둘은 완전히 다른 특징을 가집니다. 객체 관계 매핑에서 가장 어려운 부분이 바로 객체 연관관계와 테이블 연관관계를 매핑하는 일입니다.

- 방향(direction)
	- 단방향, 양방향이 있습니다.
	- 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향입니다.

- 다중성(multiplicity)
	- 다대일, 일대다, 일대일, 다대다 다중성이 있습니다.

- 연관관계의 주인(owner)
	- 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 합니다.

## 단방향 연관관계

지금부터 회원과 팀의 관계를 통해 다대일 단방향 관계를 알아보겠습니다.

- 회원과 팀이 있다.
- 회원은 하나의 팀에만 소속될 수 있다.
- 회원과 팀은 다대일 관계다.

![jpa20](../static/jpa/jpa20.png)


회원 객체와 팀 객체는 단방향 관계입니다. 회원은 Member.team 필드를 통해서 팀을 알 수 있지만 반대로 팀은 회원을 알 수 없습니다. 회원 테이블과 팀 테이블은 양방향 관계입니다.

연관된 데이터를 조회할 때 객체는 참조를 사용하지만 테이블은 조인을 사용합니다. 객체는 참조를 사용해서 연관관계를 탐색할 수 있는데 이것을 객체 그래프 탐색이라고 합니다.

```java
@Entity
public class Member {
	@Id
	@Column(name = "MEMBER_ID")
	private String id;

	private String username;

	// 연관관계 매핑
	@ManyToOne
	@JoinColumn(name="TEAM_ID")
	private Team team;
}

@Entity
public class Team {
	@Id
	@Column(name = "TEAM_ID")
	private String id;

	private String name;
}
```

Member.team 과 MEMBER.TEAM_ID 를 매핑하는 것이 연관관계 매핑입니다.

- @ManyToOne
	- 다대일 관계라는 매핑 정보입니다
	- 연관관계 매핑할 때 이렇게 다중성을 나타내는 어노테이션을 필수로 사용해야 합니다.

![jpa21](../static/jpa/jpa21.png)


- @JoinColumn(name="TEAM_ID")
	- 조인 컬럼은 외래 키를 매핑할 때 사용합니다.
	- name 속성에는 매핑할 외래 키 이름을 지정합니다.

![jpa22](../static/jpa/jpa22.png)


---

## 연관관계 사용

JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 합니다.

```java
public void testSave() {
	Team team1 = new Team("team1", "팀1");
	em.persist(team1);

	Memeber member1 = new Member("member1", "회원1");
	member1.setTeam(team1);
	em.persist(member1);

	Memeber member2 = new Member("member2", "회원2");
	member2.setTeam(team1);
	em.persist(member2);
}
```


연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지다.

- 객체 그래프 탐색(객체 연관관계를 사용한 조회)
- 객체지향 쿼리 사용(JPQL)

객체 그래프 탐색이란 member.getTeam() 을 사용해서 member와 연관된 team 엔티티를 조회할 수 있습니다.
JPQL은 객체를 대상으로 하고 SQL보다 간결합니다.

연관관계 제거 방법은 연관관계를 null로 설정하는 것입니다. member1.setTeam(null)

연관된 엔티티를 삭제하려면 기존에 잇던 연관관계를 먼저 제거하고 삭제해야 합니다. 그렇지 않으면 외래 키 제약조건으로 인해, 데이터베이스에서 오류가 발생합니다.

```java
member1.setTeam(null)
member2.setTeam(null)
em.remove(team);
```


---

## 양방향 연관관계

지금까지 회원에서 팀으로만 접근하는 다대일 단방향 매핑을 알아보았습니다. 이번에는 반대 방향인 팀에서 회원으로 접근하는 관계를 추가해보겠습니다.

![jpa23](../static/jpa/jpa23.png)

일대다 관계는 여러 건과 연관관계를 맺을 수 있으므로 컬렉션을 사용해야 합니다. Team.members를 List 컬렉션으로 추가합니다.

```java
@Entity
public class Team {
	@Id
	@Column(name = "TEAM_ID")
	private String id;

	private String name;

	@OneToMany(mappedBy = "team")
	private List<Member> members = new ArrayList<>();
}
```

팀과 회원은 일대다 관계입니다. 따라서 팀 엔티티에 컬렉션인 List\<Member> members 를 추가했습니다. 그리고 일대다 관계를 매핑하기 위해 @OneToMany 매핑 정보를 사용했습니다. mappedBy 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 됩니다. 반대쪽 매핑이 Memeber.team 이므로 team 을 값으로 주었습니다.


---

## 연관관계의 주인

@OneToMany는 직관적으로 이해가 될 것입니다. 문제는 mappedBy 속성입니다. 엄밀히 이야기하면 객체에는 양방향 연관관계라는 것이 없습니다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐입니다. 반면에 데이터베이스 테이블은 앞서 설명했듯이 외래 키 하나로 양쪽이 서로 조인할 수 있습니다.

다시 강조하지만 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리합니다. 엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로 이 참조로 외래키를 관리하면 됩니다. 그런데 엔티티를 양방향으로 매핑하면 회원 -> 팀, 팀 -> 회원 두 곳에서 서로를 참조합니다. 따라서 객체의 연관관계를 관리하는 포인트는 2곳으로 늘어납니다.

엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나입니다. 따라서 둘 사이에 차이가 발생합니다. 이런 차이로 인해 JPA 에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 하는데 이것을 연관관계의 주인이라고 합니다.

#### 1) 양방향 매핑의 규칙: 연관관계의 주인

양방향 연관관계 매핑 시 지켜야 할 규칙이 있는데 두 연관관계 중 하나를 연관관계의 주인으로 정해야 합니다. 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리할 수 있습니다. 반면에 주인이 아닌 쪽은 읽기만 할 수 있습니다. 어떤 연관관계를 주인으로 정할지는 mappedBy 속성을 사용하면 됩니다.

- 주인은 mappedBy 속성을 사용하지 않습니다.
- 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야 합니다.

연관관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것입니다.

#### 2) 연관관계의 주인은 외래 키가 있는 곳

연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 합니다. 여기서는 회원 테이블이 외래 키를 가지고 있으므로 Member.team 이 주인이 됩니다. 주인이 아닌 Team.members에는 mappedBy="team" 속성을 사용해서 주인이 아님을 설정합니다.

![jpa24](../static/jpa/jpa24.png)


정리하면 연관관계의 주인만 데이터베이스 연관관계와 매핑되고 외래 키를 관리할 수 있습니다. 주인이 아닌 반대편은 읽기만 가능하고 외래키를 변경하지는 못합니다.


---

## 양방향 연관관계 저장

위에서 회원에 팀을 매핑하고 저장하는 코드와 완전히 동일합니다. team1.getMembers().add(member1) 과 같은 코드가 필요할 수 있다고 느낄 수 있지만 team은 연관관계의 주인이 아니기 때문에 외래 키에 영향을 주지 않습니다.
따라서 위 코드는 데이터베이스에 저장할 때 무시됩니다.


---

## 양방향 연관관계의 주의점

양방향 연관관계를 설정하고 가장 흔히 하는 실수는 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것입니다. 즉, 연관관계의 주인만이 외래 키의 값을 변경할 수 있습니다.

#### 1) 순수한 객체까지 고려한 양방향 연관관계

사실은 객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전합니다. 양쪽 방향 모두 값을 입력하지 않으면 JPA를 사용하지 않는 순수한 객체 상태에서 심각한 문제가 발생할 수 있습니다. 결론적으로 객체의 양방향 연관관계는 모두 관계를 맺어주는 것이 좋습니다.

#### 2) 연관관계 편의 메소드

양방향 연관관계는 결국 양쪽 다 신경써야 합니다.

```java
member.setTeam(team);
team.getMembers().add(member);
```

양방향 관계에서 두 코드는 하나인 것처럼 사용하는 것이 안전합니다. 따라서 Member 클래스의 setTeam 메서드를 수정해보겠습니다.

```java
public class Member {
	...

	private Team team;

	public void setTeam(Team team) {
		this.team = team;
		team.getMembers().add(this);
	}
}
```

위 코드를 통해 setTeam() 메서드 하나로 양방향 관계를 모두 설정하도록 변경했습니다. 이렇게 한 번에 양방향 관계를 설정하는 메소드를 연관관계 편의 메소드라 합니다.

#### 3) 연관관계 편의 메소드 작성 시 주의사항

사실 위 메서드에는 버그가 있습니다.

```java
member1.setTeam(teamA);
member1.setTeam(teamB);
Member findMember = teamA.getMember();  // member1 이 여전히 조회됩니다.
```

![jpa25](../static/jpa/jpa25.png)


위 코드에서 teamB로 변경할 때 teamA -> member1 관계를 제거하지 않았습니다. 연관관계를 변경할 때는 기존 팀이 있으면 기존 팀과 회원의 연관관계를 삭제하는 코드를 추가해야 합니다. 따라서 기존 코드를 수정해보겠습니다.

```java
public void setTeam(Team team) {

	// 기존 팀과 관계를 제거
	if (this.team != null) {
		this.team.getMembers().remove(this);
	}
	this.team = team;
	team.getMembers().add(this);
}
```

위 코드는 객체에서 서로 다른 단방향 연관관계 2개를 양방향인 것처럼 보이게 하려고 얼마나 많은 고민과 수고가 필요한지 보여줍니다. 반면에 관계형 데이터베이스는 외래 키 하나로 문제를 단순하게 해결합니다. 정리하자면 객체에서 양방향 연관관계를 사용하려면 로직을 견고하게 작성해야 합니다.


---

## 정리

단방향 매핑과 비교해서 양방향 매핑은 복잡합니다. 연관관계의 주인도 정해야 하고, 두 개의 단방향 연관관계를 양방향으로 만들기 위해 로직도 잘 관리해야 합니다. 중요한 사실은 연관관계가 하나인 단방향 매핑은 언제나 연관관계의 주인이라는 점입니다.

양방향은 여기에 주인이 아닌 연관관계를 하나 추가했을 뿐입니다. 결국 단방향과 비교해서 양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것뿐입니다.

- 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료되었다.
- 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가된다.
- 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야 한다.

> 양방향 매핑은 복잡합니다. 비즈니스 로직의 필요에 따라 다르겠지만 우선 단방향 매핑을 사용하고 반대 방향으로 객체 그래프 탐색 기능이 필요할 때 양방향을 사용하도록 코드를 추가해도 됩니다.
