
엔티티의 연관관계를 매핑할 때는 다음 3가지를 고려해야 합니다.

- 다중성
- 단방향, 양방향
- 연관관계의 주인

먼저 연관관계가 있는 두 엔티티가 일대일 관계인지 일대다 관계인지 다중성을 고려해야 합니다. 다음으로 두 엔티티 중 한쪽만 참조하는 단방향 관계인지 서로 참조하는 양방향 관계인지 고려해야 합니다. 마지막으로 양방향 관계면 연관관계의 주인을 정해야 합니다.

객체 관계에서 한 쪽만 참조하는 것을 단방향 관계라 하고, 양쪽이 서로 참조하는 것을 양방향 관계라고 합니다.

JPA는 두 객체 연관관계 중 하나를 정해서 데이터베이스 외래 키를 관리하는데 이것을 연관관계의 주인이라 합니다. 주인이 아닌 방향은 외래 키를 변경할 수 없고 읽기만 가능합니다.


## 다대일

외래 키는 항상 다쪽에 있습니다. 따라서 객체 양방향 관계에서 연관관계의 주인은 항상 다쪽입니다.

![jpa26](../static/jpa/jpa26.png)

#### 1) 다대일 양방향

양방향은 외래 키가 있는 쪽이 연관관계의 주인입니다.
- 일대다와 다대일 연관관계는 항상 다(N)에 외래 키가 있습니다.
- 여기서는 다쪽인 Member 테이블이 외래 키를 가지고 있으므로 Member.team이 연관관계의 주인입니다.
- Team.members는 조회를 위한 JPQL이나 객체 그래프를 탐색할 때 사용합니다.

양방향 연관관계는 항상 서로를 참조해야 합니다.
- 어느 한 쪽만 참조하면 양방향 연관관계가 성립하지 않습니다.
- 항상 서로 참조하게 하려면 연관관계 편의 메소드를 작성하는 것이 좋습니다.


---

## 일대다

일대다 관계는 다대일 관계의 반대 방향입니다. 일대다 관계는 엔티티를 하나 이상 참조할 수 있으므로 자바 컬렉션 중에 하나를 사용해야 합니다.

#### 1) 일대다 단방향

하나의 팀은 여러 회원을 참조할 수 있는데 이런 관계를 일대다 관계라 합니다.

![jpa27](../static/jpa/jpa27.png)

일대다 단방향 관계는 약간 특이한데 위 그림을 보면 팀 엔티티의 Team.members로 회원 테이블의 TEAM_ID 외래 키를 관리합니다.

일대다 단방향 매핑의 단점은 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점입니다. 본인 테이블에 외래 키가 있으면 엔티티의 저장과 연관관계 처리를 INSERT SQL 한 번으로 끝낼 수 있지만, 다른 테이블에 외래 키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 설정해야 합니다.

따라서 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하는것이 좋습니다.

#### 2) 일대다 양방향

일대다 양방향 매핑은 존재하지 않습니다. 대신 다대일 양방향 매핑을 사용해야 합니다. 더 정확히 말하자면 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없습니다.

> 될 수 있으면 다대일 양방향 매핑을 사용하는것이 좋습니다.


---

## 일대일

일대일 관계는 양쪽이 서로 하나의 관계만 가집니다. 예를 들어 회원은 하나의 사물함만 사용하고 사물함도 하나의 회원에 의해서만 사용됩니다. 일대일 관계는 다음과 같은 특징이 있습니다.

- 일대일 관계는 그 반대도 일대일 관계다.
- 테이블 관계에서 일대다, 다대일은 항상 다(N)쪽이 외래 키를 가진다. 반면에 일대일 관계는 주 테이블이나 대상 테이블 둘 중 어느 곳이나 외래 키를 가질 수 있다.

일대일 관계는 주 테이블이나 대상 테이블 중에 누가 외래 키를 가질지 선택해야 합니다.

#### 1) 주 테이블에 외래 키

일대일 관계를 구성할 때 객체지향 개발자들은 주 테이블에 외래 키가 있는 것을 선호합니다. JPA도 주 테이블에 외래 키가 있으면 좀 더 편리하게 매핑할 수 있습니다.

![jpa28](../static/jpa/jpa28.png)

아래는 양방향 관계로 매핑한 예제 코드입니다.

```java
@Entity
public class Member {
	@Id @GeneratedValue
	@Column(name = "MEMBER_ID")
	private Long id;

	private String username;

	@OneToOne
	@JoinColumn(name = "LOCKER_ID")
	private Locker locker;
	...
}

@Entity
public class Locker {
	@Id @GeneratedValue
	@Column(name = "LOCKER_ID")
	private Long id;

	private String name;

	@OneToOne(mappedBy = "locker")
	private Member member;
	...
}
```

양방향이므로 연관관계의 주인을 정해야 합니다. Member 테이블이 외래 키를 가지고 있으므로 Member 엔티티에 있는 Member.locker가 연관관계의 주인입니다. 따라서 반대 매핑인 사물함의 Locker.member는 mappedBy를 선언해서 연관관계의 주인이 아니라고 설정했습니다.

#### 2) 대상 테이블에 외래 키

일대일 관계 중 대상 테이블에 외래 키가 있는 단방향 관계는 JPA에서 지원하지 않습니다. 그리고 이런 모양으로 매핑할 수 있는 방법도 없습니다. 이때는 단방향 관계를 Locker에서 Member 방향으로 수정하거나, 양방향 관계로 만들고 Locker를 연관관계의 주인으로 설정해야 합니다.

![jpa29](../static/jpa/jpa29.png)


```java
@Entity
public class Member {
	@Id @GeneratedValue
	@Column(name = "MEMBER_ID")
	private Long id;

	private String username;

	@OneToOne(mappedBy = "member")
	private Locker locker;
	...
}

@Entity
public class Locker {
	@Id @GeneratedValue
	@Column(name = "LOCKER_ID")
	private Long id;

	private String name;

	@OneToOne
	@JoinColumn(name = "MEMBER_ID")
	private Member member;
	...
}
```


일대일 매핑에서 대상 테이블에 외래 키를 두고 싶으면 이렇게 양방향으로 매핑합니다. 주 엔티티인 Member 엔티티 대신에 대상 엔티티의 Locker를 연관고나계의 주인으로 만들어서 LOCKER 테이블의 외래 키를 관리하도록 했습니다.


---

## 다대다

다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용합니다. 테이블의 경우 중간에 연결 테이블을 추가해야 합니다. 그런데 객체는 테이블과 다르게 객체 2개로 다대다 관계를 만들 수 있습니다. 예를 들어 회원 객체는 컬렉션을 사용해서 상품들을 참조하면 되고 반대로 상품들도 컬렉션을 사용해서 회원들을 참조하면 됩니다.

![jpa30](../static/jpa/jpa30.png)

![jpa31](../static/jpa/jpa31.png)


다대다 연관관계에서 @ManyToMany를 사용하면 연결 테이블을 자동으로 처리해주므로 도메인 모델이 단순해지고 여러 가지로 편리합니다. 하지만 이 매핑을 실무에서 사용하기에는 한계가 있습니다. 예를 들어 회원이 상품을 주문하면 연결 테이블에 단순히 주문한 회원 아이디와 상품 아이디만 담고 끝나지 않습니다. 보통은 연결 테이블에 주문 수량 컬럼이나 주문한 날짜 같은 컬럼이 더 필요합니다.

아래는 회원과 상품의 중간 테이블인 회원상품 엔티티 설정 코드 예시입니다.

```java
@Entity
@IdClass(MemberProductId.class)
public class MemberProduct {

	@Id
	@ManyToOne
	@JoinColumn(name = "MEMBER_ID")
	private Member member;  // MemberProductId.member 와 연결

	@Id
	@ManyToOne
	@JoinColumn(name = "PRODUCT_ID")
	private Product product;   // MemberProductId.product 와 연결

	private int orderAmount;
	...
}

public class MemberProductId implements Serializable {

	private String member;  // MemberProduct.member 와 연결
	private String product;   // MemberProduct.product 와 연결

	@Override
	public boolean equals(Object o) {...}

	@Override
	public int hashCode() {...}
}
```

위 회원상품 엔티티를 보면 기본 키를 매핑하는 @Id와 외래 키를 매핑하는 @JoinColumn을 동시에 사용해서 기본 키 + 외래 키를 한번에 매핑했습니다. 그리고 @IdClass를 사용해서 복합 기본 키를 매핑했습니다.

#### 복합 기본 키
회원상품 엔티티는 기본 키가 MEMBER_ID와 PRODUCT_ID로 이루어진 복합 기본키다. JPA에서 복합 키를 사용하려면 별도의 식별자 클래스를 만들어야 합니다. 그리고 엔티티에 @IdClass를 사용해서 식별자 클래스를 지정하면 됩니다. 복합 키를 위한 식별자 클래스는 다음과 같은 특징이 있습니다.

- 복합 키는 별도의 식별자 클래스로 만들어야 합니다.
- Serializable을 구현해야 합니다.
- equals와 hashCode 메소드를 구현해야 합니다.
- 기본 생성자가 있어야 합니다.
- 식별자 클래스는 public이어야 합니다.
- @IdClass를 사용하는 방법 외에 @EmbeddedId를 사용하는 방법도 있습니다.

#### 식별 관계
회원상품은 회원과 상품의 기본 키를 받아서 자신의 기본 키로 사용합니다. 이렇게 부모 테이블의 기본 키를 받아서 자신의 기본 키 + 외래 키로 사용하는 것을 데이터베이스 용어로 식별 관계라 합니다.

종합해보면 회원상품은 회원의 기본 키를 받아서 자신의 기본 키로 사용함과 동시에 회원과의 관계를 위한 외래 키로 사용합니다. 그리고 상품의 기본 키도 받아서 자신의 기본 키로 사용함과 동시에 상품과의 관계를 위한 외래 키로 사용합니다. 또한 MemberProductId 식별자 클래스로 두 기본 키를 묶어서 복합 기본 키로 사용합니다.

복합 키를 사용하는 방법은 복잡합니다. 단순히 컬럼 하나만 기본 키로 사용하는 것과 비교해서 복합 키를 사용하면 ORM 매핑에서 처리할 일이 상당히 많아집니다. 따라서 다음으로 복합 키를 사용하지 않고 간단히 다대다 관계를 구성하는 방법을 살펴보겠습니다.

#### 다대다: 새로운 기본 키 사용
추천하는 기본 키 생성 전략은 데이터베이스에서 자동으로 생성해주는 대리 키를 Long 값으로 사용하는 것입니다. 이것의 장점은 간편하고 거의 영구히 쓸 수 있으며 비즈니스에 의존하지 않습니다. 그리고 ORM 매핑 시에 복합 키를 만들지 않아도 되므로 간단히 매핑을 완성할 수 있습니다.

![jpa32](../static/jpa/jpa32.png)

> 식별자 클래스를 사용하지 않아서 코드가 훨씬 단순해질 수 있습니다. 이처럼 새로운 기본 키를 사용해서 다대다 관계를 풀어내는 것도 좋은 방법입니다.

#### 다대다 연관관계 정리

다대다 관계를 일대다 다대일 관계로 풀어내기 위해 연결 테이블을 만들 때 식별자를 어떻게 구성할지 선택해야 합니다.

- 식별 관계 : 받아온 식별자를 기본 키 + 외래 키로 사용합니다.
- 비식별 관계 : 받아온 식별자는 외래 키로만 사용하고 새로운 식별자를 추가합니다.

데이터베이스 설계에서는 1번처럼 부모 테이블의 기본 키를 받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 것을 식별 관계라 하고, 2번처럼 단순히 외래 키로만 사용하는 것을 비식별 관계라고 합니다.

객체 입장에서 보면 2번처럼 비식별 관계를 사용하는 것이 복합 키를 위한 식별자 클래스를 만들지 않아도 되므로 단순하고 편리하게 ORM 매핑을 할 수 있습니다. 이런 이유로 식별 관계보다는 비식별 관계를 추천합니다.
