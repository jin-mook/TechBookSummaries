JPA를 사용하는 데 가장 중요한 일은 엔티티와 테이블을 정확히 매핑하는 것입니다. 따라서 매핑 어노테이션을 숙지하고 사용해야 합니다. JPA는 다양한 매핑 어노테이션을 지원하는데 크게 4가지로 분류할 수 있습니다.

- 객체와 테이블 매핑 : @Entity, @Table
- 기본 키 매핑 : @Id
- 필드와 컬럼 매핑 : @Column
- 연관관계 매핑 : @ManyToOne, @JoinColumn

## @Entity

JPA를 사용해서 테이브로가 매핑할 클래스는 @Entity 어노테이션을 필수로 붙여야 합니다. @Entity가 붙은 클래스는 JPA가 관리하는 것으로, 엔티티라 부릅니다.

- 기본 생성자는 필수입니다.
- final 클래스, enum, interface, inner 클래스에는 사용할 수 없습니다.
- 저장할 필드에 final을 사용하면 안 됩니다.


---

## @Table

@Table은 엔티티와 매핑할 테이블을 지정합니다. 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용합니다.

![jpa17](../static/jpa/jpa17.png)


---

## 다양한 매핑 사용

1. 자바의 enum을 사용할 수 있습니다. enum을 사용하려면 @Enumerated 어노테이션으로 매핑해야 합니다.
2. createdDate, lastModifiedDate 처럼 자바의 날짜 타입은 @Temporal을 사용해서 매핑할 수 있습니다.
3. 설명하는 필드는 길이 제한이 없습니다. 따라서 varchar 타입 대신 CLOB 타입으로 지정해야 하는데 @Lob을 사용하면 해당 타입을 매핑할 수 있습니다.


---

## 데이터베이스 스키마 자동 생성

JPA를 통해 애플리케이션 실행 시점에 데이터베이스 테이블을 자동으로 생성하게 할 수 있습니다. 하지만 스키마 자동 생성 기능이 만든 DDL은 운영 환경에서 사용할 만큼 완벽하지는 않으므로 개발 환경에서 사용하거나 매핑을 어떻게 해야 하는지 참고하는 정도로만 사용하는 것이 좋습니다.


---

## DDL 생성 기능

컬럼을 설정할 때 @Column 의 length 와 nullable 속성을 포함해서 설정할 수 있습니다. 이런 기능들은 단지 DDL을 자동으로 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않습니다. 따라서 스키마 자동 생성 기능을 사용하지 않고 직접 DDL을 만든다면 사용할 이유가 없습니다. 그래도 이 기능을 사용하면 애플리케이션 개발자가 엔티티만 보고도 손쉽게 다양한 제약 조건을 파악할 수 있는 장점이 있습니다.


---

## 기본 키 매핑

JPA가 제공하는 데이터베이스 기본 키 생성 전략은 다음과 같습니다.

- 직접 할당 : 기본 키를 애플리케이션에서 직접 할당합니다.
- 자동 생성 : 대리 키 사용 방식
	- IDENTITY : 기본 키 생성을 데이터베이스에 위임합니다.
	- SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키를 할당합니다.
	- TABLE : 키 생성 테이블을 사용합니다.

TABLE 전략은 키 생성용 테이블을 하나 만들어두고 마치 시퀀스처럼 사용하는 방법입니다. 이 전략은 테이블을 활용하므로 모든 데이터베이스에서 사용할 수 있습니다.

참고로 SEQUENCE 전략은 em.persist()를 호출할 때 먼저 데이터베이스 시퀀스를 사용해서 식별자를 조회합니다. 그리고 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장합니다. 이후 트랜잭션을 커밋해서 플러시가 일어나면 엔티티를 데이터베이스에 저장합니다.

반대로 이전에 설명했던 IDENTITY 전략은 먼저 엔티티를 데이터베이스에 저장한 후에 식별자를 조회해서 엔티티의 식별자에 할당합니다.

#### @SequenceGenerator

```java
@Entity
@SequenceGenerator(
	name = "BOARD_SEQ_GENERATOR",
	sequenceName = "BOARD_SEQ", // 매핑할 데이터베이스 시퀀스 이름
	initialValue = 1, allocationSize = 1
)
public class Board {
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE,
					generator = "BOARD_SEQ_GENERATOR")
	private Long id;
	...
}
```


@SequenceGenerator 의 속성은 아래와 같습니다.

| 속성            | 기능                                           | 기본값             |
| --------------- | ---------------------------------------------------------------------- | ------------------ |
| name            | 식별자 생성기 이름                                   | 필수               |
| sequenceName    | 데이터베이스에 등록되어 있는 시퀀스 이름                       | hibernate_sequence |
| initialValue    | DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 때 처음 시작하는 수를 지정 | 1                  |
| allocationSize  | 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨)              | 50                 |
| catalog, schema | 데이터베이스 catalog, schema 이름                    |                    |

SEQUENCE 전략은 데이터베이스 시퀀스를 통해 식별자를조회하는 추가 작업이 필요합니다. 따라서 데이터베이스와 2번 통신합니다.

1. 식별자를 구하려고 데이터베이스 시퀀스를 조회합니다.
	- SELECT BOARD_SEQ.NEXTVAL FROM DUAL
2. 조회한 시퀀스를 기본 키 값으로 사용해 데이터베이스에 저장합니다.

JPA는 시퀀스에 접근하는 횟수를 줄이기 위해 @SequenceGenerator.allocationSize를 사용합니다. 간단히 설명하자면 여기에 설정한 값만큼 한 번에 시퀀스 값을 증가시키고 나서 그만큼 메모리에 시퀀스 값을 할당합니다. 예를 들어 allocationSize 값이 50이면 시퀀스를 한 번에 50 증가시킨 다음에 1 ~ 50 까지 메모리에서 식별자를 할당합니다. 그리고 51이 되면 시퀀스 값을 100으로 증가시킨 다음 51 ~ 100 까지 메모리에서 식별자를 할당합니다.

이 최적화 방법은 시퀀스 값을 선점하므로 여러 JVM이 동시에 동작해도 기본 키 값이 충돌하지 않는다는 장점이 있습니다. 이러한 설정을 적용하려면 hibernate.id.new_generator_mappings 속성을 true로 설정해야 합니다.

참고로 @SequenceGenerator는 다음과 같이 @GeneratedValue 옆에 사용해도 됩니다.

```java
@Entity
public class Board {
	@Id
	@GeneratedValue(...)
	@SequenceGenerator(...)
	private Long id;
}
```


TABLE 전략은 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스를 흉내내는 전략입니다. 이 전략은 테이블을 사용하므로 모든 데이터베이스에 적용할 수 있습니다.

TABLE 전략은 시퀀스 대신에 테이블을 사용한다는 것만 제외하면 SEQUENCE 전략과 내부 동작방식이 같습니다.


AUTO 전략의 장점은 데이터베이스를 변경해도 코드를 수정할 필요가 없다는 것입니다. 특히 키 생성 전략이 아직 확정되지 않은 개발 초기 단계나 프로토타입 개발 시 편리하게 사용할 수 있습니다.

#### 기본 키 매핑 정리

- 직접 할당 : em.persist()를 호출하기 전에 애플리케이션에서 직접 식별자 값을 할당해야 합니다. 만약 식별자 값이 없으면 예외가 발생합니다.
- SEQUENCE : 데이터베이스 시퀀스에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장합니다.
- TABLE : 데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장합니다.
- IDENTITY : 데이터베이스에 엔티티를 저장해서 식별자 값을 획득한 후 영속성 컨텍스트에 저장합니다.


---

## 필드와 컬럼 매핑: 레퍼런스

![jpa18](../static/jpa/jpa18.png)


