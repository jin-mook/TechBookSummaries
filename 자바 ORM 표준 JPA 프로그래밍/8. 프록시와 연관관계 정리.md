
#### 프록시와 즉시로딩, 지연로딩
객체는 객체 그래프로 연관된 객체들을 탐색합니다. 그런데 객체가 데이터베이스에 저장되어 있으므로 연관된 객체를 마음껏 탐색하기는 어렵습니다.JPA 구현체들은 이 문제를 해결하려고 프록시라는 기술을 사용합니다. 프록시를 사용하면 연관된 객체를 처음부터 데이터베이스에서 조회하는 것이 아니라, 실제 사용하는 시점에 데이터베이스에서 조회할 수 있습니다. 하지만, 자주 함께 사용하는 객체들은 조인을 사용해서 함께 조회하는 것이 효과적입니다.

#### 영속성 전이와 고아 객체
JPA는 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 영속성 전이와 고아 객체 제거라는 편리한 기능을 제공합니다.


---

## 프록시

JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 <span style="color:#ff0000">지연 로딩</span>이라고 합니다. 그런데 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라고 합니다.

#### 1) 프록시 기초

Memeber member = em.getReference(Member.class, "member1");

위 메서드를 호출할 때 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않습니다. 대신에 데이터베이스 접근을 위임한 프록시 객체를 반환합니다.

프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같습니다. 따라서 사용하는 입장에서는 이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됩니다.

프록시 객체는 member.getName() 처럼 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라 합니다.

#### 프록시의 특징
- 프록시 객체는 처음 사용할 때 한 번만 초기화됩니다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아닙니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있습니다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 합니다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환합니다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능합니다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생합니다.

참고로 준영속 상태인 em.close() 메소드로 영속성 컨텍스트를 종료하게 되면, 이후 memeber.getName()을 호출하면 프록시를 초기화해야 하는데 영속성 컨텍스트가 없으므로 실제 엔티티를 조회할 수 없습니다. 따라서 예외가 발생합니다.

#### 2) 프록시와 식별자

엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관합니다.

```java
Team team = em.getReference(Team.class, "team1");
team.getId();  // 초기화 되지 않음
```

프록시 객체는 식별자 값을 가지고 있으므로 식별자 값을 조회하는 team.getId()를 호출해도 프록시를 초기화하지 않습니다.
프록시는 다음 코드처럼 연관관계를 설정할 때 유용하게 사용할 수 있습니다.

```java
Member member = em.find(Member.class, "member1");
Team team = em.getReference(Team.class, "team1");  // SQL을 실행하지 않음
member.setTeam(team);
```

연관관계를 설정할 때는 식별자 값만 사용하므로 프록시를 사용하면 데이터베이스 접근 횟수를 줄일 수 있습니다.


---

## 즉시 로딩과 지연 로딩

프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용합니다. JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 다음 두 가지 방법을 제공합니다.

- 즉시 로딩 : 엔티티를 조회할 때 연관된 엔티티도 함께 조회합니다.
	- em.find(Member.class, "member1") 를 호출할 때 회원 엔티티와 연관된 팀 엔티티도 함께 조회합니다.

- 지연 로딩 : 연관된 엔티티를 실제 사용할 때 조회합니다.
	- member.getTeam().getName() 처럼 조회한 팀 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해서 팀 엔티티를 조회합니다.

#### 1) 즉시 로딩

대부분의 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용합니다.

![jpa45](../static/jpa/jpa45.png)

위 쿼리를 살펴보면 외부 조인을 사용하고 있는 것을 확인할 수 있습니다. 하지만 외부 조인보다 내부 조인이 성능과 최적화에서 더 유리합니다. 외래 키에 NOT NULL 제약 조건을 설정하면 값이 있는 것을 보장합니다. 따라서 이때는 내부 조인만 사용해도 됩니다.

JPA 에게도 이런 사실을 알려줘야 합니다. @JoinColumn에 nullable = false 를 설정해서 이 외래 키는 NULL 값을 허용하지 않는다고 알려주면 JPA는 외부 조인 대신에 내부 조인을 사용합니다.

또는 @ManyToOne(optional = false) 옵션을 통해 내부 조인을 사용할 수 있습니다.

> 정리하자면 JPA는 선택적 관계면 외부 조인을 사용하고 필수 관계면 내부 조인을 사용합니다.

#### 2) 지연 로딩

지연 로딩을 사용하려면 fetch 속성을 FetchType.LAZY 로 설정합니다.
참고로 조회 대상이 이미 영속성 컨텍스트에 있으면 프록시를 사용할 이유가 없기 때문이 지연 로딩 설정이어도 프록시가 아닌 실제 엔티티를 사용하게 됩니다.

#### 즉시 로딩, 지연 로딩 정리

연관된 데이터를 즉시 로딩하는 것이 좋은지 아니면 실제 사용할 때까지 지연해서 로딩하는 것이 좋은지는 상황에 따라 다릅니다.

- 지연 로딩 : 연관된 엔티티를 프록시로 조회합니다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회합니다.
- 즉시 로딩 : 연관된 엔티티를 즉시 조회합니다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회합니다.


---

## 지연 로딩 활용

#### JPA 기본 페치 전략

JPA의 기본 페치 전략은 연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용합니다. 컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩할 수 있기 때문입니다.

추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것입니다. 그리고 애플리케이션 개발이 어느 정도 완료단계에 왔을 때 실제 사용하는 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하면 됩니다.

#### 컬렉션에 FetchType.EAGER 사용 시 주의점

- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않습니다.
	- 컬렉션과 조인한다는 것은 데이터베이스 테이블로 보면 일대다 조인입니다.
	- 일대다 조인은 결과 데이터가 다 쪽에 있는 수만큼 증가하게 된다는 것입니다.
	- JPA는 조회된 결과를 메모리에서 필터링해서 반환합니다. 따라서 2개 이상의 컬렉션을 즉시 로딩으로 설정하는 것은 권장하지 않습니다.

- 컬렉션 즉시 로딩은 항상 외부 조인을 사용합니다.
	- 예를 들어 다대일 관계인 회원 테이블과 팀 테이블을 조인할 때 회원 테이블의 외래 키에 not null 제약 조건을 걸어두면 모든 회원은 팀에 소속되므로 항상 내부 조인을 사용해도 됩니다.
	- 반대로 팀 테이블에서 회원 테이블로 일대다 관계를 조인할 때 회원이 한 명도 없는 팀을 내부 조인하면 팀까지 조회되지 않는 문제가 발생합니다.
	- 데이터베이스 제약조건으로 이런 상황을 막을 수는 없습니다.
	- 따라서 JPA는 일대다 관계를 즉시 로딩할 때 항상 외부 조인을 사용합니다.

fetchType.EAGER 설정과 조인 전략을 정리하면 다음과 같습니다.

- @ManyToOne, @OneToOne
	- optional = false : 내부 조인
	- optional = true : 외부 조인

- @OneToMany, @ManyToMany
	- optional = false : 외부 조인
	- optional = true : 외부 조인


---

## 영속성 전이 : CASCADE

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 상요하면 됩니다. JPA는 CASCADE 옵션으로 영속성 전이를 제공합니다. 쉽게 말해서 영속성 전이를 사용하면 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있습니다.

#### 영속성 전이 : 저장

```java
@Entity
public class Parent {
	...
	@OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
	private List<Child> children = new ArrayList<Child>();
	...
}

@Entity
public class Child {
	@Id @GeneratedValue
	private Long id;

	@ManyToOne
	private Parent parent;
	...
}
```

cascade 설정이 없었다면 Child 엔티티를 만들고 자식과 부모 연관관계를 설정한 후 직접 persist() 메서드를 통해 저장을 해야 했습니다. 하지만 cascade 옵션을 통해 아래 코드로 변경 가능합니다.

```java
Child child1 = new Child();
Child child2 = new Child();

Parent parent = new Parent();
child1.setParent(parent);   // 연관관계 추가
child2.setParent(parent);   // 연관관계 추가

parent.getChildren().add(child1);
parent.getChildren().add(child2);

// 부모 저장, 연관된 자식들 저장
em.persist(parent);
```

부모만 영속화하면 CascadeType.PERSIST 로 설정한 자식 엔티티까지 함께 영속화해서 저장합니다.

영속성 전이는 연관관계를 매핑하는 것과는 아무 관련이 없습니다. 단지 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공할 뿐입니다.

#### 영속성 전이 : 삭제

영속성 전이는 엔티티를 삭제할 때도 사용할 수 있습니다. CascadeType.REMOVE로 설정하고 부모 엔티티만 삭제하면 연관된 자식 엔티티도 함께 삭제됩니다.

```java
Parent = findParent = em.find(Parent.class, 1L);
em.remove(findParent);
```

코드를 실행하면 DELET 쿼리를 3번 실행하고 부모는 물론 연관된 자식도 모두 삭제합니다. 삭제 순서는 외래 키 제약 조건을 고려해서 자식을 먼저 삭제하고 부모를 삭제합니다.

> cascade 설정을 하지 않고 부모 엔티티만 삭제한다면 외래 키 제약조건으로 인해, 데이터베이스에서 외래키 무결성 예외가 발생합니다.


---

## 고아 객체

JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체(ORPHAN) 제거라 합니다. 이 기능을 사용해서 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제됩니다.

```java
@Entity
public class Parent {
	@Id @GeneratedValue
	private Long id;

	@OneToMany(mappedBy = "parent", orphanRemoval = true)
	private List<Child> children = new ArrayList<Child>();
}
```

이제 아래 코드를 살펴봅니다.

```java
Parent parent1 = em.find(Parent.class, id);
parent1.getChildren().remove(0);  // 자식 엔티티를 컬렉션에서 제거
```

위 코드 실행 결과 "DELETE FROM CHILD WHERE ID = ?" 쿼리가 실행됩니다.
orphanRemoval = true 옵션으로 인해 컬렉션에서 엔티티를 제거하면 데이터베이스의 데이터도 삭제됩니다.

고아 객체 제거 기능은 영속성 컨텍스트를 플러시할 때 적용되므로 플러시 시점에 DELETE SQL이 실행됩니다.

고아 객체를 정리해보면, 고아 객체 제거는 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능입니다. 따라서 이 기능은 참조하는 곳이 하나일 때만 사용해야 합니다. 쉽게 이야기해서 특정 엔티티가 개인 소유하는 엔티티에만 이 기능을 적용해야 합니다.

만약 삭제한 엔티티를 다른 곳에서도 참조한다면 문제가 발생할 수 있습니다. 이런 이유로 orphanRemoval은 @OneToOne, @OneToMany 에만 사용할 수 있습니다.

고아 객체 제거에는 기능이 하나 더 있는데 개념적으로 볼때 부모를 제거하면 자식은 고아가 됩니다. 따라서 부모를 제거하면 자식도 같이 제거됩니다. 이는 CascadeType.REMOVE 를 설정한 것과 같습니다.


---

## 영속성 전이 + 고아 객체, 생명주기

CascadeType.ALL + orphanRemoval = true 를 동시에 사용하면 어떻게 될까?
두 옵션을 모두 활성화하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있습니다. 에를 들면 다음과 같습니다.

자식을 저장하려면 부모에 등록만 하면 됩니다.(CASCADE)

```java
Parent parent = em.find(Parent.class, parentId);
parent.addChild(child1);
```

자식을 삭제하려면 부모에서 제거하면 됩니다.(orphanRemoval)

```java
Parent parent = em.find(Parent.class, parentId);
parent.getChildren().remove(removeObject);
```

> 참고로 CascadeType.REMOVE 설정이 있다고 컬렉션에서 자식 객체를 지운다고 자식 엔티티가 삭제되는 것이 아닙니다.
> CascadeType.REMOVE 설정은 부모 엔티티가 삭제될 때 자식 엔티티도 지우는 것이고 자식 엔티티만 삭제하려면 orphanRemoval 설정을 이용해야 합니다.


---

## 정리

지금까지 내용을 간단하게 정리하면 다음과 같습니다.

- JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 지원하는데 이 때 프록시 기술을 사용합니다.
- 객체를 조회할 때 연관된 객체를 즉시 로딩하는 방법을 즉시 로딩이라 하고, 연관된 객체를 지연해서 로딩하는 방법을 지연 로딩이라 합니다.
- 객체를 저장하거나 삭제할 때연관된 객체도 함께 저장하거나 삭제할 수 있는데 이것을 영속성 전이라 합니다.
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 제거 기능을 사용하면 됩니다.