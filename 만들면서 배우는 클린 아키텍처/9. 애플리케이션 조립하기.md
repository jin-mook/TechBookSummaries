
이번 장에서는 평범한 자바로 의존성 주입을 어떻게 하는지, 그리고 스프링, 스프링 부트 프레임워크에서는 이를 각각 어떻게 하는지 살펴봅니다.


---

## 왜 조립까지 신경 써야 할까?

모든 의존성은 안쪽으로, 애플리케이션의 도메인 코드 방향으로 향해야 도메인 코드가 바깥 계층의 변경으로부터 안전하다는 점을 기억해야 합니다.

유스케이스가 영속성 어댑터를 호출해야 하고 스스로 인스턴스화한다면 코드 의존성이 잘못된 방향으로 만들어진 것입니다. 유스케이스는 인터페이스만 알아야 하고, 런타임에 이 인터페이스의 구현을 제공받아야 합니다.

이러한 스타일의 유익한 부수효과 중 하나는 코드를 훨씬 더 테스트하기 쉽다는 것입니다.

그럼 객체 인스턴스를 생성할 책임은 누구에게 있을까, 그리고 어떻게 의존성 규칙을 어기지 않으면서 그렇게 할 수 있을까?
이에 대한 대답을 위해 아키텍처에 대해 중립적이고 인스턴스 생성을 위해 모든 클래스에 대한 의존성을 가지는 설정 컴포넌트가 있어야 합니다.

![[Pasted image 20240402010448.png]]


설정 컴포넌트는 우리가 제공한 조각들로 애플리케이션을 조립하는 것을 책임집니다. 이 컴포넌트는 다음과 같은 역할을 수행해야 합니다.

- 웹 어댑터 인스턴스 생성
- HTTP  요청이 실제로 웹 어댑터로 전달되도록 보장
- 유스케이스 인스턴스 생성
- 웹 어댑터에 유스케이스 인스턴스 제공
- 영속성 어댑터 인스턴스 생성
- 유스케이스에 영속성 어댑터 인스턴스 제공
- 영속성 어댑터가 실제로 데이터베이스에 접근할 수 있도록 보장

더불어 설정 컴포넌트는 설정 파일이나 커맨드라인 파라미터 등과 같은 설정 파라미터의 소스에도 접근할 수 있어야 합니다. 보다시피 책임이 굉장히 많습니다. 그러나 애플리케이션의 나머지 부분을 깔끔하게 유지하고 싶다면 이처럼 구성요소들을 연결하는 바깥쪽 컴포넌트가 필요합니다. 그리고 이 컴포넌트는, 작동하는 애플리케이션으로 조립하기 위해 애플리케이션을 구성하는 모든 움직이는 부품을 알아야 합니다.


---

## 평범한 코드로 조립하기

![[Pasted image 20240402010715.png]]

위 코드를 통해 자바를 이용해 컴포넌트를 만드는 예시를 확인할 수 있습니다. 자바에서는 애플리케이션이 main 메서드로부터 시작됩니다. main 메서드 안에서 웹 컨트롤러부터 영속성 어댑터까지, 필요한 모든 클래스의 인스턴스를 생성한 후 함께 연결합니다.

위 코드는 몇 가지 단점이 있습니다.

첫 번째로, 앞의 코드는 웹 컨트롤러, 유스케이스, 영속성 어댑터가 단 하나씩만 있는 애플리케이션을 예로 든 것입니다. 완전한 엔터프라이즈 애플리케이션을 실행하기 위해서는 이러한 코드를 얼마나 많이 만들어야 할지 모릅니다.

두 번째로, 각 클래스가 속한 패키지 외부에서 인스턴스를 생성하기 때문에 이 클래스들은 전부 public 이어야 합니다. package-private 접근 제한자를 이용해서 원치 않은 의존성을 피할 수 있었다면 더 좋았을 것입니다.


---

## 스프링의 클래스 패스 스캐닝으로 조립하기

스프링 프레임워크를 이용해서 애플리케이션을 조립한 결과물을 애플리케이션 컨텍스트(application context) 라고 합니다. 애플리케이션 컨텍스트는 애플리케이션을 구성하는 모든 객체를 포함합니다.

스프링에서는 @Componenet 애너테이션을 이용해 해당 클래스들의 인스턴스를 만들어 애플리케이션 컨텍스트에 추가합니다.

@Componenet 대신 @PersistenceAdapter 커스텀 애너테이션을 이용해서 영속성 어댑터 클래스들이 애플리케이션의 일부임을 표시할 수도 있습니다. 이 애너테이션 덕분에 코드를 읽는 사람들은 아키텍처를 더 쉽게 파악할 수 있습니다.


---

## 스프링의 자바 컨피그로 조립하기

이 방식에서는 애플리케이션 컨텍스트에 추가할 빈을 생성하는 설정 클래스를 만듭니다.

@Configuration 애너테이션을 통해 이 클래스가 스프링의 클래스패스 스캐닝에서 발견해야 할 설정 클래스임을 표시합니다. 그러므로 사실 여전히 클래스패스 스캐닝을 사용하고 있는 것이지만, 모든 빈을 가져오는 대신 설정 클래스만 선택하기 때문에 해로운 마법이 일어날 확률이 줄어듭니다.

하지만 이 방법에도 문제점은 있습니다. 설정 클래스가 생성하는 빈이 설정 클래스와 같은 패키지에 존재하지 않는다면 이 빈들을 public 으로 만들어야 합니다.