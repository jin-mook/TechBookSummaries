
이번 장에서는 육각형 아키텍처에서의 테스트 전략에 대해 이야기합니다. 아키텍처의 각 요소들을 테스트할 수 있는 테스트 유형에 대해 논의할 것입니다.


---

## 테스트 피라미드

![[Pasted image 20240320020231.png]]

기본 전제는 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고, 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지해야 합니다. 이 테스트는 하나의 단위가 제대로 동작하는지 확인할 수 있는 단위 테스트들입니다.

테스트 피라미드는 테스트가 비싸질수록 테스트의 커버리지 목표는 낮게 잡아야 한다는 것을 보여줍니다. 그렇지 않으면 새로운 기능을 만드는 것보다 테스트를 만드는 데 시간을 더 쓰게 되기 때문입니다.

단위 테스트는 피라미드의 토대에 해당합니다. 일반적으로 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트합니다. 만약 테스트 중인 클래스가 다른 클래스에 의존한다면 의존되는 클래스들은 인스턴스화하지 않고 테스트하는 동안 필요한 작업들을 흉내 내는 목으로 대체합니다.

피라미드의 다음 계층은 통합 테스트입니다. 이 테스트는 연결된 여러 유닛을 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한 대로 잘 동작하는지 검증합니다.

시스템 테스트는 애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증합니다.

시스템 테스트 위에는 애플리케이션의 UI를 포함하는 엔드투엔드 테스트 층이 있을 수 있습니다.


---

## 단위 테스트로 도메인 엔티티 테스트하기

책에서는 육각형 아키텍처의 중심이 되는 도메인 엔티티를 먼저 테스트합니다. Account 라는 도메인이 withdraw() 메서드를 가질 때 해당 메서드가 제대로 작동하는지 확인하기 위한 단순한 단위 테스트입니다.

이러한 테스트는 만들고 이해하는 것도 쉬운 편이고, 아주 빠르게 실행됩니다. 테스트가 이보다 간단할 수 없습니다. 이런 식의 단위 테스트가 도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증하기에 가장 적절한 방법입니다.


---

## 단위 테스트로 유스케이스 테스트하기

계층의 바깥쪽으로 나가서, 다음으로 테스트할 아키텍처 요소는 유스케이스입니다. SendMoneyService 클래스의 SendMoney 유스케이스가 있을 수 있습니다.

테스트의 가독성을 높이기 위해 행동-주도 개발에서 일반적으로 사용되는 방식인 given / when / then 방식을 사용할 수 있습니다.

테스트 중인 유스케이스 서비스는 상태가 없기 때문에 then 섹션에서 특정 상태를 검증할 수 없습니다. 대신 테스트는 서비스가 의존 대상의 특정 메서드와 상호작용했는지 여부를 검증합니다. 이는 테스트가 코드의 행동 변경뿐만 아니라 코드의 구조 변경에도 취약해진다는 의미가 됩니다. 자연스럽게 코드가 리팩터링되면 테스트도 변경될 확률이 높아집니다.

그렇기 때문에, 테스트에서 어떤 상호작용을 검증하고 싶은지 신중하게 생각해야 합니다. 앞의 예제처럼 모든 동작을 검증하는 대신 중요한 핵심만 골라 집중해서 테스트하는 것이 좋습니다.

해당 테스트는 단위 테스트이긴 하지만 의존성의 상호작용을 테스트하고 있기 때문에 통합테스트에 가깝습니다. 그렇지만 목으로 작업하고 있고 실제 의존성을 관리해야 하는 것은 아니기 때문에 완전한 통합 테스트에 비해 만들고 유지보수하기 쉽습니다.


---

## 통합 테스트로 웹 어댑터 테스트하기

한 계층 더 바깥으로 나가면 어댑터에 도착합니다. 웹 어댑터를 테스트할 수 있습니다.

웹 어댑터는 JSON 문자열 등의 형태로 HTTP를 통해 입력을 받고, 입력에 대한 유효성 검증을 하고, 유스케이스에서 사용할 수 있는 포맷으로 매핑하고, 유스케이스에 전달합니다. 그러고 나서 다시 유스케이스의 결과를 JSON 으로 매핑하고 HTTP 응답을 통해 클라이언트에 반환합니다.

스프링에서는 이러한 테스트를 @WebMvcTest 어노테이션을 통해 진행할 수 있고 MockMvc 객체를 이용해 모킹할 수 있습니다.

MockMvc 객체를 이용해 모킹했기 때문에 실제로 HTTP 프로토콜을 통해 테스트한 것은 아닙니다. 프레임워크가 HTTP 프로토콜에 맞게 모든 것을 적절히 잘 반환한다고 믿는 것입니다.

웹 컨트롤러가 스프링 프레임워크에 강하게 묶여 있기 때문에 격리된 상태로 테스트하기 보다는 이 프레임워크와 통합된 상태로 테스트하는 것이 합리적입니다.


---

## 통합 테스트로 영속성 어댑터 테스트하기

비슷한 이유로 영속성 어댑터의 테스트에는 단위 테스트보다는 통합 테스트를 적용하는 것이 합리적입니다. 단순히 어댑터의 로직만 검증하고 싶은 게 아니라 데이터베이스 매핑도 검증하고 싶기 때문입니다.

@DataJpaTest 애너테이션으로 스프링 데이터 리포지토리들을 포함해서 데이터베이스 접근에 필요한 객체 네트워크를 인스턴스화해야 한다고 스프링에 알려줍니다. loadAccount() 메서드에 대한 테스트에서는 SQL 스크립트를 이용해 데이터베이스를 특정 상태로 만듭니다. 그런 다음, 어댑터 API를 이용해 계좌를 가져온 후 SQL 스크립트에서 설정한 상태값을 가지고 있는지 검증합니다.

```java
@DataJpaTest
@Import({AccountPersistenceAdapter.class, AccountMapper.class})
class AccountPersistenceAdapterTest {

	...

	@Test
	@Sql("AccountPersistenceAdapterTest.sql")
	void loadsAccount() {
		...
	}
}
```

위 테스트에서는 데이터베이스를 모킹하지 않았다는 점이 중요합니다. 테스트가 실제로 데이터베이스에 접근합니다. 참고로 스프링에서는 기본적으로 인메모리 데이터베이스를 테스트에서 사용합니다. 아무것도 설정할 필요 없이 곧바로 테스트할 수 있으므로 아주 실용적입니다.

하지만 프로덕션 환경에서는 인메모리 데이터베이스를 사용하지 않는 경우가 많기 때문에 인메모리 데이터베이스에서 테스트가 완벽하게 통과했더라도 실제 데이터베이스에서는 문제가 생길 가능성이 높습니다. 예를 들면, 데이터베이스마다 고유한 SQL 문법이 있어서 이 부분이 문제가 되는 식으로 말입니다.

이러한 이유로 영속성 어댑터 테스트는 실제 데이터베이스를 대상으로 진행해야 합니다. Testcontainers 같은 라이브러리는 필요한 데이터베이스를 도커 컨테이너에 띄울 수 있기 때문에 이런 측면에서 아주 유용합니다.


---

## 시스템 테스트로 주요 경로 테스트하기

@SpringBootTest 애너테이션은 스프링이 애플리케이션을 구성하는 모든 객체 네트워크를 띄우게 합니다. 또한 랜덤 포트로 이 애플리케이션을 띄우도록 설정하고 있습니다.

여기서는 웹 어댑터에서처럼 MockMvc를 이용해 요청을 보내는 것이 아니라 TestRestTemplate 을 이용해서 요청을 보냅니다. 테스트를 프로덕션 환경에 조금 더 가깝게 만들기 위해 실제 HTTP 통신을 하는 것입니다.

시스템 테스트라고 하더라도 언제나 서드파티 시스템을 실행해서 테스트할 수 있는 것은 아니기 때문에 결국 모킹을 해야 할 때도 있습니다. 육각형 아키텍처는 이러한 경우 몇 개의 출력 포트 인터페이스만 모킹하면 되기 때문에 아주 쉽게 이 문제를 해결할 수 있습니다.

이전 절에서 이야기한 바와 같이 단위 테스트와 통합 테스트를 만들었다면 시스템 테스트는 앞서 커버한 코드와 겹치는 부분이 많을 것입니다. 물론 추가적인 장점이 있습니다. 일반적으로 시스템 테스트는 단위 테스트와 통합 테스트가 발견하는 버그와는 또다른 종류의 버그를 발견해서 수정할 수 있게 해줍니다. 예를 들어, 단위 테스트나 통합 테스트만으로는 알아차리지 못했을 계층 간 매핑 버그 같은 것들이 있을 수 있습니다.


---

## 얼마만큼의 테스트가 충분할까

라인 커버리지는 테스트 성공을 측정하는 데 있어서는 잘못된 지표입니다.

> 저자는 얼마나 마음 편하게 소프트웨어를 배포할 수 있느냐를 테스트의 성공 기준으로 삼으면 된다고 생각합니다.

테스트를 실행한 후에 소프트웨어를 배포해도 될 만큼 테스트를 신뢰한다면 그것으로 된 것입니다.

> 처음 몇 번의 배포에는 믿음의 도약이 필요합니다. 그렇지만 프로덕션의 버그를 수정하고 이로부터 배우는 것을 우선순위로 삼으면 제대로 가고 있는 것입니다.

각각의 프로덕션 버그에 대해서 테스트가 이 버그를 왜 잡지 못했을까를 생각하고 이에 대한 답변을 기록하고, 이 케이스를 커버할 수 있는 테스트를 추가해야 합니다. 시간이 지나면 이 작업들이 배포할 때 마음을 편하게 해줄 것이고, 남겨둔 기록은 시간이 지날수록 상황이 개선되고 있음을 증명해줄 것입니다.

하지만 우리가 만들어야 할 테스트를 정의하는 전략으로 시작하는 것도 좋습니다. 다음은 육각형 아키텍처에서 사용하는 전략입니다.

- 도메인 엔티티를 구현할 때는 단위 테스트로 커버하자
- 유스케이스를 구현할 때는 단위 테스트로 커버하자
- 어댑터를 구현할 때는 통합 테스트로 커버하자
- 사용자가 취할 수 있는 중요 애플리케이션 경로는 시스템 테스트로 커버하자

구현할 때는 이라는 문구에 주목하자. 만약 테스트가 기능 개발 후가 아닌 개발 중에 이뤄진다면 하기 싫은 귀찮은 작업이 안리ㅏ 개발 도구로 느껴질 것입니다.

하지만 새로운 필드를 추가할 때마다 테스트를 고치는 데 한 시간을 써야 한다면 뭔가 잘못 된 것입니다.


---

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

육각형 아키텍처는 도메인 로직과 바깥으로 향한 어댑터를 깔끔하게 분리합니다. 덕분에 핵심 도메인 로직은 단위 테스트로, 어댑터는 통합 테스트로 처리하는 명확한 테스트 전략을 정의할 수 있습니다.

입출력 포트는 테스트에서 아주 뚜렷한 모킹 지점이 됩니다. 각 포트에 대해 모킹할지, 실제 구현을 이용할지 선택할 수 있습니다. 만약 포트가 아주 작고 핵심만 담고 있다면 모킹하는 것이 아주 쉬울 것입니다. 포트 인터페이스가 더 적은 메서드를 제공할수록 어떤 메서드를 모킹해야 할지 덜 헷갈립니다.

모킹하는 것이 너무 버거워지거나 코드의 특정 부분을 커버하기 위해 어떤 종류의 테스트를 써야 할지 모르겠다면 이는 경고 신호입니다. 이런 측면에서 테스트는 아키텍처의 문제에 대해 경고하고 유지보수 가능한 코드를 만들기 위한 올바른 길로 인도하는 카나리아의 역할도 한다고 할 수 있습니다.

