
일정 규모 이상의 모든 프로젝트에서는 시간이 지나면서 아키텍처가 서서히 무너지게 됩니다. 계층 간의 경계가 약화되고, 코드는 점점 더 테스트하기 어려워지고, 새로운 기능을 구현하는 데 점점 더 많은 시간이 듭니다.

이번 장에서는 아키텍처 내의 경계를 강제하는 방법과 함께 아키텍처 붕괴에 맞서 싸우기 위해 취할 수 있는 몇 가지 조치를 살펴봅니다.


---

## 경계와 의존성

아키텍처 경계를 강제하는 여러 가지 방법에 대해 이야기하기에 앞서 아키텍처의 어디에 경계가 있고, 경계를 강제한다는 것이 어떤 의미인지 먼저 살펴봅니다.

![[Pasted image 20240402011520.png]]


위 그림에서 가장 안쪽에 있는 계층에는 도메인 엔티티가 있습니다. 애플리케이션 계층은 애플리케이션 서비스안에 유스케이스를 구현하기 위해 도메인 엔티티에 접근합니다. 어댑터는 인커밍 포트를 통해 서비스에 접근하고, 반대로 서비스는 아웃고잉 포트를 통해 어댑터에 접근합니다. 마지막으로 설정 계층은 어댑터와 서비스 객체를 생성할 팩터리를 포함하고 있고, 의존성 주입 메커니즘을 제공합니다.

이번 장에서는 이러한 의존성 규칙을 강제하는 방법들을 알아보고 잘못된 방향을 가리키는 의존성을 없게 만들고자 합니다.


---

## 접근 제한자

package-private 제한자는 왜 그렇게 중요할까? 자바 패키지를 통해 클래스들을 응집적인 모듈로 만들어 주기 때문입니다. 이러한 모듈 내에 있는 클래스들은 서로 접근 가능하지만, 패키지 바깥에서는 접근할 수 없습니다. 그럼 모듈의 진입점으로 활용될 클래스들만 골라서 public으로 만들면 됩니다. 이렇게 하면 의존성이 잘못된 방향을 가리켜서 의존성 규칙을 위반할 위험이 줄어듭니다.

![[Pasted image 20240402011805.png]]


위 그림에서 persistence 패키지에 있는 클래스들은 외부에서 접근할 필요가 없기 때문에 package-private(위 트리에서'o'로 표시) 으로 만들 수 있습니다. 영속성 어댑터는 자신이 구현하는 출력 포트를 통해 접근됩니다. 의존성 주입 메커니즘은 일반적으로 리플렉션을 이용해 클래스를 인스턴스로 만들기 때문에 package-private 이더라도 여전히 인스턴스를 만들 수 있습니다.

domain 패키지는 다른 계층에서 접근할 수 있어야 하고, application 계층은 web 어댑터와 persistence 어댑터에서 접근 가능해야 합니다.


---

## 컴파일 후 체크

클래스에 public 제한자를 쓰면 아키텍처 상의 의존성 방향이 잘못되더라도 컴파일러는 다른 클래스들이 이 클래스를 사용하도록 허용합니다.

이런 경우 컴파일 후 체크를 도입하는 것이 좋습니다. 다시 말해, 코드가 컴파일된 후에 런타임에 체크한다는 뜻입니다. 이러한 런타임 체크는 지속적인 통합 빌드 환경에서 자동화된 테스트 과정에서 가장 잘 동작합니다.

이러한 체크를 도와주는 자바용 도구로 ArchUnit 이 있습니다. 다른 무엇보다 ArchUnit은 의존성 방향이 기대한 대로 잘 설정돼 있는지 체크할 수 있는 API를 제공합니다.

ArchUnit API를 이용하면 적은 작업만으로도 육각형 아키텍처 내에서 관련된 모든 패키지를 명시할 수 있는 일종의 도메인 특화 언어를 만들 수 있고, 패키지 사이의 의존성 방향이 올바른지 자동으로 체크할 수 있습니다.


---

## 빌드 아티팩트

빌드 아티팩트는 빌드 프로세스의 결과물입니다. 자바 세계에서는 메이븐과 그레이들이 인기가 있습니다. 그러므로 지금까지 단일 메이븐 혹은 그레이들 빌드 스크립트가 있고, 메이븐이나 그레이들을 호출해서 코드를 컴파일하고, 테스트하고, 하나의 JAR 파일로 패키징할 수 있었다고 상상합니다.

빌드 도구의 주요한 기능 중 하나는 의존성 해결입니다. 이를 활용해서 모듈과 아키텍처의 계층 간의 의존성을 강제할 수 있습니다. 각 모듈 혹은 계층에 대해 전용 코드베이스와 빌드 아티팩트로 분리된 빌드 모듈(JAR 파일)을 만들 수 있습니다. 각 모듈의 빌드 스크립트에서는 아키텍처에서 허용하는 의존성만 지정합니다. 클래스들이 클래스패스에 존재하지도 않아 컴파일 에러가 발생하기 때문에 개발자들은 더이상 실수로 잘못된 의존성을 만들 수 없습니다.

![[Pasted image 20240402012530.png]]


위 그림은 아키텍처를 여러 개의 분리된 빌드 아티팩트로 나누는 몇 가지 선택지를 보여줍니다. 애플리케이션을 빌드 모듈로 쪼개는 다양한 방법을 묘사하고 있습니다. 핵심은 모듈을 더 세분화할수록, 모듈 간 의존성을 더 잘 제어할 수 있게 된다는 것입니다. 하지만 더 작게 분리할수록 모듈 간에 매핑을 더 많이 수행해야 합니다.

이 밖에도 빌드 모듈로 아키텍처 경계를 구분하는 것은 패키지로 구분하는 방식과 비교했을 때 몇 가지 장점이 있습니다.

첫 번째로, 빌드 도구가 순환 의존성을 극도로 싫어한다는 것입니다. 그러므로 빌드 도구를 이용하면 빌드 모듈 간 순환 의존성이 없음을 확신할 수 있습니다.

두 번째로, 빌드 모듈 방식에서는 다른 모듈을 고려하지 않고 특정 모듈의 코드를 격리한 채로 변경할 수 있습니다. 만약 애플리케이션 계층이 독립된 빌드 모듈이라면 IDE가 어댑터에 신경 쓰지 않을 것이기 때문에 애플리케이션 계층의 테스트를 마음대로 실행할 수 있습니다. 그러므로 여러 개의 빌드 모듈은 각 모듈을 격리한 채로 변경할 수 있게 해줍니다.

마지막으로, 모듈 간 의존성이 빌드 스크립트에 분명하게 선언돼 있기 때문에 새로 의존성을 추가하는 일은 우연이 아닌 의식적인 행동이 됩니다.

하지만 이런 장점에는 빌드 스크립트를 유지보수하는 비용을 수반하기 때문에 아키텍처를 여러 개의 빌드 모듈로 나누기 전에 아키텍처가 어느 정도는 안정된 상태여야 합니다.


---

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

기본적으로 소프트웨어 아키텍처는 아키텍처 요소 간의 의존성을 관리하는 게 전부입니다. 그렇기 때문에 아키텍처를 잘 유지해나가고 싶다면 의존성이 올바른 방향을 가리키고 있는지 지속적으로 확인해야 합니다.

새로운 코드를 추가하거나 리팩터링할 때 패키지 구조를 항상 염두에 둬야 하고, 가능하다면 package-private 가시성을 이용해 패키지 바깥에서 접근하면 안 되는 클래스에 대한 의존성을 피해야 합니다.

하나의 빌드 모듈 안에서 아키텍처 경계를 강제해야 하고, 패키지 구조가 허용하지 않아 package-private 제한자를 사용할 수 없다면 ArchUnit 같은 컴파일 후 체크 도구를 이용해야 합니다.

그리고 아키텍처가 충분히 안정적이라고 느껴지면 아키텍처 요소를 독립적인 빌드 모듈로 추출해야 합니다. 그래야 의존성을 분명하게 제어할 수 있기 때문입니다.