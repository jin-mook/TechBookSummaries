
이 책의 서문에서는 절대 갚을 길 없는 기술 부채를 쌓아가면서 항상 지름길의 유혹을 느낀다는 사실을 저주했습니다. 지름길을 방지하기 위해서는 먼저 지름길 자체를 파악해야 합니다. 그래서 이번 장의 목표는 잠재적인 지름길에 대한 인식을 높이고 그 영향에 대해 이야기하는 것입니다.

이 정보만 있어도 우발적으로 사용되는 지름길을 인식하고 수정할 수 있습니다. 또는 정당한 지름길이라면 지름길의 효과를 의식적으로 택할 수도 있습니다.

> 어떤 때는 (의식적으로) 지름길을 먼저 취하고 나중에 고치는 것이(혹은 아예 고치지 않더라도) 실제로 더 경제적일 수도 있습니다.


---

## 왜 지름길은 깨진 창문 같을까?

깨진 창문 이론을 저자의 표현으로 바꾼다면

<span style="color:#ff0000">"어떤 것이 멈춘 것처럼 보이고, 망가져 보이고, 혹은 관리되지 않는다고 여겨지면 인간의 뇌는 이를 더 멈추고, 망가뜨려도 된다고 생각하게 된다"</span>

이 이론이 코드 작업에 적용될 때의 의미는 다음과 같습니다.

- 품질이 떨어진 코드에서 작업할 때 더 낮은 품질의 코드를 추가하기가 쉽다.
- 코딩 규칙을 많이 어긴 코드에서 작업할 때 또 다른 규칙을 어기기도 쉽다.
- 지름길을 많이 사용한 코드에서 작업할 때 또 다른 지름길을 추가하기도 쉽다.


---

## 깨끗한 상태로 시작할 책임

가능한 한 지름길을 거의 쓰지 않고 기술 부채를 지지 않은 채로 프로젝트를 깨끗하게 시작하는 것이 중요합니다.

소프트웨어 프로젝트는 대개 큰 비용이 들고 장기적인 노력을 필요로 하기 때문에 깨진 창문을 막는 것이 소프트웨어 개발자들의 아주 막대한 책임입니다.

그러나 때로는 지름길을 취하는 것이 더 실용적일 때도 있습니다. 작업 중인 부분이 프로젝트 전체로 봤을 때 그리 중요하지 않은 부분이거나, 프로토타이핑 작업 중이거나, 경제적인 이유가 있을 수도 있습니다.

이어지는 절에서부터 육각형 아키텍처에서 고려해볼 수 있는 지름길들을 몇 가지 이야기해보겠습니다.


---

## 유스케이스 간 모델 공유하기

유스케이스마다 다른 입출력 모델을 가져야 한다고 4장에서 이야기했습니다. 즉, 입력 파라미터의 타입과 반환값의 타입이 달라야 한다는 뜻입니다. 아래 그림은 두 개의 유스케이스가 같은 입력 모델을 공유하는 예시입니다.

![[Pasted image 20240402013940.png]]

공유로 인한 영향은 SendMoneyUseCase 와 RevokeActivityUseCase가 결합된다는 것입니다. 공유하고 있는 SendMoneyCommand 클래스가 변경되면 두 유스케이스 모두 영향을 받습니다.

유스케이스 간 입출력 모델을 공유하는 것은 유스케이스들이 기능적으로 묶여 있을 때 유효합니다. 즉, 특정 요구사항을 공유할 때 괜찮다는 의미입니다. 이 경우 특정 세부사항을 변경할 경우 실제로 두 유스케이스 모두에 영향을 주고 싶은 것입니다.

> 비슷한 개념의 유스케이스 여러 개를 만든다면 유스케이스를 독립적으로 진화할 필요가 있는지 주기적으로 질문해야 합니다. 대답이 "예"가 되는 그때가 바로 입출력 모델을 분리할 시점입니다.


---

## 도메인 엔티티를 입출력 모델로 사용하기

도메인 엔티티인 Account 와 인커밍 포트인 SendMoneyUseCase 가 있으면 엔티티를 인커밍 포트의 입출력 모델로 사용하고 싶다는 생각이 들지도 모릅니다.

![[Pasted image 20240402014240.png]]


인커밍 포트는 도메인 엔티티에 의존성을 가지고 있습니다. 그 결과, Account 엔티티는 변경할 또 다른 이유가 생겼습니다.

현재 Account 엔티티에는 존재하지 않는 정보를 유스케이스가 필요로 한다고 생각해보자, 이 정보는 최종적으로 Account 엔티티에 저장돼 있어야 하는 것이 아니라 다른 도메인이나 다른 바운디드 컨텍스트에 저장돼야 합니다. 그럼에도 불구하고 이미 유스케이스 인터페이스에서 사용할 수 있기 때문에 Account 엔티티에 새로운 필드를 추가하고 싶다는 생각이 듭니다.

간단한 생성이나 업데이트 유스케이스에서는 유스케이스 인터페이스에 도메인 엔티티가 있는 것이 괜찮을지도 모릅니다. 데이터베이스에 저장해야 하는 바로 그 상태 정보가 엔티티에 있기 때문입니다.

하지만 유스케이스가 단순히 데이터베이스의 필드 몇 개를 업데이트하는 수준이 아니라 더 복잡한 도메인 로직을 구현해야 한다면 유스케이스 인터페이스에 대한 전용 입출력 모델을 만들어야 합니다. 왜냐하면 유스케이스의 변경이 도메인 엔티티까지 전파되길 바라진 않을 것이기 때문입니다.

> 처음에는 도메인 엔티티를 입력 모델로 사용했더라도 도메인 모델로부터 독립적인 전용 입력 모델로 교체해야 하는 시점을 잘 파악해야 합니다.


---

## 인커밍 포트 건너뛰기

아웃고잉 포트는 애플리케이션 계층과 아웃고잉 어댑터 사이의 의존성을 역전시키기 위한 필수 요소인 반면 인커밍 포트는 의존성 역전에 필수적인 요소는 아닙니다.

![[Pasted image 20240402014603.png]]


인커밍 포트를 제거함으로써 인커밍 어댑터와 애플리케이션 계층 사이의 추상화 계층을 줄였습니다.

하지만 인커밍 포트는 애플리케이션 중심에 접근하는 진입점을 정의합니다. 이를 제거하면 특정 유스케이스를 구현하기 위해 어떤 서비스 메서드를 호출해야 할지 알아내기 위해 애플리케이션의 내부 동작에 대해 더 잘 알아야 합니다. 전용 인커밍 포트를 유지하면 한눈에 진입점을 식별할 수 있습니다. 이는 새로운 개발자가 코드를 파악할 때 특히 더 도움이 됩니다.

인커밍 포트를 유지해야 하는 또 다른 이유는 아키텍처를 쉽게 강제할 수 있기 때문입니다.

> 애플리케이션의 규모가 작거나 인커밍 어댑터가 하나밖에 없어서 모든 제어 흐름을 인커밍 포트의 도움 없이 단숨에 파악할 수 있다면 인커밍 포트가 없는 것이 편하다. 그러나 애플리케이션의 규모가 이후로도 계속 작게 유지되거나 인커밍 어댑터가 계속 하나밖에 없을 것이라고 확신할 수 있을까?


---

## 애플리케이션 서비스 건너뛰기

![[Pasted image 20240402014855.png]]

위 그림에서 아웃고잉 어댑터에 있는 AccountPersistenceAdapter 클래스는 직접 인커밍 포트를 구현해서 일반적으로 인커밍 포트를 구현하는 애플리케이션 서비스를 대체합니다.

하지만 이 방법은 인커밍 어댑터와 아웃고잉 어댑터 사이에 모델을 공유해야 합니다. 이 경우엔 공유해야 하는 모델이 Account 도메인 엔티티이므로 앞에서 이야기한 도메인 모델을 입력 모델로 사용하는 케이스가 되는 것입니다.

나아가 애플리케이션 코어에 유스케이스라고 할 만한 것이 없어집니다. 시간이 지나 도메인 로직이 추가된다면 유지보수하기 어려워질 것입니다.

유스케이스가 엔티티를 단순히 생성, 업데이트, 삭제하는 것보다 더 많은 일을 하게 되면 애플리케이션 서비스를 만든다는 명확한 가이드라인을 팀에 정해둬야 합니다.


---

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

간단한 CRUD 유스케이스에 대해서는 전체 아키텍처를 구현하는 것이 지나치게 느껴지기 때문에 지름길의 유혹을 느낄 수 있습니다. 하지만 모든 애플리케이션은 처음에는 작게 시작하기 때문에, 유스케이스가 단순한 CRUD 상태에서 벗어나는 시점이 언제인지에 대해 팀이 합의하는 것이 매우 중요합니다.

어떤 경우든 아키텍처에 대해, 그리고 왜 특정 지름길을 선택했는가에 대한 기록을 남겨서 나중에 우리 자신 또는 프로젝트를 인계받는 이들이 이 결정에 대해 다시 평가할 수 있게 하자.