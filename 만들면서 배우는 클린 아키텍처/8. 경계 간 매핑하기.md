
이번 장에서는 각 계층의 모델을 매핑하는 것에 대해서 얘기합니다. 아마 매퍼 구현을 피하기 위해 두 계층에서 같은 모델을 사용하는 것에 대해 논의해 본 적이 있을 것입니다. 이러한 논쟁에는 아래 의견이 존재할 것입니다.

- 매핑에 찬성하는 개발자
	- 두 계층 간에 매핑을 하지 않으면 양 계층에서 같은 모델을 사용해야 하는데 이렇게 하면 두 계층이 강하게 결합됩니다.
- 매핑에 반대하는 개발자
	- 하지만 두 계층 간에 매핑을 하게 되면 보일러플레이트 코드를 너무 많이 만들게 됩니다.
	- 많은 유스케이스들이 오직 CRUD만 수행하고 계층에 걸쳐 같은 모델을 사용하기 때문에 계층 사이의 매핑은 과합니다.

두 개발자 모두 일정 부분 맞습니다. 이 개발자들이 결정하는 데 도움이 되도록 이번 장에서 몇 가지 매핑 전략을 장단점과 함께 알아보겠습니다.


---

## '매핑하지 않기' 전략

첫 번째 전략은 '매핑하지 않기' 전략입니다.

![[Pasted image 20240321011427.png]]

웹 계층에서는 웹 컨트롤러가 SendMoneyUserCase 인터페이스를 호출해서 유스케이스를 실행합니다. 이 인터페이스는 Account 객체를 인자로 가집니다. 즉, 웹 계층과 애플리케이션 계층 모두 Account 클래스에 접근해야 한다는 것입니다.

반대쪽의 영속성 계층과 애플리케이션 계층도 같은 관계입니다. 모든 계층이 같은 모델을 사용하니 계층 간 매핑을 전혀 할 필요가 없습니다.

도메인과 애플리케이션 계층은 웹이나 영속성과 관련된 특수한 요구사항에 관심이 없음에도 불구하고 Account 도메인 모델 클래스는 이런 모든 요구사항을 다뤄야 합니다. Account 클래스는 웹, 애플리케이션, 영속성 계층과 관련된 이유로 인해 변경돼야 하기 때문에 단일 책임 원칙을 위반합니다.

> 이러한 결과로, 오로지 한 계층에서만 필요한 필드들을 포함하는 파편화된 도메인 모델로 이어질 수 있습니다.

모든 계층이 정확히 같은 구조의, 정확히 같은 정보를 필요로 한다면 '매핑하지 않기' 전략은 완벽한 선택지 입니다.

그러나 애플리케이션 계층이나 도메인 계층에서 웹과 영속성 문제를 다루게 되면 곧바로 다른 전략을 취해야 합니다.

> 이쯤에서 앞에서 언급한 두 개발자 의견에 줄 수 있는 교훈은 어떤 매핑 전략을 선택했더라도 나중에 언제든 바꿀 수 있다는 점입니다.

저자의 경험에 의하면 많은 유스케이스들이 간단한 CRUD 유스케이스로 시작했다가 시간이 지남에 따라 값비싼 매핑 전략이 필요한, 풍부한 행동과 유효성 검증을 가진 제대로 된 비즈니스 유스케이스로 바뀌어 갔다고 합니다.


---

## '양방향' 매핑 전략

각 계층이 전용 모델을 가진 매핑 전략을 '양방향' 매핑 전략이라고 합니다.

![[Pasted image 20240321011917.png]]

각 계층은 도메인 모델과는 완전히 다른 구조의 전용 모델을 가지고 있습니다.

웹 계층에서는 웹 모델을 인커밍 포트에서 필요한 도메인 모델로 매핑하고, 인커밍 포트에 의해 반환된 도메인 객체를 다시 웹 모델로 매핑합니다.

영속성 계층은 아웃고잉 포트가 사용하는 도메인 모델과 영속성 모델 간의 매핑과 유사한 매핑을 담당합니다.

두 계층 모두 양방향으로 매핑하기 때문에 '양방향' 매핑이라고 부릅니다.

각 계층이 전용 모델을 가지고 있는 덕분에 각 계층이 전용 모델을 변경하더라도 다른 계층에는 영향이 없습니다. 그래서 웹 모델은 데이터를 최적으로 표현할 수 있는 구조를 가질 수 있고, 도메인 모델은 유스케이스를 제일 잘 구현할 수 있는 구조를 가질 수 있습니다. 그리고 영속성 모델은 데이터베이스에 객체를 저장하기 위해 ORM 에서 필요로 하는 구조를 가질 수 있습니다.

> 이러한 매핑 전략은 웹이나 영속성 관심사로 오염되지 않은 깨끗한 도메인 모델로 이어집니다.

'양방향' 매핑의 또 다른 장점은 개념적으로는 '매핑하지 않기' 전략 다음으로 간단한 전략이라는 것입니다. 매핑 책임이 명확합니다. 즉, 바깥쪽 계층/어댑터는 안쪽 계층의 모델로 매핑하고, 다시 반대 방향으로 매핑합니다. 안쪽 계층은 해당 계층의 모델만 알면 되고 매핑 대신 도메인 로직에 집중할 수 있습니다.

물론 '양방향' 매핑도 단점이 있습니다.

먼저 너무 많은 보일러플레이트 코드가 생깁니다. 또 다른 단점은 도메인 모델이 계층 경계를 넘어서 통신하는 데 사용되고 있다는 것입니다. 인커밍 포트와 아웃고잉 포트는 도메인 객체를 입력 파라미터와 반환값으로 사용합니다. 즉, 도메인 모델은 도메인 모델의 필요에 의해서만 변경되는 것이 이상적이지만 바깥쪽 계층의 요구에 따른 변경에 취약해집니다.

> 결국 어떤 매핑 전략도 철칙처럼 여겨져서는 안 됩니다. 그 대신 각 유스케이스마다 적절한 전략을 택할 수 있어야 합니다.


---

## '완전' 매핑 전략

또 다른 매핑 전략은 '완전' 매핑 전략입니다.

![[Pasted image 20240321012641.png]]

이 매핑 전략에서는 각 연산마다 별도의 입출력 모델을 사용합니다. 계층 경계를 넘어 통신할 때 도메인 모델을 사용하는 대신 위 그림의 SendMoneyUserCase 포트의 입력 모델로 동작하는 SendMoneyCommand 처럼 각 작업에 특화된 모델을 사용합니다. 즉, 각 유스케이스는 전용 필드와 유효성 검증 로직을 가진 전용 커맨드를 갖습니다.

그러고 나서 애플리케이션 계층은 커맨드 객체를 유스케이스에 따라 도메인 모델을 변경하기 위해 필요한 무엇인가로 매핑할 책임을 갖습니다.

당연하겠지만 한 계층을 다른 여러 개의 커맨드로 매핑하는 데는 하나의 웹 모델과 도메인 모델 간의 매핑보다 더 많은 코드가 필요합니다. 하지만 이렇게 매핑하면 여러 유스케이스의 요구사항을 함께 다뤄야 하는 매핑에 비해 구현하고 유지보수하기 훨씬 쉽습니다.

이 매핑 전략을 전역 패턴으로는 추천하지 않습니다. 이 전략은 웹 계층과 애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 빛을 발합니다. 애플리케이션 계층과 영속성 계층 사이에서는 매핑 오버헤드 때문에 사용하지 않는 것이 좋습니다.

또한 어떤 경우에는 연산의 입력 모델에 대해서만 이 매핑을 사용하고, 도메인 객체를 그대로 출력 모델로 사용하는 것도 좋습니다. SendMoneyUseCase가 업데이트된 잔고를 가진 채로 Account 객체를 그대로 반환하는 것처럼 말입니다.

> 이처럼 매핑 전략은 여러 가지를 섞어서 쓸 수 있고, 섞어 써야만 합니다. 어떤 매핑 전략도 모든 계층에 걸쳐 전역 규칙일 필요가 없습니다.


---

## '단방향' 매핑 전략

또 다른 장단점을 지닌 매핑 전략이 하나 더 있습니다. '단방향' 전략입니다.

![[Pasted image 20240321013140.png]]

이 전략에서는 모든 계층의 모델들이 같은 인터페이스를 구현합니다. 이 인터페이스는 관련 있는 특성에 대한 getter 메서드를 제공해서 도메인 모델의 상태를 캡슐화 합니다.

도메인 모델 자체는 풍부한 행동을 구현할 수 있고, 애플리케이션 계층 내의 서비스에서 이러한 행동에 접근할 수 있습니다. 도메인 객체를 바깥 계층으로 전달하고 싶으면 매핑 없이할 수 있습니다. 왜냐하면 도메인 객체가 인커밍/아웃고잉 포트가 기대하는 대로 상태 인터페이스를 구현하고 있기 때문입니다.

그러고 나면 바깥 계층에서는 상태 인터페이스를 이용할지, 전용 모델로 매핑해야 할지 결정할 수 있습니다. 행동을 변경하는 것이 상태 인터페이스에 의해 노출돼 있지 않기 때문에 실수로 도메인 객체의 상태를 변경하는 일은 발생하지 않습니다.

바깥 계층에서 애플리케이션 계층으로 전달하는 객체들도 이 상태 인터페이스를 구현하고 있습니다. 애플리케이션 계층에서는 이 객체를 실제 도메인 모델로 매핑해서 도메인 모델의 행동에 접근할 수 있게 됩니다. 이 매핑은 팩터리라는 DDD 개념과 잘 어울립니다. DDD 용어인 팩터리는 어떤 특정한 상태로부터 도메인 객체를 재구성할 책임을 가지고 있습니다.

이 전략에서 매핑 책임은 명확합니다. 만약 한 계층이 다른 계층으로부터 객체를 받으면 해당 계층에서 이용할 수 있도록 다른 무언가로 매핑하는 것입니다. 그러므로 각 계층은 한 방향으로만 매핑합니다. 그래서 이 전략의 이름이 '단방향' 매핑 전략인 것입니다.

하지만 매핑이 계층을 넘나들며 퍼져 있기 때문에 이 전략은 다른 전략에 비해 개념적으로 어렵습니다.

> 이 전략은 계층 간의 모델이 비슷할 때 가장 효과적입니다.


---

## 언제 어떤 매핑 전략을 사용할 것인가?

각 매핑 전략이 저마다 장단점을 갖고 있기 때문에 한 전략을 전체 코드에 대한 어떤 경우에도 변하지 않는 전역 규칙으로 정의하려는 충동을 이겨내야 합니다.

또한 소프트웨어는 시간이 지나며 변화를 거듭하기 때문에, 어제는 최선이었던 전략이 오늘은 최선이 아닐 수 있습니다. 고정된 매핑 전략으로 계속 유지하기보다는 빠르게 코드를 짤 수 있는 간단한 전략으로 시작해서 계층 간 결합을 떼어내는 데 도움이 되는 복잡한 전략으로 갈아타는 것도 괜찮은 방법입니다.

합의할 수 있는 가이드라인은 아래와 같을 수 있습니다.

'변경 유스케이스'를 작업하고 있다면 웹 계층과 애플리케이션 계층 사이에서는 유스케이스 간의 결합을 제거하기 위해 '완전 매핑' 전략을 첫 번째 선택지로 택해야 합니다. 이렇게 하면 유스케이스별 유효성 검증 규칙이 명확해지고 특정 유스케이스에서 필요하지 않은 필드를 다루지 않아도 됩니다.

'변경 유스케이스'를 작업하고 있다면 애플리케이션과 영속성 계층 사이에서는 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해서 '매핑하지 않기' 전략을 첫 번째 선택지로 둡니다. 하지만 애플리케이션 계층에서 영속성 문제를 다뤄야 하게 되면 '양방향' 매핑 전략으로 바꿔서 영속성 문제를 영속성 계층에 가둘 수 있게 합니다.

'쿼리' 작업을 한다면 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해 '매핑하지 않기' 전략이 웹 계층과 애플리케이션 계층 사이, 애플리케이션 계층과 영속성 계층 사이에서 첫 번째 선택지가 돼야 합니다. 하지만 애플리케이션 계층에서 영속성 문제나 웹 문제를 다뤄야 하게 되면 웹 계층과 애플리케이션 계층, 애플리케이션 계층과 영속성 계층 사이에서 각각 '양방향' 매핑 전략으로 바꿔야 합니다.


---

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

계층 사이에서 문지기처럼 동작하는 인커밍 포트와 아웃고잉 포트는 서로 다른 계층이 어떻게 통신해야 하는지를 정의합니다. 여기에는 계층 사이에 매핑을 수행할지 여부와 어떤 매핑 전략을 선택할지가 포함됩니다.

각 유스케이스에 대해 좁은 포트를 사용하면 유스케이스마다 다른 매핑 전략을 사용할 수 있고, 다른 유스케이스에 영향을 미치지 않으면서 코드를 개선할 수 있기 때문에 특정 상황, 특정 시점에 최선의 전략을 선택할 수 있습니다.

상황별로 매핑 전략을 선택하는 것은 모든 상황에 같은 매핑 전략을 사용하는 것보다 분명 더 어렵고 더 많은 커뮤니케이션을 필요로 하겠지만 매핑 가이드라인이 있는 한, 코드가 정확히 해야 하는 일만 수행하면서도 더 유지보수하기 쉬운 코드로 팀에 보상이 되어 돌아올 것입니다.