
오늘날의 애플리케이션은 대부분 웹 인터페이스 같은 것을 제공합니다. 웹 브라우저를 통해 상호작용할 수 있는 UI나 다른 시스템에서 우리 애플리케이션으로 호출하는 방식으로 상호작용하는 HTTP API가 여기에 해당합니다.

우리가 목표로 하는 아키텍처에서 외부 세계와의 모든 커뮤니케이션은 어댑터를 통해 이뤄집니다. 따라서 이번에는 웹 인터페이스를 제공하는 어댑터의 구현 방법을 살펴보겠습니다.


---

## 의존성 역전

![[Pasted image 20240311223331.png]]

웹 어댑터는 '주도하는' 혹은 '인커밍' 어댑터입니다. 외부로부터 요청을 받아 애플리케이션 코어를 호출하고 무슨 일을 해야 할지 알려줍니다. 이때 제어 흐름은 웹 어댑터에 있는 컨트롤러에서 애플리케이션 계층에 있는 서비스로 흐릅니다.

애플리케이션 계층은 웹 어댑터가 통신할 수 있는 특정 포트를 제공합니다. 서비스는 이 포트를 구현하고, 웹 어댑터는 이 포트를 호출할 수 있습니다.

사실 어댑터와 유스케이스 사이에 또 다른 간접 계층을 넣어야 할까?? 애플리케이션 코어가 외부 세계와 통신할 수 있는 곳에 대한 명세가 포트이기 때문입니다. 포트를 적절한 곳에 위치시키면 외부와 어떤 통신이 일어나고 있는지 정확히 알 수 있고, 이는 레거시 코드를 다루는 유지보수 엔지니어에게는 무척 소중한 정보입니다.

> 이렇게 말하긴 했지만 인커밍 포트를 생략하고 애플리케이션 서비스를 직접 호출하고 싶은 생각도 들 것입니다. 이 지름길에 대해서는 11장에서 이야기합니다.


---

## 웹 어댑터의 책임

웹 어댑터는 일반적으로 다음과 같은 일을 합니다.

1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입력 유효성 검증
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스의 출력을 HTTP로 매핑
7. HTTP 응답을 반환

우선 웹 어댑터는 URL, 경로, HTTP 메서드, 콘텐츠 타입과 같이 특정 기준을 만족하는 HTTP 요청을 수신해야 합니다. 그러고 나서 HTTP 요청의 파라미터와 콘텐츠를 객체로 역직렬화해야 합니다.

보통은 웹 어댑터가 인증과 권한 부여를 수행하고 실패할 경우 에러를 반환합니다.

그러고 나면 들어오는 객체의 상태 유효성 검증을 할 수 있습니다. 그런데 앞에서 입력 유효성 검증이 유스케이스 입력 모델의 책임이라고 이야기하지 않았는가? 유스케이스 입력 모델은 유스케이스의 맥락에서 유효한 입력만 허용해야 합니다. 그러나 여기서는 웹 어댑터의 입력 모델에 대해 이야기하고 있는 것입니다.

> 유스케이스의 입력 모델과는 구조나 의미가 완전히 다를 수 있으므로 또 다른 유효성 검증을 수행해야 합니다.

유스케이스 입력 모델에서 했던 유효성 검증을 똑같이 웹 어댑터에서도 구현해야 하는 것은 아닙니다. 대신 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증해야 합니다.

이는 자연스럽게 웹 어댑터의 다음 책임, 즉 변환된 입력 모델로 특정한 유스케이스를 호출하는 것으로 연결됩니다. 어댑터는 유스케이스의 출력을 반환받고, HTTP 응답으로 직렬화해서 호출자에게 전달합니다.

웹 어댑터의 어깨를 짓누를 정도로 책임이 많기는 합니다. 하지만 이 책임들은 애플리케이션 계층이 신경 쓰면 안 되는 것들이기도 합니다. HTTP와 관련된 것은 애플리케이션 계층으로 침투해서는 안 됩니다.

> 웹 어댑터와 애플리케이션 계층 간의 이 같은 경계는 웹 계층에서부터 개발을 시작하는 대신 도메인과 애플리케이션 계층부터 개발하기 시작하면 자연스럽게 생깁니다.


---

## 컨트롤러 나누기

자바의 스프링 MVC 같은 대부분의 웹 프레임워크에서는 앞서 논의한 책임들을 수행할 컨트롤러 클래스를 생성할 수 있습니다. 웹 어댑터는 한 개 이상의 클래스로 구성해도 됩니다. 하지만 앞 3장에서 이야기했듯이 클래스들이 같은 소속이라는 것을 표현하기 위해 같은 패키지 수준에 놓아야 합니다.

컨트롤러는 너무 적은 것보다는 너무 많은 게 낫습니다. 각 컨트롤러가 가능한 한 좁고 다른 컨트롤러와 가능한 한 적게 공유하는 웹 어댑터 조각을 구현해야 합니다.

컨트롤러를 가능한 한 작게 하는것에 대한 장점은 아래와 같습니다.

- 특정 프로덕션 코드에 해당하는 테스트 코드를 찾기 쉽습니다.
- 모든 연산을 단일 컨트롤러에 넣는 것이 데이터 구조의 재활용을 촉진합니다.
- 서로 다른 연산에 대한 동시 작업이 쉬워집니다.

> 저자는 각 연산에 대해 가급적이면 별도의 패키지 안에 별도의 컨트롤러를 만드는 방식을 선호합니다.


---

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

애플리케이션의 웹 어댑터를 구현할 때는 HTTP 요청을 애플리케이션의 유스케이스에 대한 메서드 호출로 변환하고 결과를 다시 HTTP로 변환하고 어떤 도메인 로직도 수행하지 않는 어댑터를 만들고 있다는 점을 염두에 둬야 합니다.

반면, 애플리케이션 계층은 HTTP에 대한 상세 정보를 노출시키지 않도록 HTTP와 관련된 작업을 해서는 안 됩니다. 이렇게 하면 필요할 경우 웹 어댑터를 다른 어댑터로 쉽게 교체할 수 있습니다.

웹 컨트롤러를 나눌 때는 모델을 공유하지 않는 여러 작은 클래스들을 만드는 것을 두려워해서는 안 됩니다. 작은 클래스들은 더 파악하기 쉽고, 더 테스트하기 쉬우며, 동시 작업을 지원합니다. 이렇게 세분화된 컨트롤러를 만드는 것은 처음에는 조금 더 공수가 들겠지만 유지보수하는 동안에는 분명이 빛을 발할 것입니다.